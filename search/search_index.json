{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Teal Agents","text":""},{"location":"#chat-completion-factories","title":"Chat Completion Factories","text":""},{"location":"#background","title":"Background","text":"<p>If you hadn't noticed, Teal Agents Framework is built on top of the open source Semantic Kernel library. Semantic Kernel leverages the concept of the Kernel to which certain capabilities are added, which can then be used to interact with LLMs for things like agents.</p> <p>One of the core components you add to a Kernel is the ChatCompletionClient. This object provides connection details to the specific LLM you want to enable for a given Kernel (and in this context, an Agent). ChatCompletionClient's come in many flavors with the ability to connect to things like standard OpenAI APIs, Azure OpenAI and Anthropic APIs, Anthropic APIs, Ollama APIs, etc. Due to the early nature of this product, there is limited, in-built support for the different model hosting options (indeed only standard OpenAI at the time of writing).</p>"},{"location":"#chatcompletion-factories","title":"ChatCompletion Factories","text":"<p>In the <code>ska_types</code> module, there is defined a ChatCompletionFactory abstract class. Within the <code>chat_completion</code> package, there is a default implementation of this class called <code>DefaultChatCompletionFactory</code>. Standard, widely supported ChatCompletions should be included here, and we welcome contributions to build out the available standard models.</p>"},{"location":"#custom-factories","title":"Custom Factories","text":"<p>There is also the ability for users to add a supplementary ChatCompletionFactory of their own writing. To do so, you'll need to create a module with a class that extends the ChatCompletionFactory abstract class and implement three methods:</p> <ul> <li><code>get_configs</code> - Static method you should implement if your chat completions    require additional configuration (via environment variables).</li> <li><code>get_chat_completion_for_model_name</code> - Method that returns an instance of   <code>ChatCompletionClientBase</code> for connecting to a model with a given name. When   implemented, the model name can then be used for an agent's <code>model</code> property   in the agent config YAML.</li> <li><code>get_model_type_for_name</code> - Method that returns the appropriate <code>ModelType</code>    for a given model name. This is currently only used to determine the correct    way to calculate the token usage for a model response and if someone can    think of a better way to do it, I'd like this method to go away.</li> </ul> <p>Once you've created your custom factory, enable it by setting the two following environment variables:</p> <ul> <li>TA_CUSTOM_CHAT_COMPLETION_FACTORY_MODULE - The relative path to the python   file containing your factory class</li> <li>TA_CUSTOM_CHAT_COMPLETION_FACTORY_CLASS_NAME - The class name of your custom   factory class</li> </ul> <p>Once enabled, you have the ability to use any model your factory can handle with a given agent by specifying the model name in the <code>model</code> field of the agent's YAML configuration.</p> <p>Included is an example of a custom chat completion factory (non-working unless you have Azure OpenAI endpoints): </p>"},{"location":"#sk_agents.chat_completion.custom.example_custom_chat_completion_factory.ExampleCustomChatCompletionFactory","title":"sk_agents.chat_completion.custom.example_custom_chat_completion_factory.ExampleCustomChatCompletionFactory","text":"<p>               Bases: <code>ChatCompletionFactory</code></p> Source code in <code>src/sk_agents/chat_completion/custom/example_custom_chat_completion_factory.py</code> <pre><code>class ExampleCustomChatCompletionFactory(ChatCompletionFactory):\n    _OPENAI_MODELS: list[str] = [\n        \"gpt-35-turbo-1106\",\n        \"gpt-35-turbo-0125\",\n        \"gpt-4o-2024-05-13\",\n        \"gpt-4o-2024-08-06\",\n        \"gpt-4o-mini-2024-07-18\",\n        \"gpt-4-turbo-2024-04-09\",\n    ]\n    _ANTHROPIC_MODELS: list[str] = [\n        \"claude-3-5-sonnet-20240620\",\n        \"claude-3-haiku-20240307\",\n    ]\n\n    _GOOGLE_MODELS: list[str] = [\n        \"gemini-2-5-pro-preview-03-25\",\n        \"gemini-2-5-flash-preview-04-17\",\n        \"gemini-2-0-flash\",\n        \"gemini-2-0-flash-lite\",\n    ]\n\n    TA_BASE_URL = UtilConfig(\n        env_name=\"TA_BASE_URL\",\n        is_required=False,\n        default_value=\"https://&lt;Your AI Service Endpoint&gt;\",\n    )\n    TA_API_VERSION = UtilConfig(\n        env_name=\"TA_API_VERSION\", is_required=False, default_value=\"2024-10-21\"\n    )\n\n    _CONFIGS: list[UtilConfig] = [TA_BASE_URL, TA_API_VERSION]\n\n    def __init__(self, app_config: AppConfig):\n        super().__init__(app_config)\n        self.api_key = app_config.get(TA_API_KEY.env_name)\n        self.url_base = app_config.get(ExampleCustomChatCompletionFactory.TA_BASE_URL.env_name)\n        self.api_version = app_config.get(\n            ExampleCustomChatCompletionFactory.TA_API_VERSION.env_name\n        )\n\n    @staticmethod\n    def get_configs() -&gt; list[UtilConfig]:\n        return ExampleCustomChatCompletionFactory._CONFIGS\n\n    def get_chat_completion_for_model_name(\n        self, model_name: str, service_id: str\n    ) -&gt; ChatCompletionClientBase:\n        if model_name in ExampleCustomChatCompletionFactory._OPENAI_MODELS:\n            return AzureChatCompletion(\n                service_id=service_id,\n                deployment_name=model_name,\n                api_key=self.api_key,\n                base_url=f\"{self.url_base}/openai\",\n                api_version=self.api_version,\n            )\n        elif model_name in ExampleCustomChatCompletionFactory._ANTHROPIC_MODELS:\n            return AnthropicChatCompletion(\n                service_id=service_id,\n                api_key=\"unused\",\n                ai_model_id=model_name,\n                async_client=AsyncAnthropic(\n                    api_key=\"unused\",\n                    base_url=f\"{self.url_base}/anthropic/{model_name}-v1\",\n                    default_headers={\"X-Custom-Header\": self.api_key},\n                ),\n            )\n        elif model_name in ExampleCustomChatCompletionFactory._GOOGLE_MODELS:\n            return GoogleAIChatCompletion(\n                service_id=service_id,\n                deployment_name=model_name,\n                api_key=self.api_key,\n            )\n        else:\n            raise ValueError(\"Model type not supported\")\n\n    def get_model_type_for_name(self, model_name: str) -&gt; ModelType:\n        if model_name in ExampleCustomChatCompletionFactory._OPENAI_MODELS:\n            return ModelType.OPENAI\n        elif model_name in ExampleCustomChatCompletionFactory._ANTHROPIC_MODELS:\n            return ModelType.ANTHROPIC\n        elif model_name in ExampleCustomChatCompletionFactory._GOOGLE_MODELS:\n            return ModelType.GOOGLE\n        else:\n            raise ValueError(f\"Unknown model name {model_name}\")\n\n    def model_supports_structured_output(self, model_name: str) -&gt; bool:\n        if model_name in ExampleCustomChatCompletionFactory._OPENAI_MODELS:\n            return True\n        elif model_name in ExampleCustomChatCompletionFactory._ANTHROPIC_MODELS:\n            return False\n        elif model_name in ExampleCustomChatCompletionFactory._GOOGLE_MODELS:\n            return True\n        else:\n            raise ValueError(f\"Unknown model name {model_name}\")\n</code></pre>"},{"location":"#notes","title":"Notes","text":"<ol> <li>A custom factory takes precedence over the default factory, so if your    factory provides a chat completion with a model name matching one in the    default factory, yours will be selected.</li> <li>While not exactly on-topic, there is an additional configuration property    <code>TA_STRUCTURED_OUTPUT_TRANSFORMER_MODEL</code> which specifies which model should    be used to convert agent results in to structured output whenever an    <code>output_type</code> is defined. This defaults to <code>openai-gpt-4o</code> but if you've    implemented a custom factory, you can override this property to be one of    your models.</li> </ol>"},{"location":"reference/","title":"sk-agents","text":""},{"location":"reference/#sk_agents","title":"sk_agents","text":""},{"location":"reference/#sk_agents.a2a","title":"sk_agents.a2a","text":"sk_agents.a2a.redis_task_store <p>DEPRECATION NOTICE: A2A (Agent-to-Agent) functionality is being deprecated as part of the framework migration evaluation. This module is maintained for backward compatibility only. New development should avoid using A2A functionality.</p> <p>Redis implementation of the TaskStore interface. This implementation uses Redis as the persistent store for Task objects.</p> sk_agents.a2a.redis_task_store.RedisTaskStore <p>               Bases: <code>TaskStore</code></p> <p>Redis implementation of the TaskStore interface.</p> <p>This class provides Redis-based persistence for Task objects.</p> Source code in <code>src/sk_agents/a2a/redis_task_store.py</code> <pre><code>class RedisTaskStore(TaskStore):\n    \"\"\"Redis implementation of the TaskStore interface.\n\n    This class provides Redis-based persistence for Task objects.\n    \"\"\"\n\n    def __init__(self, redis_client: Redis, ttl: int | None = None, key_prefix: str = \"task:\"):\n        \"\"\"Initialize the RedisTaskStore with a Redis client.\n\n        Args:\n            redis_client: An instance of Redis client\n            key_prefix: Prefix used for Redis keys (default: \"task:\")\n        \"\"\"\n        self._redis = redis_client\n        self._ttl = ttl\n        self._key_prefix = key_prefix\n\n    def _get_key(self, task_id: str) -&gt; str:\n        \"\"\"Generate a Redis key for a given task ID.\n\n        Args:\n            task_id: The ID of the task\n\n        Returns:\n            A Redis key string\n        \"\"\"\n        return f\"{self._key_prefix}{task_id}\"\n\n    async def save(self, task: Task):\n        \"\"\"Saves or updates a task in the Redis store.\n\n        Args:\n            task: The Task object to save\n        \"\"\"\n        # Convert the Task object to a serializable dictionary\n        task_dict = task.model_dump(mode=\"json\")\n\n        # Serialize the task dictionary to JSON\n        task_json = json.dumps(task_dict)\n\n        # Store the serialized task in Redis using the task ID as the key\n        await self._redis.set(self._get_key(task.id), task_json, ex=self._ttl)\n\n    async def get(self, task_id: str) -&gt; Task | None:\n        \"\"\"Retrieves a task from the Redis store by ID.\n\n        Args:\n            task_id: The ID of the task to retrieve\n\n        Returns:\n            The Task object if found, None otherwise\n        \"\"\"\n        # Get the serialized task from Redis\n        task_json = await self._redis.get(self._get_key(task_id))\n\n        if task_json is None:\n            return None\n\n        # Deserialize the JSON string to a dictionary\n        task_dict = json.loads(task_json)\n\n        # Create and return a Task object from the dictionary\n        return Task.model_validate(task_dict)\n\n    async def delete(self, task_id: str):\n        \"\"\"Deletes a task from the Redis store by ID.\n\n        Args:\n            task_id: The ID of the task to delete\n        \"\"\"\n        # Delete the task from Redis\n        await self._redis.delete(self._get_key(task_id))\n</code></pre> <code></code> sk_agents.a2a.redis_task_store.RedisTaskStore.__init__ <pre><code>__init__(\n    redis_client: Redis,\n    ttl: int | None = None,\n    key_prefix: str = \"task:\",\n)\n</code></pre> <p>Initialize the RedisTaskStore with a Redis client.</p> <p>Parameters:</p> Name Type Description Default <code>redis_client</code> <code>Redis</code> <p>An instance of Redis client</p> required <code>key_prefix</code> <code>str</code> <p>Prefix used for Redis keys (default: \"task:\")</p> <code>'task:'</code> Source code in <code>src/sk_agents/a2a/redis_task_store.py</code> <pre><code>def __init__(self, redis_client: Redis, ttl: int | None = None, key_prefix: str = \"task:\"):\n    \"\"\"Initialize the RedisTaskStore with a Redis client.\n\n    Args:\n        redis_client: An instance of Redis client\n        key_prefix: Prefix used for Redis keys (default: \"task:\")\n    \"\"\"\n    self._redis = redis_client\n    self._ttl = ttl\n    self._key_prefix = key_prefix\n</code></pre> <code></code> sk_agents.a2a.redis_task_store.RedisTaskStore.save <code>async</code> <pre><code>save(task: Task)\n</code></pre> <p>Saves or updates a task in the Redis store.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>The Task object to save</p> required Source code in <code>src/sk_agents/a2a/redis_task_store.py</code> <pre><code>async def save(self, task: Task):\n    \"\"\"Saves or updates a task in the Redis store.\n\n    Args:\n        task: The Task object to save\n    \"\"\"\n    # Convert the Task object to a serializable dictionary\n    task_dict = task.model_dump(mode=\"json\")\n\n    # Serialize the task dictionary to JSON\n    task_json = json.dumps(task_dict)\n\n    # Store the serialized task in Redis using the task ID as the key\n    await self._redis.set(self._get_key(task.id), task_json, ex=self._ttl)\n</code></pre> <code></code> sk_agents.a2a.redis_task_store.RedisTaskStore.get <code>async</code> <pre><code>get(task_id: str) -&gt; Task | None\n</code></pre> <p>Retrieves a task from the Redis store by ID.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to retrieve</p> required <p>Returns:</p> Type Description <code>Task | None</code> <p>The Task object if found, None otherwise</p> Source code in <code>src/sk_agents/a2a/redis_task_store.py</code> <pre><code>async def get(self, task_id: str) -&gt; Task | None:\n    \"\"\"Retrieves a task from the Redis store by ID.\n\n    Args:\n        task_id: The ID of the task to retrieve\n\n    Returns:\n        The Task object if found, None otherwise\n    \"\"\"\n    # Get the serialized task from Redis\n    task_json = await self._redis.get(self._get_key(task_id))\n\n    if task_json is None:\n        return None\n\n    # Deserialize the JSON string to a dictionary\n    task_dict = json.loads(task_json)\n\n    # Create and return a Task object from the dictionary\n    return Task.model_validate(task_dict)\n</code></pre> <code></code> sk_agents.a2a.redis_task_store.RedisTaskStore.delete <code>async</code> <pre><code>delete(task_id: str)\n</code></pre> <p>Deletes a task from the Redis store by ID.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to delete</p> required Source code in <code>src/sk_agents/a2a/redis_task_store.py</code> <pre><code>async def delete(self, task_id: str):\n    \"\"\"Deletes a task from the Redis store by ID.\n\n    Args:\n        task_id: The ID of the task to delete\n    \"\"\"\n    # Delete the task from Redis\n    await self._redis.delete(self._get_key(task_id))\n</code></pre> <code></code> sk_agents.a2a.response_classifier <code></code> sk_agents.a2a.response_classifier.A2AResponseClassifier <p>A class to classify responses from the A2A agent.</p> Source code in <code>src/sk_agents/a2a/response_classifier.py</code> <pre><code>class A2AResponseClassifier:\n    \"\"\"\n    A class to classify responses from the A2A agent.\n    \"\"\"\n\n    NAME = \"a2a-response-classifier\"\n    SYSTEM_PROMPT = (\n        \"## System Prompt: Agent Output Classifier\\n\"\n        \"\\n\"\n        \"**You are an AI agent tasked with analyzing the output of another AI agent \"\n        '(referred to as the \"Primary Agent\") and classifying its status. Your output MUST '\n        \"be a JSON object.**\\n\"\n        \"\\n\"\n        \"Your goal is to determine which of the following categories best describes \"\n        \"the Primary Agent's output and structure your response accordingly.\\n\"\n        \"\\n\"\n        \"**Possible Classification Statuses &amp; JSON Output Structures:**\\n\"\n        \"\\n\"\n        \"1.  **Status: `completed`**\\n\"\n        \"    * The Primary Agent has successfully completed the assigned task or answered the \"\n        \"user's query.\\n\"\n        \"    * **JSON Output Structure:**\\n\"\n        \"        ```json\\n\"\n        \"        {\\n\"\n        '          \"status\": \"completed\"\\n'\n        \"        }\\n\"\n        \"        ```\\n\"\n        '    * Keywords/phrases to look for: \"done,\" \"completed,\" \"finished,\" \"success,\" '\n        '\"here is the result,\" \"I have finished,\" \"the task is complete,\" direct answers '\n        \"to questions, generated content that fulfills the request.\\n\"\n        \"    * Context: The output clearly indicates finality and achievement of the original \"\n        \"goal.\\n\"\n        \"\\n\"\n        \"2.  **Status: `failed`**\\n\"\n        \"    * The Primary Agent has failed to complete the assigned task or answered the \"\n        \"user's query.\\n\"\n        \"    * **JSON Output Structure:**\\n\"\n        \"        ```json\\n\"\n        \"        {\\n\"\n        '          \"status\": \"failed\"\\n'\n        \"        }\\n\"\n        \"        ```\\n\"\n        '    * Keywords/phrases to look for: \"failed,\" \"unable to,\" \"cannot complete,\" '\n        '\"error,\" \"encountered a problem,\" \"not possible,\" \"I\\'m sorry, I can\\'t,\" '\n        '\"task aborted.\"\\n'\n        \"    * Context: The output indicates an inability to proceed or a definitive negative \"\n        \"outcome regarding the task. This includes technical errors, lack of capability, \"\n        \"or hitting a dead end.\\n\"\n        \"\\n\"\n        \"3.  **Status: `input-required`**\\n\"\n        \"    * The Primary Agent requires additional information, clarification, or a decision \"\n        \"from the user to continue or complete the task.\\n\"\n        \"    * **JSON Output Structure:**\\n\"\n        \"        ```json\\n\"\n        \"        {\\n\"\n        '          \"status\": \"input-required\",\\n'\n        '          \"message\": \"A description of what info is needed from the user and why.\"\\n'\n        \"        }\\n\"\n        \"        ```\\n\"\n        '    * Keywords/phrases to look for: \"what do you mean by,\" \"could you please '\n        'specify,\" \"which option do you prefer,\" \"do you want to proceed,\" \"please '\n        'provide,\" \"I need more information,\" questions directed at the user.\\n'\n        \"    * Context: The output is a direct or indirect request for user interaction to \"\n        \"resolve ambiguity, make a choice, or provide necessary data. The `message` field \"\n        \"should summarize this request.\\n\"\n        \"\\n\"\n        \"4.  **Status: `auth-required`**\\n\"\n        \"    * The Primary Agent has indicated that it needs to perform some form of \"\n        \"authentication (e.g., login, API key verification, permission grant) before it \"\n        \"can proceed with the task.\\n\"\n        \"    * **JSON Output Structure:**\\n\"\n        \"        ```json\\n\"\n        \"        {\\n\"\n        '          \"status\": \"auth-required\",\\n'\n        '          \"message\": \"A description of what authentication is needed and why.\",\\n'\n        '          \"auth_details\": {} // Likely a JSON structure extracted from the Primary '\n        \"Agent's output containing technical details about the auth request. Can be an \"\n        \"empty object if no specific structure is found.\\n\"\n        \"        }\\n\"\n        \"        ```\\n\"\n        '    * Keywords/phrases to look for: \"please log in,\" \"authentication required,\" '\n        '\"access denied,\" \"invalid credentials,\" \"API key needed,\" \"sign in to continue,\" '\n        '\"verify your identity,\" \"permissions needed.\"\\n'\n        \"    * Context: The output explicitly states or strongly implies that a security or \"\n        \"access barrier is preventing task progression. The `message` field should explain \"\n        \"this. The `auth_details` field should attempt to capture any structured information \"\n        \"(e.g., OAuth URLs, scopes needed, realm info) provided by the Primary Agent \"\n        \"regarding the authentication. If the Primary Agent provides a JSON blob related to \"\n        \"auth, try to pass that through in `auth_details`.\\n\"\n        \"\\n\"\n        \"**Your Analysis Process:**\\n\"\n        \"\\n\"\n        \"1.  **Carefully review the entire output from the Primary Agent.** Understand the \"\n        \"context and the overall message.\\n\"\n        \"2.  **Look for explicit keywords and phrases** associated with each category.\\n\"\n        \"3.  **Consider the intent** behind the Primary Agent's message.\\n\"\n        \"4.  **Prioritize:**\\n\"\n        \"    * If authentication is mentioned as a blocker, classify as `auth-required`. \"\n        \"Extract relevant details for the `message` and `auth_details` fields.\\n\"\n        \"    * If the agent is clearly asking the user a question to proceed (and it's not \"\n        \"primarily an authentication request), classify as `input-required`. Formulate the \"\n        \"`message` field.\\n\"\n        \"    * If the agent explicitly states success, classify as `completed`.\\n\"\n        \"    * If the agent explicitly states failure or an insurmountable error (not related \"\n        \"to needing input or auth), classify as `failed`.\\n\"\n        \"5.  **Extract Information for `message` and `auth_details`:**\\n\"\n        \"    * For `input-required` and `auth-required`, the `message` should be a concise \"\n        \"explanation derived from the Primary Agent's output.\\n\"\n        \"    * For `auth-required`, if the Primary Agent's output includes a structured \"\n        \"(e.g., JSON) segment detailing the authentication requirements, attempt to extract \"\n        \"and place this into the `auth_details` field. If no specific structure is found, \"\n        \"`auth_details` can be an empty object `{}`. Do not invent details; only extract \"\n        \"what is provided.\\n\"\n        \"6.  **If the output is ambiguous, try to infer the most likely category.** If truly \"\n        'unclear, you may need a default or \"UNCLEAR\" category (though this prompt focuses '\n        \"on the four defined). In such a case, defaulting to `failed` with an appropriate \"\n        \"message might be a safe fallback if no other category fits.\\n\"\n        \"\\n\"\n        \"**Output Format:**\\n\"\n        \"\\n\"\n        \"Your output **MUST** be a single JSON object corresponding to one of the structures \"\n        \"defined above.\\n\"\n        \"\\n\"\n        \"**Example Scenarios:**\\n\"\n        \"\\n\"\n        \"* **Primary Agent Output:** \\\"I've finished generating the report you asked for. \"\n        \"It's attached below.\\\"\\n\"\n        \"    * **Your JSON Output:**\\n\"\n        \"        ```json\\n\"\n        \"        {\\n\"\n        '          \"status\": \"completed\"\\n'\n        \"        }\\n\"\n        \"        ```\\n\"\n        \"* **Primary Agent Output:** \\\"I'm sorry, I encountered an unexpected error and cannot \"\n        'process your request at this time. Error code: 503. Please try again later.\"\\n'\n        \"    * **Your JSON Output:**\\n\"\n        \"        ```json\\n\"\n        \"        {\\n\"\n        '          \"status\": \"failed\"\\n'\n        \"        }\\n\"\n        \"        ```\\n\"\n        '* **Primary Agent Output:** \"To help you with that, could you please tell me which '\n        'specific date range you are interested in for the sales data?\"\\n'\n        \"    * **Your JSON Output:**\\n\"\n        \"        ```json\\n\"\n        \"        {\\n\"\n        '          \"status\": \"input-required\",\\n'\n        '          \"message\": \"The agent needs to know the specific date range for the sales '\n        'data to proceed.\"\\n'\n        \"        }\\n\"\n        \"        ```\\n\"\n        '* **Primary Agent Output:** \"Access to this API endpoint requires authentication. '\n        \"Please provide a valid Bearer token. Details: {'type': 'Bearer', 'realm': \"\n        \"'[api.example.com/auth](https://api.example.com/auth)'}}\\\"\\n\"\n        \"    * **Your JSON Output:**\\n\"\n        \"        ```json\\n\"\n        \"        {\\n\"\n        '          \"status\": \"auth-required\",\\n'\n        '          \"message\": \"Access to the API endpoint requires a valid Bearer token.\",\\n'\n        '          \"auth_details\": {\\n'\n        '            \"type\": \"Bearer\",\\n'\n        '            \"realm\": \"[api.example.com/auth](https://api.example.com/auth)\"\\n'\n        \"          }\\n\"\n        \"        }\\n\"\n        \"        ```\\n\"\n        '* **Primary Agent Output:** \"You need to sign in to your account to access your '\n        'profile. Click here to login.\"\\n'\n        \"    * **Your JSON Output:**\\n\"\n        \"        ```json\\n\"\n        \"        {\\n\"\n        '          \"status\": \"auth-required\",\\n'\n        '          \"message\": \"User needs to sign in to their account to access their profile.\",\\n'\n        '          \"auth_details\": {}\\n'\n        \"        }\\n\"\n        \"        ```\\n\"\n        \"\\n\"\n        \"**Critical Considerations:**\\n\"\n        \"\\n\"\n        \"* Ensure your output is always valid JSON.\\n\"\n        \"* Be precise in your classification and in the information extracted for the `message` \"\n        \"and `auth_details` fields.\\n\"\n        \"* Focus solely on the provided output from the Primary Agent.\\n\"\n        \"* Adhere to the prioritization logic.\\n\"\n    )\n\n    def __init__(self, app_config: AppConfig, chat_completion_builder: ChatCompletionBuilder):\n        model_name = app_config.get(TA_A2A_OUTPUT_CLASSIFIER_MODEL.env_name)\n        chat_completion = chat_completion_builder.get_chat_completion_for_model(\n            service_id=self.NAME, model_name=model_name\n        )\n        kernel = Kernel()\n        kernel.add_service(chat_completion)\n        settings = kernel.get_prompt_execution_settings_from_service_id(self.NAME)\n        settings.response_format = A2AResponseClassification\n        self.agent = ChatCompletionAgent(\n            kernel=kernel,\n            name=self.NAME,\n            instructions=self.SYSTEM_PROMPT,\n            arguments=KernelArguments(settings=settings),\n        )\n\n    async def classify_response(self, response: str) -&gt; A2AResponseClassification:\n        \"\"\"\n        Classify the response from the A2A agent.\n\n        Args:\n            response (str): The response from the A2A agent.\n\n        Returns:\n            str: The classification of the response.\n        \"\"\"\n        chat_history = ChatHistory()\n        chat_history.add_user_message(f\"Please classify the following response:\\n\\n{response}\")\n        async for content in self.agent.invoke(messages=chat_history):\n            data = json.loads(str(content.content))\n            return A2AResponseClassification(**data)\n        return A2AResponseClassification(\n            status=A2AResponseStatus.failed,\n            message=\"No response received from response classifier.\",\n        )\n</code></pre> <code></code> sk_agents.a2a.response_classifier.A2AResponseClassifier.classify_response <code>async</code> <pre><code>classify_response(\n    response: str,\n) -&gt; A2AResponseClassification\n</code></pre> <p>Classify the response from the A2A agent.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>The response from the A2A agent.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>A2AResponseClassification</code> <p>The classification of the response.</p> Source code in <code>src/sk_agents/a2a/response_classifier.py</code> <pre><code>async def classify_response(self, response: str) -&gt; A2AResponseClassification:\n    \"\"\"\n    Classify the response from the A2A agent.\n\n    Args:\n        response (str): The response from the A2A agent.\n\n    Returns:\n        str: The classification of the response.\n    \"\"\"\n    chat_history = ChatHistory()\n    chat_history.add_user_message(f\"Please classify the following response:\\n\\n{response}\")\n    async for content in self.agent.invoke(messages=chat_history):\n        data = json.loads(str(content.content))\n        return A2AResponseClassification(**data)\n    return A2AResponseClassification(\n        status=A2AResponseStatus.failed,\n        message=\"No response received from response classifier.\",\n    )\n</code></pre>"},{"location":"reference/#sk_agents.appv3","title":"sk_agents.appv3","text":"class AppV3 <p>@staticmethod def run(name, version, app_config, config, app):     pass</p>"},{"location":"reference/#sk_agents.auth_storage","title":"sk_agents.auth_storage","text":"sk_agents.auth_storage.auth_storage_factory sk_agents.auth_storage.auth_storage_factory.AuthStorageFactory Source code in <code>src/sk_agents/auth_storage/auth_storage_factory.py</code> <pre><code>class AuthStorageFactory(metaclass=Singleton):\n    def __init__(self, app_config: AppConfig):\n        self.app_config = app_config\n\n        # Try to load custom module, fallback to default if not configured\n        module_name, class_name = self._get_custom_auth_storage_config()\n        if module_name and class_name:\n            try:\n                self.module = ModuleLoader.load_module(module_name)\n            except Exception as e:\n                raise ImportError(f\"Failed to load module '{module_name}': {e}\") from e\n\n            self.class_name = class_name\n            self._validate_custom_class()\n        else:\n            self.module = None\n            self.class_name = None\n\n    def get_auth_storage_manager(self) -&gt; SecureAuthStorageManager:\n        if self.module and self.class_name:\n            # Use custom implementation\n            custom_class = getattr(self.module, self.class_name)\n            try:\n                return custom_class(app_config=self.app_config)\n            except TypeError:\n                # Fallback if app_config not accepted\n                return custom_class()\n        else:\n            # Use default implementation\n            return InMemorySecureAuthStorageManager()\n\n    def _get_custom_auth_storage_config(self) -&gt; tuple[str | None, str | None]:\n        \"\"\"Get custom auth storage configuration, returning None values if not configured.\"\"\"\n        try:\n            module_name = self.app_config.get(TA_AUTH_STORAGE_MANAGER_MODULE.env_name)\n        except KeyError:\n            return None, None\n\n        try:\n            class_name = self.app_config.get(TA_AUTH_STORAGE_MANAGER_CLASS.env_name)\n        except KeyError:\n            if module_name:\n                raise ValueError(\"Custom Auth Storage Manager class name not provided\") from None\n            return None, None\n\n        return module_name, class_name\n\n    def _validate_custom_class(self):\n        \"\"\"Validate that the custom class is a proper SecureAuthStorageManager subclass.\"\"\"\n        if not hasattr(self.module, self.class_name):\n            module_name = getattr(self.module, \"__name__\", \"unknown module\")\n            raise ValueError(\n                f\"Custom Auth Storage Manager class: {self.class_name} \"\n                f\"Not found in module: {module_name}\"\n            )\n\n        custom_class = getattr(self.module, self.class_name)\n        if not issubclass(custom_class, SecureAuthStorageManager):\n            raise TypeError(\n                f\"Class '{self.class_name}' is not a subclass of SecureAuthStorageManager.\"\n            )\n</code></pre> <code></code> sk_agents.auth_storage.custom <code></code> sk_agents.auth_storage.custom.example_redis_auth_storage <p>Complete Redis Authentication Storage Implementation</p> <p>This example demonstrates a full-featured, production-ready Redis-based authentication storage implementation. It serves as a complete alternative to the default in-memory storage.</p> <p>To use this implementation, set the following environment variables:</p> <p>TA_AUTH_STORAGE_MANAGER_MODULE=src/sk_agents/auth_storage/custom/example_redis_auth_storage.py TA_AUTH_STORAGE_MANAGER_CLASS=RedisSecureAuthStorageManager</p> <p>Required Redis configuration environment variables: - TA_REDIS_HOST (default: localhost) - TA_REDIS_PORT (default: 6379) - TA_REDIS_DB (default: 0) - TA_REDIS_TTL (default: 3600 seconds) - TA_REDIS_PWD (optional) - TA_REDIS_SSL (default: false)</p> <code></code> sk_agents.auth_storage.custom.example_redis_auth_storage.RedisSecureAuthStorageManager <p>               Bases: <code>SecureAuthStorageManager</code></p> Source code in <code>src/sk_agents/auth_storage/custom/example_redis_auth_storage.py</code> <pre><code>class RedisSecureAuthStorageManager(SecureAuthStorageManager):\n    def __init__(self, app_config: AppConfig = None):\n        \"\"\"\n        Initialize the Redis-based auth storage manager.\n\n        Args:\n            app_config: Application configuration object. If None, creates a new one.\n        \"\"\"\n        if app_config is None:\n            app_config = AppConfig()\n\n        self.app_config = app_config\n        self._lock = threading.Lock()\n\n        # Get Redis configuration\n        redis_host = self.app_config.get(TA_REDIS_HOST.env_name) or \"localhost\"\n        redis_port = int(self.app_config.get(TA_REDIS_PORT.env_name) or 6379)\n        redis_db = int(self.app_config.get(TA_REDIS_DB.env_name) or 0)\n        redis_password = self.app_config.get(TA_REDIS_PWD.env_name)\n        redis_ssl = self.app_config.get(TA_REDIS_SSL.env_name) == \"false\"\n        self.ttl = int(self.app_config.get(TA_REDIS_TTL.env_name) or 3600)  # Default 1 hour\n\n        # Initialize Redis client\n        self.redis_client = redis.Redis(\n            host=redis_host,\n            port=redis_port,\n            db=redis_db,\n            password=redis_password,\n            ssl=redis_ssl,\n            decode_responses=True,  # Automatically decode responses to strings\n            socket_connect_timeout=5,\n            socket_timeout=5,\n            retry_on_timeout=True,\n        )\n\n        # Test connection\n        try:\n            self.redis_client.ping()\n        except redis.ConnectionError as e:\n            raise ConnectionError(f\"Failed to connect to Redis: {e}\") from e\n\n    def _get_redis_key(self, user_id: str, key: str) -&gt; str:\n        \"\"\"Generate a Redis key for the given user_id and key.\"\"\"\n        return f\"auth_storage:{user_id}:{key}\"\n\n    def _serialize_auth_data(self, data: AuthData) -&gt; str:\n        \"\"\"Serialize AuthData to JSON string.\"\"\"\n        return data.model_dump_json()\n\n    def _deserialize_auth_data(self, data_str: str) -&gt; AuthData:\n        \"\"\"Deserialize JSON string to AuthData.\"\"\"\n        data_dict = json.loads(data_str)\n        # Import here to avoid circular imports\n        from sk_agents.auth_storage.models import AuthData\n\n        return AuthData.model_validate(data_dict)\n\n    def store(self, user_id: str, key: str, data: AuthData) -&gt; None:\n        \"\"\"Store authorization data for a given user and key with TTL.\"\"\"\n        with self._lock:\n            try:\n                redis_key = self._get_redis_key(user_id, key)\n                serialized_data = self._serialize_auth_data(data)\n\n                # Store with TTL\n                self.redis_client.setex(redis_key, self.ttl, serialized_data)\n\n            except redis.RedisError as e:\n                raise RuntimeError(f\"Failed to store auth data in Redis: {e}\") from e\n\n    def retrieve(self, user_id: str, key: str) -&gt; AuthData | None:\n        \"\"\"Retrieve authorization data for a given user and key.\"\"\"\n        with self._lock:\n            try:\n                redis_key = self._get_redis_key(user_id, key)\n                data_str = self.redis_client.get(redis_key)\n\n                if data_str is None:\n                    return None\n\n                return self._deserialize_auth_data(data_str)\n\n            except redis.RedisError as e:\n                raise RuntimeError(f\"Failed to retrieve auth data from Redis: {e}\") from e\n            except (json.JSONDecodeError, ValueError) as e:\n                # If we can't deserialize the data, it's corrupted, so delete it\n                try:\n                    redis_key = self._get_redis_key(user_id, key)\n                    self.redis_client.delete(redis_key)\n                except redis.RedisError:\n                    pass  # Ignore deletion errors\n                raise ValueError(\n                    f\"Corrupted auth data found for user {user_id}, key {key}: {e}\"\n                ) from e\n\n    def delete(self, user_id: str, key: str) -&gt; None:\n        \"\"\"Delete authorization data for a given user and key.\"\"\"\n        with self._lock:\n            try:\n                redis_key = self._get_redis_key(user_id, key)\n                self.redis_client.delete(redis_key)\n\n            except redis.RedisError as e:\n                raise RuntimeError(f\"Failed to delete auth data from Redis: {e}\") from e\n\n    def clear_user_data(self, user_id: str) -&gt; int:\n        \"\"\"\n        Clear all authorization data for a given user.\n\n        Returns:\n            Number of keys deleted.\n        \"\"\"\n        with self._lock:\n            try:\n                pattern = self._get_redis_key(user_id, \"*\")\n                keys = self.redis_client.keys(pattern)\n\n                if not keys:\n                    return 0\n\n                return self.redis_client.delete(*keys)\n\n            except redis.RedisError as e:\n                raise RuntimeError(f\"Failed to clear user data from Redis: {e}\") from e\n\n    def health_check(self) -&gt; bool:\n        \"\"\"Check if Redis connection is healthy.\"\"\"\n        try:\n            self.redis_client.ping()\n            return True\n        except redis.RedisError:\n            return False\n</code></pre> <code></code> sk_agents.auth_storage.custom.example_redis_auth_storage.RedisSecureAuthStorageManager.__init__ <pre><code>__init__(app_config: AppConfig = None)\n</code></pre> <p>Initialize the Redis-based auth storage manager.</p> <p>Parameters:</p> Name Type Description Default <code>app_config</code> <code>AppConfig</code> <p>Application configuration object. If None, creates a new one.</p> <code>None</code> Source code in <code>src/sk_agents/auth_storage/custom/example_redis_auth_storage.py</code> <pre><code>def __init__(self, app_config: AppConfig = None):\n    \"\"\"\n    Initialize the Redis-based auth storage manager.\n\n    Args:\n        app_config: Application configuration object. If None, creates a new one.\n    \"\"\"\n    if app_config is None:\n        app_config = AppConfig()\n\n    self.app_config = app_config\n    self._lock = threading.Lock()\n\n    # Get Redis configuration\n    redis_host = self.app_config.get(TA_REDIS_HOST.env_name) or \"localhost\"\n    redis_port = int(self.app_config.get(TA_REDIS_PORT.env_name) or 6379)\n    redis_db = int(self.app_config.get(TA_REDIS_DB.env_name) or 0)\n    redis_password = self.app_config.get(TA_REDIS_PWD.env_name)\n    redis_ssl = self.app_config.get(TA_REDIS_SSL.env_name) == \"false\"\n    self.ttl = int(self.app_config.get(TA_REDIS_TTL.env_name) or 3600)  # Default 1 hour\n\n    # Initialize Redis client\n    self.redis_client = redis.Redis(\n        host=redis_host,\n        port=redis_port,\n        db=redis_db,\n        password=redis_password,\n        ssl=redis_ssl,\n        decode_responses=True,  # Automatically decode responses to strings\n        socket_connect_timeout=5,\n        socket_timeout=5,\n        retry_on_timeout=True,\n    )\n\n    # Test connection\n    try:\n        self.redis_client.ping()\n    except redis.ConnectionError as e:\n        raise ConnectionError(f\"Failed to connect to Redis: {e}\") from e\n</code></pre> <code></code> sk_agents.auth_storage.custom.example_redis_auth_storage.RedisSecureAuthStorageManager.store <pre><code>store(user_id: str, key: str, data: AuthData) -&gt; None\n</code></pre> <p>Store authorization data for a given user and key with TTL.</p> Source code in <code>src/sk_agents/auth_storage/custom/example_redis_auth_storage.py</code> <pre><code>def store(self, user_id: str, key: str, data: AuthData) -&gt; None:\n    \"\"\"Store authorization data for a given user and key with TTL.\"\"\"\n    with self._lock:\n        try:\n            redis_key = self._get_redis_key(user_id, key)\n            serialized_data = self._serialize_auth_data(data)\n\n            # Store with TTL\n            self.redis_client.setex(redis_key, self.ttl, serialized_data)\n\n        except redis.RedisError as e:\n            raise RuntimeError(f\"Failed to store auth data in Redis: {e}\") from e\n</code></pre> <code></code> sk_agents.auth_storage.custom.example_redis_auth_storage.RedisSecureAuthStorageManager.retrieve <pre><code>retrieve(user_id: str, key: str) -&gt; AuthData | None\n</code></pre> <p>Retrieve authorization data for a given user and key.</p> Source code in <code>src/sk_agents/auth_storage/custom/example_redis_auth_storage.py</code> <pre><code>def retrieve(self, user_id: str, key: str) -&gt; AuthData | None:\n    \"\"\"Retrieve authorization data for a given user and key.\"\"\"\n    with self._lock:\n        try:\n            redis_key = self._get_redis_key(user_id, key)\n            data_str = self.redis_client.get(redis_key)\n\n            if data_str is None:\n                return None\n\n            return self._deserialize_auth_data(data_str)\n\n        except redis.RedisError as e:\n            raise RuntimeError(f\"Failed to retrieve auth data from Redis: {e}\") from e\n        except (json.JSONDecodeError, ValueError) as e:\n            # If we can't deserialize the data, it's corrupted, so delete it\n            try:\n                redis_key = self._get_redis_key(user_id, key)\n                self.redis_client.delete(redis_key)\n            except redis.RedisError:\n                pass  # Ignore deletion errors\n            raise ValueError(\n                f\"Corrupted auth data found for user {user_id}, key {key}: {e}\"\n            ) from e\n</code></pre> <code></code> sk_agents.auth_storage.custom.example_redis_auth_storage.RedisSecureAuthStorageManager.delete <pre><code>delete(user_id: str, key: str) -&gt; None\n</code></pre> <p>Delete authorization data for a given user and key.</p> Source code in <code>src/sk_agents/auth_storage/custom/example_redis_auth_storage.py</code> <pre><code>def delete(self, user_id: str, key: str) -&gt; None:\n    \"\"\"Delete authorization data for a given user and key.\"\"\"\n    with self._lock:\n        try:\n            redis_key = self._get_redis_key(user_id, key)\n            self.redis_client.delete(redis_key)\n\n        except redis.RedisError as e:\n            raise RuntimeError(f\"Failed to delete auth data from Redis: {e}\") from e\n</code></pre> <code></code> sk_agents.auth_storage.custom.example_redis_auth_storage.RedisSecureAuthStorageManager.clear_user_data <pre><code>clear_user_data(user_id: str) -&gt; int\n</code></pre> <p>Clear all authorization data for a given user.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of keys deleted.</p> Source code in <code>src/sk_agents/auth_storage/custom/example_redis_auth_storage.py</code> <pre><code>def clear_user_data(self, user_id: str) -&gt; int:\n    \"\"\"\n    Clear all authorization data for a given user.\n\n    Returns:\n        Number of keys deleted.\n    \"\"\"\n    with self._lock:\n        try:\n            pattern = self._get_redis_key(user_id, \"*\")\n            keys = self.redis_client.keys(pattern)\n\n            if not keys:\n                return 0\n\n            return self.redis_client.delete(*keys)\n\n        except redis.RedisError as e:\n            raise RuntimeError(f\"Failed to clear user data from Redis: {e}\") from e\n</code></pre> <code></code> sk_agents.auth_storage.custom.example_redis_auth_storage.RedisSecureAuthStorageManager.health_check <pre><code>health_check() -&gt; bool\n</code></pre> <p>Check if Redis connection is healthy.</p> Source code in <code>src/sk_agents/auth_storage/custom/example_redis_auth_storage.py</code> <pre><code>def health_check(self) -&gt; bool:\n    \"\"\"Check if Redis connection is healthy.\"\"\"\n    try:\n        self.redis_client.ping()\n        return True\n    except redis.RedisError:\n        return False\n</code></pre> <code></code> sk_agents.auth_storage.in_memory_secure_auth_storage_manager <code></code> sk_agents.auth_storage.in_memory_secure_auth_storage_manager.InMemorySecureAuthStorageManager <p>               Bases: <code>SecureAuthStorageManager</code></p> <p>A thread-safe, in-memory implementation of the SecureAuthStorageManager.</p> Source code in <code>src/sk_agents/auth_storage/in_memory_secure_auth_storage_manager.py</code> <pre><code>class InMemorySecureAuthStorageManager(SecureAuthStorageManager):\n    \"\"\"A thread-safe, in-memory implementation of the SecureAuthStorageManager.\"\"\"\n\n    def __init__(self):\n        self._storage: dict[str, dict[str, AuthData]] = {}\n        self._lock = threading.Lock()\n\n    def store(self, user_id: str, key: str, data: AuthData) -&gt; None:\n        with self._lock:\n            if user_id not in self._storage:\n                self._storage[user_id] = {}\n            self._storage[user_id][key] = data\n\n    def retrieve(self, user_id: str, key: str) -&gt; AuthData | None:\n        with self._lock:\n            return self._storage.get(user_id, {}).get(key)\n\n    def delete(self, user_id: str, key: str) -&gt; None:\n        with self._lock:\n            if user_id in self._storage and key in self._storage[user_id]:\n                del self._storage[user_id][key]\n</code></pre> <code></code> sk_agents.auth_storage.secure_auth_storage_manager <code></code> sk_agents.auth_storage.secure_auth_storage_manager.SecureAuthStorageManager <p>               Bases: <code>ABC</code></p> Source code in <code>src/sk_agents/auth_storage/secure_auth_storage_manager.py</code> <pre><code>class SecureAuthStorageManager(ABC):\n    @abstractmethod\n    def store(self, user_id: str, key: str, data: AuthData) -&gt; None:\n        \"\"\"Stores authorization data for a given user and key.\"\"\"\n        pass\n\n    @abstractmethod\n    def retrieve(self, user_id: str, key: str) -&gt; AuthData | None:\n        \"\"\"Retrieves authorization data for a given user and key.\"\"\"\n        pass\n\n    @abstractmethod\n    def delete(self, user_id: str, key: str) -&gt; None:\n        \"\"\"Deletes authorization data for a given user and key.\"\"\"\n        pass\n</code></pre> <code></code> sk_agents.auth_storage.secure_auth_storage_manager.SecureAuthStorageManager.store <code>abstractmethod</code> <pre><code>store(user_id: str, key: str, data: AuthData) -&gt; None\n</code></pre> <p>Stores authorization data for a given user and key.</p> Source code in <code>src/sk_agents/auth_storage/secure_auth_storage_manager.py</code> <pre><code>@abstractmethod\ndef store(self, user_id: str, key: str, data: AuthData) -&gt; None:\n    \"\"\"Stores authorization data for a given user and key.\"\"\"\n    pass\n</code></pre> <code></code> sk_agents.auth_storage.secure_auth_storage_manager.SecureAuthStorageManager.retrieve <code>abstractmethod</code> <pre><code>retrieve(user_id: str, key: str) -&gt; AuthData | None\n</code></pre> <p>Retrieves authorization data for a given user and key.</p> Source code in <code>src/sk_agents/auth_storage/secure_auth_storage_manager.py</code> <pre><code>@abstractmethod\ndef retrieve(self, user_id: str, key: str) -&gt; AuthData | None:\n    \"\"\"Retrieves authorization data for a given user and key.\"\"\"\n    pass\n</code></pre> <code></code> sk_agents.auth_storage.secure_auth_storage_manager.SecureAuthStorageManager.delete <code>abstractmethod</code> <pre><code>delete(user_id: str, key: str) -&gt; None\n</code></pre> <p>Deletes authorization data for a given user and key.</p> Source code in <code>src/sk_agents/auth_storage/secure_auth_storage_manager.py</code> <pre><code>@abstractmethod\ndef delete(self, user_id: str, key: str) -&gt; None:\n    \"\"\"Deletes authorization data for a given user and key.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#sk_agents.authorization","title":"sk_agents.authorization","text":"sk_agents.authorization.request_authorizer sk_agents.authorization.request_authorizer.RequestAuthorizer <p>               Bases: <code>ABC</code></p> Source code in <code>src/sk_agents/authorization/request_authorizer.py</code> <pre><code>class RequestAuthorizer(ABC):\n    @abstractmethod\n    async def authorize_request(self, auth_header: str) -&gt; str:\n        \"\"\"\n        Validates the given authorization header and returns a unique identifier\n        for the authenticated user.\n\n        Parameters:\n            auth_header (str): The value of the 'Authorization' HTTP header.\n                Typically, this is in the format 'Bearer &lt;token&gt;' or some other\n                scheme depending on the implementation.\n\n        Returns:\n            str: A unique string that identifies the authenticated user.\n                This could be a user ID, username, email, or any other unique\n                identifier suitable for tracking and authorization.\n            Examples:\n                \"user_12345\"\n                \"alice@example.com\"\n\n        Raises:\n            ValueError: If the authorization header is missing, malformed, or invalid.\n            AuthenticationError (optional): If used in your implementation, it may\n                be raised to signal an authentication failure.\n        \"\"\"\n        pass\n</code></pre> <code></code> sk_agents.authorization.request_authorizer.RequestAuthorizer.authorize_request <code>abstractmethod</code> <code>async</code> <pre><code>authorize_request(auth_header: str) -&gt; str\n</code></pre> <p>Validates the given authorization header and returns a unique identifier for the authenticated user.</p> <p>Parameters:</p> Name Type Description Default <code>auth_header</code> <code>str</code> <p>The value of the 'Authorization' HTTP header. Typically, this is in the format 'Bearer ' or some other scheme depending on the implementation. required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A unique string that identifies the authenticated user. This could be a user ID, username, email, or any other unique identifier suitable for tracking and authorization.</p> <code>Examples</code> <code>str</code> <p>\"user_12345\" \"alice@example.com\"</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the authorization header is missing, malformed, or invalid.</p> <code>AuthenticationError(optional)</code> <p>If used in your implementation, it may be raised to signal an authentication failure.</p> Source code in <code>src/sk_agents/authorization/request_authorizer.py</code> <pre><code>@abstractmethod\nasync def authorize_request(self, auth_header: str) -&gt; str:\n    \"\"\"\n    Validates the given authorization header and returns a unique identifier\n    for the authenticated user.\n\n    Parameters:\n        auth_header (str): The value of the 'Authorization' HTTP header.\n            Typically, this is in the format 'Bearer &lt;token&gt;' or some other\n            scheme depending on the implementation.\n\n    Returns:\n        str: A unique string that identifies the authenticated user.\n            This could be a user ID, username, email, or any other unique\n            identifier suitable for tracking and authorization.\n        Examples:\n            \"user_12345\"\n            \"alice@example.com\"\n\n    Raises:\n        ValueError: If the authorization header is missing, malformed, or invalid.\n        AuthenticationError (optional): If used in your implementation, it may\n            be raised to signal an authentication failure.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#sk_agents.exceptions","title":"sk_agents.exceptions","text":"sk_agents.exceptions.AgentsException <p>               Bases: <code>Exception</code></p> <p>Base class for all exception in SKagents</p> Source code in <code>src/sk_agents/exceptions.py</code> <pre><code>class AgentsException(Exception):\n    \"\"\"Base class for all exception in SKagents\"\"\"\n</code></pre> <code></code> sk_agents.exceptions.InvalidConfigException <p>               Bases: <code>AgentsException</code></p> <p>Exception raised when the provided configuration is invalid</p> Source code in <code>src/sk_agents/exceptions.py</code> <pre><code>class InvalidConfigException(AgentsException):\n    \"\"\"Exception raised when the provided configuration is invalid\"\"\"\n\n    message: str\n\n    def __init__(self, message: str):\n        self.message = message\n</code></pre> <code></code> sk_agents.exceptions.InvalidInputException <p>               Bases: <code>AgentsException</code></p> <p>Exception raised when the provided input type is invalid</p> Source code in <code>src/sk_agents/exceptions.py</code> <pre><code>class InvalidInputException(AgentsException):\n    \"\"\"Exception raised when the provided input type is invalid\"\"\"\n\n    message: str\n\n    def __init__(self, message: str):\n        self.message = message\n</code></pre> <code></code> sk_agents.exceptions.AgentInvokeException <p>               Bases: <code>AgentsException</code></p> <p>Exception raised when invoking an Agent failed</p> Source code in <code>src/sk_agents/exceptions.py</code> <pre><code>class AgentInvokeException(AgentsException):\n    \"\"\"Exception raised when invoking an Agent failed\"\"\"\n\n    message: str\n\n    def __init__(self, message: str):\n        self.message = message\n</code></pre> <code></code> sk_agents.exceptions.PersistenceCreateError <p>               Bases: <code>AgentsException</code></p> <p>Exception raised for errors during task creation.</p> Source code in <code>src/sk_agents/exceptions.py</code> <pre><code>class PersistenceCreateError(AgentsException):\n    \"\"\"Exception raised for errors during task creation.\"\"\"\n\n    message: str\n\n    def __init__(self, message: str):\n        self.message = message\n</code></pre> <code></code> sk_agents.exceptions.PersistenceLoadError <p>               Bases: <code>AgentsException</code></p> <p>Exception raised for errors during task loading.</p> Source code in <code>src/sk_agents/exceptions.py</code> <pre><code>class PersistenceLoadError(AgentsException):\n    \"\"\"Exception raised for errors during task loading.\"\"\"\n\n    message: str\n\n    def __init__(self, message: str):\n        self.message = message\n</code></pre> <code></code> sk_agents.exceptions.PersistenceUpdateError <p>               Bases: <code>AgentsException</code></p> <p>Exception raised for errors during task update.</p> Source code in <code>src/sk_agents/exceptions.py</code> <pre><code>class PersistenceUpdateError(AgentsException):\n    \"\"\"Exception raised for errors during task update.\"\"\"\n\n    message: str\n\n    def __init__(self, message: str):\n        self.message = message\n</code></pre> <code></code> sk_agents.exceptions.PersistenceDeleteError <p>               Bases: <code>AgentsException</code></p> <p>Exception raised for errors during task deletion.</p> Source code in <code>src/sk_agents/exceptions.py</code> <pre><code>class PersistenceDeleteError(AgentsException):\n    \"\"\"Exception raised for errors during task deletion.\"\"\"\n\n    message: str\n\n    def __init__(self, message: str):\n        self.message = message\n</code></pre> <code></code> sk_agents.exceptions.AuthenticationException <p>               Bases: <code>AgentsException</code></p> <p>Exception raised errors when authenticating users</p> Source code in <code>src/sk_agents/exceptions.py</code> <pre><code>class AuthenticationException(AgentsException):\n    \"\"\"Exception raised errors when authenticating users\"\"\"\n\n    message: str\n\n    def __init__(self, message: str):\n        self.message = message\n</code></pre> <code></code> sk_agents.exceptions.PluginCatalogDefinitionException <p>               Bases: <code>AgentsException</code></p> <p>Exception raised when the parsed json does not match the PluginCatalogDefinition Model</p> Source code in <code>src/sk_agents/exceptions.py</code> <pre><code>class PluginCatalogDefinitionException(AgentsException):\n    \"\"\"Exception raised when the parsed json does not match the PluginCatalogDefinition Model\"\"\"\n\n    message: str\n\n    def __init__(self, message: str):\n        self.message = message\n</code></pre> <code></code> sk_agents.exceptions.PluginFileReadException <p>               Bases: <code>AgentsException</code></p> <p>Raise this exception when the plugin file fails to be read</p> Source code in <code>src/sk_agents/exceptions.py</code> <pre><code>class PluginFileReadException(AgentsException):\n    \"\"\"Raise this exception when the plugin file fails to be read\"\"\"\n\n    message: str\n\n    def __init__(self, message: str):\n        self.message = message\n</code></pre>"},{"location":"reference/#sk_agents.hitl","title":"sk_agents.hitl","text":"sk_agents.hitl.hitl_manager sk_agents.hitl.hitl_manager.HitlInterventionRequired <p>               Bases: <code>Exception</code></p> <p>Exception raised when a tool call requires human-in-the-loop intervention.</p> Source code in <code>src/sk_agents/hitl/hitl_manager.py</code> <pre><code>class HitlInterventionRequired(Exception):\n    \"\"\"\n    Exception raised when a tool call\n    requires human-in-the-loop intervention.\n    \"\"\"\n\n    def __init__(self, function_calls: list[FunctionCallContent]):\n        self.function_calls = function_calls\n        if function_calls:\n            self.plugin_name = function_calls[0].plugin_name\n            self.function_name = function_calls[0].function_name\n            message = f\"HITL intervention required for {self.plugin_name}.{self.function_name}\"\n\n        else:\n            message = \"HITL intervention required but no function calls provided (internal error)\"\n        super().__init__(message)\n</code></pre> <code></code> sk_agents.hitl.hitl_manager.check_for_intervention <pre><code>check_for_intervention(\n    tool_call: FunctionCallContent,\n) -&gt; bool\n</code></pre> <p>Checks the plugin catalog to determine if a tool call requires Human-in-the-Loop intervention.</p> Source code in <code>src/sk_agents/hitl/hitl_manager.py</code> <pre><code>def check_for_intervention(tool_call: FunctionCallContent) -&gt; bool:\n    \"\"\"\n    Checks the plugin catalog to determine if a tool call requires\n    Human-in-the-Loop intervention.\n    \"\"\"\n    plugin_factory = PluginCatalogFactory()\n    catalog = plugin_factory.get_catalog()\n    if not catalog:\n        # Fallback if catalog is not configured\n        return False\n\n    tool_id = f\"{tool_call.plugin_name}-{tool_call.function_name}\"\n    tool = catalog.get_tool(tool_id)\n\n    if tool:\n        logger.debug(\n            f\"HITL Check: Intercepted call to {tool_id}. \"\n            f\"Requires HITL: {tool.governance.requires_hitl}\"\n        )\n        return tool.governance.requires_hitl\n    # Default to no intervention if tool is not in the catalog\n    return False\n</code></pre>"},{"location":"reference/#sk_agents.persistence","title":"sk_agents.persistence","text":"sk_agents.persistence.custom sk_agents.persistence.custom.example_redis_persistence <p>Complete Redis Task Persistence Implementation</p> <p>This example demonstrates a full-featured, production-ready Redis-based task persistence implementation. It serves as a complete alternative to the default in-memory storage.</p> <p>To use this implementation, set the following environment variables:</p> <p>TA_PERSISTENCE_MODULE=src/sk_agents/persistence/custom/example_redis_persistence.py TA_PERSISTENCE_CLASS=RedisTaskPersistenceManager</p> <p>Required Redis configuration environment variables: - TA_REDIS_HOST (default: localhost) - TA_REDIS_PORT (default: 6379) - TA_REDIS_DB (default: 0) - TA_REDIS_TTL (default: 3600 seconds) - TA_REDIS_PWD (optional) - TA_REDIS_SSL (default: false)</p> sk_agents.persistence.custom.example_redis_persistence.RedisTaskPersistenceManager <p>               Bases: <code>TaskPersistenceManager</code></p> Source code in <code>src/sk_agents/persistence/custom/example_redis_persistence.py</code> <pre><code>class RedisTaskPersistenceManager(TaskPersistenceManager):\n    def __init__(self, app_config: AppConfig = None):\n        \"\"\"\n        Initialize the Redis-based task persistence manager.\n\n        Args:\n            app_config: Application configuration object. If None, creates a new one.\n        \"\"\"\n        if app_config is None:\n            app_config = AppConfig()\n\n        self.app_config = app_config\n        self._lock = threading.Lock()\n\n        # Get Redis configuration\n        redis_host = self.app_config.get(TA_REDIS_HOST.env_name) or \"localhost\"\n        redis_port = int(self.app_config.get(TA_REDIS_PORT.env_name) or 6379)\n        redis_db = int(self.app_config.get(TA_REDIS_DB.env_name) or 0)\n        redis_password = self.app_config.get(TA_REDIS_PWD.env_name)\n        redis_ssl = self.app_config.get(TA_REDIS_SSL.env_name) == \"false\"\n        self.ttl = int(self.app_config.get(TA_REDIS_TTL.env_name) or 3600)  # Default 1 hour\n\n        # Initialize Redis client\n        self.redis_client = redis.Redis(\n            host=redis_host,\n            port=redis_port,\n            db=redis_db,\n            password=redis_password,\n            ssl=redis_ssl,\n            decode_responses=True,  # Automatically decode responses to strings\n            socket_connect_timeout=5,\n            socket_timeout=5,\n            retry_on_timeout=True,\n        )\n\n        # Test connection\n        try:\n            self.redis_client.ping()\n        except redis.ConnectionError as e:\n            raise ConnectionError(f\"Failed to connect to Redis: {e}\") from e\n\n    def _get_task_key(self, task_id: str) -&gt; str:\n        \"\"\"Generate a Redis key for the given task_id.\"\"\"\n        return f\"task_persistence:task:{task_id}\"\n\n    def _get_request_index_key(self, request_id: str) -&gt; str:\n        \"\"\"Generate a Redis key for request_id index.\"\"\"\n        return f\"task_persistence:request_index:{request_id}\"\n\n    def _serialize_task(self, task: AgentTask) -&gt; str:\n        \"\"\"Serialize AgentTask to JSON string.\"\"\"\n        return task.model_dump_json()\n\n    def _deserialize_task(self, task_str: str) -&gt; AgentTask:\n        \"\"\"Deserialize JSON string to AgentTask.\"\"\"\n        task_dict = json.loads(task_str)\n        return AgentTask.model_validate(task_dict)\n\n    async def create(self, task: AgentTask) -&gt; None:\n        \"\"\"Create a new task in Redis.\"\"\"\n        try:\n            task_key = self._get_task_key(task.task_id)\n\n            # Check if task already exists\n            if self.redis_client.exists(task_key):\n                raise PersistenceCreateError(\n                    message=f\"Task with ID '{task.task_id}' already exists.\"\n                )\n\n            # Serialize and store the task\n            serialized_task = self._serialize_task(task)\n            self.redis_client.setex(task_key, self.ttl, serialized_task)\n\n            # Update request_id indexes\n            for item in task.items:\n                request_index_key = self._get_request_index_key(item.request_id)\n                self.redis_client.sadd(request_index_key, task.task_id)\n                self.redis_client.expire(request_index_key, self.ttl)\n\n        except redis.RedisError as e:\n            raise PersistenceCreateError(\n                message=f\"Failed to create task '{task.task_id}' in Redis: {e}\"\n            ) from e\n        except Exception as e:\n            raise PersistenceCreateError(\n                message=f\"Unexpected error creating task '{task.task_id}': {e}\"\n            ) from e\n\n    async def load(self, task_id: str) -&gt; AgentTask | None:\n        \"\"\"Load a task from Redis by task_id.\"\"\"\n        with self._lock:\n            try:\n                task_key = self._get_task_key(task_id)\n                task_str = self.redis_client.get(task_key)\n\n                if task_str is None:\n                    return None\n\n                return self._deserialize_task(task_str)\n\n            except redis.RedisError as e:\n                raise PersistenceLoadError(\n                    message=f\"Failed to load task '{task_id}' from Redis: {e}\"\n                ) from e\n            except (json.JSONDecodeError, ValueError) as e:\n                # If we can't deserialize the task, it's corrupted, so delete it\n                try:\n                    task_key = self._get_task_key(task_id)\n                    self.redis_client.delete(task_key)\n                except redis.RedisError:\n                    pass  # Ignore deletion errors\n                raise PersistenceLoadError(\n                    message=f\"Corrupted task data found for task_id {task_id}: {e}\"\n                ) from e\n\n    async def update(self, task: AgentTask) -&gt; None:\n        \"\"\"Update an existing task in Redis.\"\"\"\n        try:\n            task_key = self._get_task_key(task.task_id)\n\n            # Check if task exists\n            old_task_str = self.redis_client.get(task_key)\n            if old_task_str is None:\n                raise PersistenceUpdateError(\n                    f\"Task with ID '{task.task_id}' does not exist for update.\"\n                )\n\n            # Deserialize old task to clean up old request_id indexes\n            old_task = self._deserialize_task(old_task_str)\n\n            # Remove old request_id associations\n            for item in old_task.items:\n                request_index_key = self._get_request_index_key(item.request_id)\n                self.redis_client.srem(request_index_key, task.task_id)\n\n            # Update the task\n            serialized_task = self._serialize_task(task)\n            self.redis_client.setex(task_key, self.ttl, serialized_task)\n\n            # Add new request_id associations\n            for item in task.items:\n                request_index_key = self._get_request_index_key(item.request_id)\n                self.redis_client.sadd(request_index_key, task.task_id)\n                self.redis_client.expire(request_index_key, self.ttl)\n\n        except redis.RedisError as e:\n            raise PersistenceUpdateError(\n                message=f\"Failed to update task '{task.task_id}' in Redis: {e}\"\n            ) from e\n        except Exception as e:\n            raise PersistenceUpdateError(\n                message=f\"Unexpected error updating task '{task.task_id}': {e}\"\n            ) from e\n\n    async def delete(self, task_id: str) -&gt; None:\n        \"\"\"Delete a task from Redis.\"\"\"\n        try:\n            task_key = self._get_task_key(task_id)\n\n            # Get the task first to clean up request_id indexes\n            task_str = self.redis_client.get(task_key)\n            if task_str is None:\n                raise PersistenceDeleteError(\n                    message=f\"Task with ID '{task_id}' does not exist for deletion.\"\n                )\n\n            task = self._deserialize_task(task_str)\n\n            # Remove from request_id indexes\n            for item in task.items:\n                request_index_key = self._get_request_index_key(item.request_id)\n                self.redis_client.srem(request_index_key, task_id)\n\n            # Delete the task\n            self.redis_client.delete(task_key)\n\n        except redis.RedisError as e:\n            raise PersistenceDeleteError(\n                message=f\"Failed to delete task '{task_id}' from Redis: {e}\"\n            ) from e\n        except Exception as e:\n            raise PersistenceDeleteError(\n                message=f\"Unexpected error deleting task '{task_id}': {e}\"\n            ) from e\n\n    async def load_by_request_id(self, request_id: str) -&gt; AgentTask | None:\n        \"\"\"Load a task by request_id.\"\"\"\n        try:\n            request_index_key = self._get_request_index_key(request_id)\n            task_ids = self.redis_client.smembers(request_index_key)\n\n            if not task_ids:\n                return None\n\n            # If multiple tasks have the same request_id, return the first one\n            task_id = next(iter(task_ids))\n            return await self.load(task_id)\n\n        except redis.RedisError as e:\n            raise PersistenceLoadError(\n                message=f\"Failed to load task by request_id '{request_id}' from Redis: {e}\"\n            ) from e\n        except Exception as e:\n            raise PersistenceLoadError(\n                message=f\"Unexpected error loading task by request_id '{request_id}': {e}\"\n            ) from e\n\n    def health_check(self) -&gt; bool:\n        \"\"\"Check if Redis connection is healthy.\"\"\"\n        try:\n            self.redis_client.ping()\n            return True\n        except redis.RedisError:\n            return False\n\n    def clear_all_tasks(self) -&gt; int:\n        \"\"\"\n        Clear all task data (useful for testing).\n\n        Returns:\n            Number of keys deleted.\n        \"\"\"\n        try:\n            # Get all task keys\n            task_keys = self.redis_client.keys(\"task_persistence:task:*\")\n            request_index_keys = self.redis_client.keys(\"task_persistence:request_index:*\")\n\n            all_keys = task_keys + request_index_keys\n\n            if not all_keys:\n                return 0\n\n            return self.redis_client.delete(*all_keys)\n\n        except redis.RedisError as e:\n            raise RuntimeError(f\"Failed to clear all tasks from Redis: {e}\") from e\n</code></pre> <code></code> sk_agents.persistence.custom.example_redis_persistence.RedisTaskPersistenceManager.__init__ <pre><code>__init__(app_config: AppConfig = None)\n</code></pre> <p>Initialize the Redis-based task persistence manager.</p> <p>Parameters:</p> Name Type Description Default <code>app_config</code> <code>AppConfig</code> <p>Application configuration object. If None, creates a new one.</p> <code>None</code> Source code in <code>src/sk_agents/persistence/custom/example_redis_persistence.py</code> <pre><code>def __init__(self, app_config: AppConfig = None):\n    \"\"\"\n    Initialize the Redis-based task persistence manager.\n\n    Args:\n        app_config: Application configuration object. If None, creates a new one.\n    \"\"\"\n    if app_config is None:\n        app_config = AppConfig()\n\n    self.app_config = app_config\n    self._lock = threading.Lock()\n\n    # Get Redis configuration\n    redis_host = self.app_config.get(TA_REDIS_HOST.env_name) or \"localhost\"\n    redis_port = int(self.app_config.get(TA_REDIS_PORT.env_name) or 6379)\n    redis_db = int(self.app_config.get(TA_REDIS_DB.env_name) or 0)\n    redis_password = self.app_config.get(TA_REDIS_PWD.env_name)\n    redis_ssl = self.app_config.get(TA_REDIS_SSL.env_name) == \"false\"\n    self.ttl = int(self.app_config.get(TA_REDIS_TTL.env_name) or 3600)  # Default 1 hour\n\n    # Initialize Redis client\n    self.redis_client = redis.Redis(\n        host=redis_host,\n        port=redis_port,\n        db=redis_db,\n        password=redis_password,\n        ssl=redis_ssl,\n        decode_responses=True,  # Automatically decode responses to strings\n        socket_connect_timeout=5,\n        socket_timeout=5,\n        retry_on_timeout=True,\n    )\n\n    # Test connection\n    try:\n        self.redis_client.ping()\n    except redis.ConnectionError as e:\n        raise ConnectionError(f\"Failed to connect to Redis: {e}\") from e\n</code></pre> <code></code> sk_agents.persistence.custom.example_redis_persistence.RedisTaskPersistenceManager.create <code>async</code> <pre><code>create(task: AgentTask) -&gt; None\n</code></pre> <p>Create a new task in Redis.</p> Source code in <code>src/sk_agents/persistence/custom/example_redis_persistence.py</code> <pre><code>async def create(self, task: AgentTask) -&gt; None:\n    \"\"\"Create a new task in Redis.\"\"\"\n    try:\n        task_key = self._get_task_key(task.task_id)\n\n        # Check if task already exists\n        if self.redis_client.exists(task_key):\n            raise PersistenceCreateError(\n                message=f\"Task with ID '{task.task_id}' already exists.\"\n            )\n\n        # Serialize and store the task\n        serialized_task = self._serialize_task(task)\n        self.redis_client.setex(task_key, self.ttl, serialized_task)\n\n        # Update request_id indexes\n        for item in task.items:\n            request_index_key = self._get_request_index_key(item.request_id)\n            self.redis_client.sadd(request_index_key, task.task_id)\n            self.redis_client.expire(request_index_key, self.ttl)\n\n    except redis.RedisError as e:\n        raise PersistenceCreateError(\n            message=f\"Failed to create task '{task.task_id}' in Redis: {e}\"\n        ) from e\n    except Exception as e:\n        raise PersistenceCreateError(\n            message=f\"Unexpected error creating task '{task.task_id}': {e}\"\n        ) from e\n</code></pre> <code></code> sk_agents.persistence.custom.example_redis_persistence.RedisTaskPersistenceManager.load <code>async</code> <pre><code>load(task_id: str) -&gt; AgentTask | None\n</code></pre> <p>Load a task from Redis by task_id.</p> Source code in <code>src/sk_agents/persistence/custom/example_redis_persistence.py</code> <pre><code>async def load(self, task_id: str) -&gt; AgentTask | None:\n    \"\"\"Load a task from Redis by task_id.\"\"\"\n    with self._lock:\n        try:\n            task_key = self._get_task_key(task_id)\n            task_str = self.redis_client.get(task_key)\n\n            if task_str is None:\n                return None\n\n            return self._deserialize_task(task_str)\n\n        except redis.RedisError as e:\n            raise PersistenceLoadError(\n                message=f\"Failed to load task '{task_id}' from Redis: {e}\"\n            ) from e\n        except (json.JSONDecodeError, ValueError) as e:\n            # If we can't deserialize the task, it's corrupted, so delete it\n            try:\n                task_key = self._get_task_key(task_id)\n                self.redis_client.delete(task_key)\n            except redis.RedisError:\n                pass  # Ignore deletion errors\n            raise PersistenceLoadError(\n                message=f\"Corrupted task data found for task_id {task_id}: {e}\"\n            ) from e\n</code></pre> <code></code> sk_agents.persistence.custom.example_redis_persistence.RedisTaskPersistenceManager.update <code>async</code> <pre><code>update(task: AgentTask) -&gt; None\n</code></pre> <p>Update an existing task in Redis.</p> Source code in <code>src/sk_agents/persistence/custom/example_redis_persistence.py</code> <pre><code>async def update(self, task: AgentTask) -&gt; None:\n    \"\"\"Update an existing task in Redis.\"\"\"\n    try:\n        task_key = self._get_task_key(task.task_id)\n\n        # Check if task exists\n        old_task_str = self.redis_client.get(task_key)\n        if old_task_str is None:\n            raise PersistenceUpdateError(\n                f\"Task with ID '{task.task_id}' does not exist for update.\"\n            )\n\n        # Deserialize old task to clean up old request_id indexes\n        old_task = self._deserialize_task(old_task_str)\n\n        # Remove old request_id associations\n        for item in old_task.items:\n            request_index_key = self._get_request_index_key(item.request_id)\n            self.redis_client.srem(request_index_key, task.task_id)\n\n        # Update the task\n        serialized_task = self._serialize_task(task)\n        self.redis_client.setex(task_key, self.ttl, serialized_task)\n\n        # Add new request_id associations\n        for item in task.items:\n            request_index_key = self._get_request_index_key(item.request_id)\n            self.redis_client.sadd(request_index_key, task.task_id)\n            self.redis_client.expire(request_index_key, self.ttl)\n\n    except redis.RedisError as e:\n        raise PersistenceUpdateError(\n            message=f\"Failed to update task '{task.task_id}' in Redis: {e}\"\n        ) from e\n    except Exception as e:\n        raise PersistenceUpdateError(\n            message=f\"Unexpected error updating task '{task.task_id}': {e}\"\n        ) from e\n</code></pre> <code></code> sk_agents.persistence.custom.example_redis_persistence.RedisTaskPersistenceManager.delete <code>async</code> <pre><code>delete(task_id: str) -&gt; None\n</code></pre> <p>Delete a task from Redis.</p> Source code in <code>src/sk_agents/persistence/custom/example_redis_persistence.py</code> <pre><code>async def delete(self, task_id: str) -&gt; None:\n    \"\"\"Delete a task from Redis.\"\"\"\n    try:\n        task_key = self._get_task_key(task_id)\n\n        # Get the task first to clean up request_id indexes\n        task_str = self.redis_client.get(task_key)\n        if task_str is None:\n            raise PersistenceDeleteError(\n                message=f\"Task with ID '{task_id}' does not exist for deletion.\"\n            )\n\n        task = self._deserialize_task(task_str)\n\n        # Remove from request_id indexes\n        for item in task.items:\n            request_index_key = self._get_request_index_key(item.request_id)\n            self.redis_client.srem(request_index_key, task_id)\n\n        # Delete the task\n        self.redis_client.delete(task_key)\n\n    except redis.RedisError as e:\n        raise PersistenceDeleteError(\n            message=f\"Failed to delete task '{task_id}' from Redis: {e}\"\n        ) from e\n    except Exception as e:\n        raise PersistenceDeleteError(\n            message=f\"Unexpected error deleting task '{task_id}': {e}\"\n        ) from e\n</code></pre> <code></code> sk_agents.persistence.custom.example_redis_persistence.RedisTaskPersistenceManager.load_by_request_id <code>async</code> <pre><code>load_by_request_id(request_id: str) -&gt; AgentTask | None\n</code></pre> <p>Load a task by request_id.</p> Source code in <code>src/sk_agents/persistence/custom/example_redis_persistence.py</code> <pre><code>async def load_by_request_id(self, request_id: str) -&gt; AgentTask | None:\n    \"\"\"Load a task by request_id.\"\"\"\n    try:\n        request_index_key = self._get_request_index_key(request_id)\n        task_ids = self.redis_client.smembers(request_index_key)\n\n        if not task_ids:\n            return None\n\n        # If multiple tasks have the same request_id, return the first one\n        task_id = next(iter(task_ids))\n        return await self.load(task_id)\n\n    except redis.RedisError as e:\n        raise PersistenceLoadError(\n            message=f\"Failed to load task by request_id '{request_id}' from Redis: {e}\"\n        ) from e\n    except Exception as e:\n        raise PersistenceLoadError(\n            message=f\"Unexpected error loading task by request_id '{request_id}': {e}\"\n        ) from e\n</code></pre> <code></code> sk_agents.persistence.custom.example_redis_persistence.RedisTaskPersistenceManager.health_check <pre><code>health_check() -&gt; bool\n</code></pre> <p>Check if Redis connection is healthy.</p> Source code in <code>src/sk_agents/persistence/custom/example_redis_persistence.py</code> <pre><code>def health_check(self) -&gt; bool:\n    \"\"\"Check if Redis connection is healthy.\"\"\"\n    try:\n        self.redis_client.ping()\n        return True\n    except redis.RedisError:\n        return False\n</code></pre> <code></code> sk_agents.persistence.custom.example_redis_persistence.RedisTaskPersistenceManager.clear_all_tasks <pre><code>clear_all_tasks() -&gt; int\n</code></pre> <p>Clear all task data (useful for testing).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of keys deleted.</p> Source code in <code>src/sk_agents/persistence/custom/example_redis_persistence.py</code> <pre><code>def clear_all_tasks(self) -&gt; int:\n    \"\"\"\n    Clear all task data (useful for testing).\n\n    Returns:\n        Number of keys deleted.\n    \"\"\"\n    try:\n        # Get all task keys\n        task_keys = self.redis_client.keys(\"task_persistence:task:*\")\n        request_index_keys = self.redis_client.keys(\"task_persistence:request_index:*\")\n\n        all_keys = task_keys + request_index_keys\n\n        if not all_keys:\n            return 0\n\n        return self.redis_client.delete(*all_keys)\n\n    except redis.RedisError as e:\n        raise RuntimeError(f\"Failed to clear all tasks from Redis: {e}\") from e\n</code></pre> <code></code> sk_agents.persistence.persistence_factory <code></code> sk_agents.persistence.persistence_factory.PersistenceFactory Source code in <code>src/sk_agents/persistence/persistence_factory.py</code> <pre><code>class PersistenceFactory(metaclass=Singleton):\n    def __init__(self, app_config: AppConfig):\n        self.app_config = app_config\n\n        # Try to load custom module, fallback to default if not configured\n        module_name, class_name = self._get_custom_persistence_config()\n        if module_name and class_name:\n            try:\n                self.module = ModuleLoader.load_module(module_name)\n            except Exception as e:\n                raise ImportError(f\"Failed to load module '{module_name}': {e}\") from e\n\n            self.class_name = class_name\n            self._validate_custom_class()\n        else:\n            self.module = None\n            self.class_name = None\n\n    def get_persistence_manager(self) -&gt; TaskPersistenceManager:\n        if self.module and self.class_name:\n            # Use custom implementation\n            custom_class = getattr(self.module, self.class_name)\n            try:\n                return custom_class(app_config=self.app_config)\n            except TypeError:\n                # Fallback if app_config not accepted\n                return custom_class()\n        else:\n            # Use default implementation\n            return InMemoryPersistenceManager()\n\n    def _get_custom_persistence_config(self) -&gt; tuple[str | None, str | None]:\n        \"\"\"Get custom persistence configuration, returning None values if using defaults.\"\"\"\n        module_name = self.app_config.get(TA_PERSISTENCE_MODULE.env_name)\n        class_name = self.app_config.get(TA_PERSISTENCE_CLASS.env_name)\n\n        # Check if we're using the default values (which means no custom config)\n        if (\n            module_name == TA_PERSISTENCE_MODULE.default_value\n            and class_name == TA_PERSISTENCE_CLASS.default_value\n        ):\n            return None, None\n\n        return module_name, class_name\n\n    def _validate_custom_class(self):\n        \"\"\"Validate that the custom class is a proper TaskPersistenceManager subclass.\"\"\"\n        if not hasattr(self.module, self.class_name):\n            module_name = getattr(self.module, \"__name__\", \"unknown module\")\n            raise ValueError(\n                f\"Custom Task Persistence Manager class: {self.class_name} \"\n                f\"Not found in module: {module_name}\"\n            )\n\n        custom_class = getattr(self.module, self.class_name)\n        if not issubclass(custom_class, TaskPersistenceManager):\n            raise TypeError(\n                f\"Class '{self.class_name}' is not a subclass of TaskPersistenceManager.\"\n            )\n</code></pre>"},{"location":"reference/#sk_agents.plugin_catalog","title":"sk_agents.plugin_catalog","text":"sk_agents.plugin_catalog.local_plugin_catalog sk_agents.plugin_catalog.local_plugin_catalog.FileBasedPluginCatalog <p>               Bases: <code>PluginCatalog</code></p> <p>File-based implementation that loads plugins from JSON files.</p> Source code in <code>src/sk_agents/plugin_catalog/local_plugin_catalog.py</code> <pre><code>class FileBasedPluginCatalog(PluginCatalog):\n    \"\"\"File-based implementation that loads plugins from JSON files.\"\"\"\n\n    def __init__(self, app_config: AppConfig):\n        self.app_config = app_config\n        self.catalog_path = Path(self.app_config.get(TA_PLUGIN_CATALOG_FILE.env_name))\n        self._plugins: dict[str, Plugin] = {}\n        self._tools: dict[str, PluginTool] = {}\n        self._load_plugins()\n\n    def get_plugin(self, plugin_id: str) -&gt; Plugin | None:\n        \"\"\"Get a plugin by its ID.\"\"\"\n        return self._plugins.get(plugin_id)\n\n    def get_tool(self, tool_id: str) -&gt; PluginTool | None:\n        \"\"\"Get a tool by its ID.\"\"\"\n        return self._tools.get(tool_id)\n\n    def _load_plugins(self) -&gt; None:\n        \"\"\"Load plugins from a single JSON file.\"\"\"\n        if not self.catalog_path.exists():\n            return\n\n        try:\n            with open(self.catalog_path) as local_plugin_json:\n                catalog_data = json.load(local_plugin_json)\n\n            # Validate and convert to PluginCatalogDefinition\n            try:\n                catalog_definition = PluginCatalogDefinition.model_validate(catalog_data)\n            except Exception as validation_error:\n                raise PluginCatalogDefinitionException(\n                    message=\"Plugin catalog definition validation failed\"\n                ) from validation_error\n            # Process the validated plugins\n            for plugin_data in catalog_definition.plugins:\n                plugin = plugin_data\n                self._plugins[plugin.plugin_id] = plugin\n\n                # Index tools for quick lookup\n                for tool in plugin.tools:\n                    self._tools[tool.tool_id] = tool\n\n        except PluginCatalogDefinitionException:\n            # Re-raise our custom exception\n            raise\n        except Exception as e:\n            raise PluginFileReadException(\n                message=\"\"\"\n                Catalog encountered an error\n                when attempting to read file\n                \"\"\"\n            ) from e\n</code></pre> <code></code> sk_agents.plugin_catalog.local_plugin_catalog.FileBasedPluginCatalog.get_plugin <pre><code>get_plugin(plugin_id: str) -&gt; Plugin | None\n</code></pre> <p>Get a plugin by its ID.</p> Source code in <code>src/sk_agents/plugin_catalog/local_plugin_catalog.py</code> <pre><code>def get_plugin(self, plugin_id: str) -&gt; Plugin | None:\n    \"\"\"Get a plugin by its ID.\"\"\"\n    return self._plugins.get(plugin_id)\n</code></pre> <code></code> sk_agents.plugin_catalog.local_plugin_catalog.FileBasedPluginCatalog.get_tool <pre><code>get_tool(tool_id: str) -&gt; PluginTool | None\n</code></pre> <p>Get a tool by its ID.</p> Source code in <code>src/sk_agents/plugin_catalog/local_plugin_catalog.py</code> <pre><code>def get_tool(self, tool_id: str) -&gt; PluginTool | None:\n    \"\"\"Get a tool by its ID.\"\"\"\n    return self._tools.get(tool_id)\n</code></pre> <code></code> sk_agents.plugin_catalog.plugin_catalog_factory <code></code> sk_agents.plugin_catalog.plugin_catalog_factory.PluginCatalogFactory <p>Singleton factory for creating PluginCatalog instances based on environment variables.</p> Source code in <code>src/sk_agents/plugin_catalog/plugin_catalog_factory.py</code> <pre><code>class PluginCatalogFactory(metaclass=Singleton):\n    \"\"\"\n    Singleton factory for creating PluginCatalog\n    instances based on environment variables.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        AppConfig.add_configs(configs)\n        app_config = AppConfig()\n        self.app_config = app_config\n        self._catalog_instance: PluginCatalog | None = None\n\n    def get_catalog(self) -&gt; PluginCatalog:\n        \"\"\"\n        Get the plugin catalog instance,\n        creating it if it doesn't exist.\n        \"\"\"\n        if self._catalog_instance is None:\n            self._catalog_instance = self._create_catalog()\n        return self._catalog_instance\n\n    def _create_catalog(self) -&gt; PluginCatalog:\n        \"\"\"\n        Create a new plugin catalog instance\n        based on environment variables.\n        \"\"\"\n        module_name = self.app_config.get(TA_PLUGIN_CATALOG_MODULE.env_name)\n        class_name = self.app_config.get(TA_PLUGIN_CATALOG_CLASS.env_name)\n\n        if not module_name or not class_name:\n            raise ValueError(\n                \"Both TA_PLUGIN_CATALOG_MODULE and TA_PLUGIN_CATALOG_CLASS \"\n                \"environment variables must be set\"\n            )\n\n        try:\n            # Dynamically import the module\n            module = ModuleLoader.load_module(module_name)\n\n            # Get the class from the module\n            catalog_class: type[PluginCatalog] = getattr(module, class_name)\n\n            # Verify it's a subclass of PluginCatalog\n            if not issubclass(catalog_class, PluginCatalog):\n                raise TypeError(\n                    f\"Class {class_name} in module {module_name} must inherit from PluginCatalog\"\n                )\n\n            # Instantiate and return the catalog\n            return catalog_class(self.app_config)\n\n        except ImportError as e:\n            raise ImportError(f\"Failed to import module '{module_name}': {e}\") from e\n        except AttributeError as e:\n            raise AttributeError(\n                f\"Class '{class_name}' not found in module '{module_name}': {e}\"\n            ) from e\n</code></pre> <code></code> sk_agents.plugin_catalog.plugin_catalog_factory.PluginCatalogFactory.get_catalog <pre><code>get_catalog() -&gt; PluginCatalog\n</code></pre> <p>Get the plugin catalog instance, creating it if it doesn't exist.</p> Source code in <code>src/sk_agents/plugin_catalog/plugin_catalog_factory.py</code> <pre><code>def get_catalog(self) -&gt; PluginCatalog:\n    \"\"\"\n    Get the plugin catalog instance,\n    creating it if it doesn't exist.\n    \"\"\"\n    if self._catalog_instance is None:\n        self._catalog_instance = self._create_catalog()\n    return self._catalog_instance\n</code></pre>"},{"location":"reference/#sk_agents.routes","title":"sk_agents.routes","text":"sk_agents.routes.Routes Source code in <code>src/sk_agents/routes.py</code> <pre><code>class Routes:\n    @staticmethod\n    def get_url(name: str, version: str, app_config: AppConfig) -&gt; str:\n        base_url = app_config.get(TA_AGENT_BASE_URL.env_name)\n        if not base_url:\n            logger.exception(\"Base URL is not provided in the app config.\")\n            raise ValueError(\"Base URL is not provided in the app config.\")\n        return f\"{base_url}/{name}/{version}/a2a\"\n\n    @staticmethod\n    def get_provider(app_config: AppConfig) -&gt; AgentProvider:\n        return AgentProvider(\n            organization=app_config.get(TA_PROVIDER_ORG.env_name),\n            url=app_config.get(TA_PROVIDER_URL.env_name),\n        )\n\n    @staticmethod\n    def get_agent_card(config: BaseConfig, app_config: AppConfig) -&gt; AgentCard:\n        if config.metadata is None:\n            logger.exception(\"Agent card metadata is not provided in the config.\")\n            raise ValueError(\"Agent card metadata is not provided in the config.\")\n\n        metadata = config.metadata\n        skills = [\n            AgentSkill(\n                id=skill.id,\n                name=skill.name,\n                description=skill.description,\n                tags=skill.tags,\n                examples=skill.examples,\n                inputModes=skill.input_modes,\n                outputModes=skill.output_modes,\n            )\n            for skill in metadata.skills\n        ]\n        return AgentCard(\n            name=config.name,\n            version=str(config.version),\n            description=metadata.description,\n            url=Routes.get_url(config.name, config.version, app_config),\n            provider=Routes.get_provider(app_config),\n            documentationUrl=config.metadata.documentation_url,\n            capabilities=AgentCapabilities(\n                streaming=True, pushNotifications=False, stateTransitionHistory=True\n            ),\n            defaultInputModes=[\"text\"],\n            defaultOutputModes=[\"text\"],\n            skills=skills,\n        )\n\n    @staticmethod\n    def _create_chat_completions_builder(app_config: AppConfig):\n        return ChatCompletionBuilder(app_config)\n\n    @staticmethod\n    def _create_remote_plugin_loader(app_config: AppConfig):\n        remote_plugin_catalog = RemotePluginCatalog(app_config)\n        return RemotePluginLoader(remote_plugin_catalog)\n\n    @staticmethod\n    def _create_kernel_builder(app_config: AppConfig, authorization: str):\n        chat_completions = Routes._create_chat_completions_builder(app_config)\n        remote_plugin_loader = Routes._create_remote_plugin_loader(app_config)\n        kernel_builder = KernelBuilder(\n            chat_completions, remote_plugin_loader, app_config, authorization\n        )\n        return kernel_builder\n\n    @staticmethod\n    def _create_agent_builder(app_config: AppConfig, authorization: str):\n        kernel_builder = Routes._create_kernel_builder(app_config, authorization)\n        agent_builder = AgentBuilder(kernel_builder, authorization)\n        return agent_builder\n\n    @staticmethod\n    def get_request_handler(\n        config: BaseConfig,\n        app_config: AppConfig,\n        chat_completion_builder: ChatCompletionBuilder,\n        state_manager: StateManager,\n        task_store: TaskStore,\n    ) -&gt; DefaultRequestHandler:\n        return DefaultRequestHandler(\n            agent_executor=A2AAgentExecutor(\n                config, app_config, chat_completion_builder, state_manager\n            ),\n            task_store=task_store,\n        )\n\n    @staticmethod\n    def get_task_handler(\n        config: BaseConfig,\n        app_config: AppConfig,\n        authorization: str,\n        state_manager: TaskPersistenceManager,\n    ) -&gt; TealAgentsV1Alpha1Handler:\n        agent_builder = Routes._create_agent_builder(app_config, authorization)\n        return TealAgentsV1Alpha1Handler(config, app_config, agent_builder, state_manager)\n\n    @staticmethod\n    def get_a2a_routes(\n        name: str,\n        version: str,\n        description: str,\n        config: BaseConfig,\n        app_config: AppConfig,\n        chat_completion_builder: ChatCompletionBuilder,\n        task_store: TaskStore,\n        state_manager: StateManager,\n    ) -&gt; APIRouter:\n        \"\"\"\n        DEPRECATION NOTICE: A2A (Agent-to-Agent) routes are being deprecated\n        as part of the framework migration evaluation. This method is maintained for\n        backward compatibility only. New development should avoid using A2A functionality.\n        \"\"\"\n        a2a_app = A2AStarletteApplication(\n            agent_card=Routes.get_agent_card(config, app_config),\n            http_handler=Routes.get_request_handler(\n                config, app_config, chat_completion_builder, state_manager, task_store\n            ),\n        )\n        a2a_router = APIRouter()\n\n        @a2a_router.post(\"\")\n        @docstring_parameter(description)\n        async def handle_a2a(request: Request):\n            \"\"\"\n            {0}\n\n            Agent-to-Agent Invocation\n            \"\"\"\n            return await a2a_app._handle_requests(request)\n\n        @a2a_router.get(\"/.well-known/agent.json\")\n        @docstring_parameter(f\"{name}:{version} - {description}\")\n        async def handle_get_agent_card(request: Request):\n            \"\"\"\n            Retrieve agent card for {0}\n            \"\"\"\n            return await a2a_app._handle_get_agent_card(request)\n\n        return a2a_router\n\n    @staticmethod\n    def get_rest_routes(\n        name: str,\n        version: str,\n        description: str,\n        root_handler_name: str,\n        config: BaseConfig,\n        app_config: AppConfig,\n        input_class: type,\n        output_class: type,\n    ) -&gt; APIRouter:\n        router = APIRouter()\n\n        @router.post(\"\")\n        @docstring_parameter(description)\n        async def invoke(inputs: input_class, request: Request) -&gt; InvokeResponse[output_class]:  # type: ignore\n            \"\"\"\n            {0}\n            \"\"\"\n            st = get_telemetry()\n            context = extract(request.headers)\n\n            authorization = request.headers.get(\"authorization\", None)\n            with (\n                st.tracer.start_as_current_span(\n                    f\"{name}-{version}-invoke\",\n                    context=context,\n                )\n                if st.telemetry_enabled()\n                else nullcontext()\n            ):\n                match root_handler_name:\n                    case \"skagents\":\n                        handler: BaseHandler = skagents_handle(config, app_config, authorization)\n                    case _:\n                        raise ValueError(f\"Unknown apiVersion: {config.apiVersion}\")\n\n                inv_inputs = inputs.__dict__\n                output = await handler.invoke(inputs=inv_inputs)\n                return output\n\n        @router.post(\"/sse\")\n        @docstring_parameter(description)\n        async def invoke_sse(inputs: input_class, request: Request) -&gt; StreamingResponse:\n            \"\"\"\n            {0}\n            Initiate SSE call\n            \"\"\"\n            st = get_telemetry()\n            context = extract(request.headers)\n            authorization = request.headers.get(\"authorization\", None)\n            inv_inputs = inputs.__dict__\n\n            async def event_generator():\n                with (\n                    st.tracer.start_as_current_span(\n                        f\"{config.service_name}-{str(config.version)}-invoke_sse\",\n                        context=context,\n                    )\n                    if st.telemetry_enabled()\n                    else nullcontext()\n                ):\n                    match root_handler_name:\n                        case \"skagents\":\n                            handler: BaseHandler = skagents_handle(\n                                config, app_config, authorization\n                            )\n                            # noinspection PyTypeChecker\n                            async for content in handler.invoke_stream(inputs=inv_inputs):\n                                yield get_sse_event_for_response(content)\n                        case _:\n                            logger.exception(\n                                \"Unknown apiVersion: %s\", config.apiVersion, exc_info=True\n                            )\n                            raise ValueError(f\"Unknown apiVersion: {config.apiVersion}\")\n\n            return StreamingResponse(event_generator(), media_type=\"text/event-stream\")\n\n        return router\n\n    @staticmethod\n    def get_websocket_routes(\n        name: str,\n        version: str,\n        root_handler_name: str,\n        config: BaseConfig,\n        app_config: AppConfig,\n        input_class: type,\n    ) -&gt; APIRouter:\n        router = APIRouter()\n\n        @router.websocket(\"/stream\")\n        async def invoke_stream(websocket: WebSocket) -&gt; None:\n            await websocket.accept()\n            st = get_telemetry()\n            context = extract(websocket.headers)\n\n            authorization = websocket.headers.get(\"authorization\", None)\n            try:\n                data = await websocket.receive_json()\n                with (\n                    st.tracer.start_as_current_span(\n                        f\"{name}-{str(version)}-invoke_stream\",\n                        context=context,\n                    )\n                    if st.telemetry_enabled()\n                    else nullcontext()\n                ):\n                    inputs = input_class(**data)\n                    inv_inputs = inputs.__dict__\n                    match root_handler_name:\n                        case \"skagents\":\n                            handler: BaseHandler = skagents_handle(\n                                config, app_config, authorization\n                            )\n                            async for content in handler.invoke_stream(inputs=inv_inputs):\n                                if isinstance(content, PartialResponse):\n                                    await websocket.send_text(content.output_partial)\n                            await websocket.close()\n                        case _:\n                            logger.exception(\n                                \"Unknown apiVersion: %s\", config.apiVersion, exc_info=True\n                            )\n                            raise ValueError(f\"Unknown apiVersion %s: {config.apiVersion}\")\n            except WebSocketDisconnect:\n                logger.exception(\"websocket disconnected\")\n                print(\"websocket disconnected\")\n\n        return router\n\n    @staticmethod\n    def get_stateful_routes(\n        name: str,\n        version: str,\n        description: str,\n        config: BaseConfig,\n        app_config: AppConfig,\n        state_manager: TaskPersistenceManager,\n        authorizer: RequestAuthorizer,\n        auth_storage_manager: SecureAuthStorageManager,\n        input_class: type[UserMessage],\n    ) -&gt; APIRouter:\n        \"\"\"\n        Get the stateful API routes for the given configuration.\n        \"\"\"\n        router = APIRouter()\n\n        async def get_user_id(authorization: str = Header(None)):\n            user_id = await authorizer.authorize_request(authorization)\n            if not user_id:\n                raise HTTPException(\n                    status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Authentication required\"\n                )\n            return user_id\n\n        @router.post(\n            \"\",\n            response_model=StateResponse,\n            summary=\"Send a message to the agent\",\n            response_description=\"Agent response with state identifiers\",\n            tags=[\"Agent\"],\n        )\n        async def chat(message: input_class, user_id: str = Depends(get_user_id)) -&gt; StateResponse:\n            # Handle new task creation or task retrieval\n            teal_handler = Routes.get_task_handler(config, app_config, user_id, state_manager)\n            response_content = await teal_handler.invoke(user_id, message)\n            # Return response with state identifiers\n            status = TaskStatus.COMPLETED.value\n            if type(response_content) is HitlResponse:\n                status = TaskStatus.PAUSED.value\n            return StateResponse(\n                session_id=response_content.session_id,\n                task_id=response_content.task_id,\n                request_id=response_content.request_id,\n                status=status,\n                content=response_content,  # Replace with actual response\n            )\n\n        return router\n\n    @staticmethod\n    def get_resume_routes(\n        config: BaseConfig, app_config: AppConfig, state_manager: TaskPersistenceManager\n    ) -&gt; APIRouter:\n        router = APIRouter()\n\n        @router.post(\"/tealagents/v1alpha1/resume/{request_id}\")\n        async def resume(request_id: str, request: Request, body: ResumeRequest):\n            authorization = request.headers.get(\"authorization\", None)\n            teal_handler = Routes.get_task_handler(config, app_config, authorization, state_manager)\n            try:\n                return await teal_handler.resume_task(authorization, request_id, body, stream=False)\n            except Exception as e:\n                logger.exception(f\"Error in resume: {e}\")\n                raise HTTPException(status_code=500, detail=\"Internal Server Error\") from e\n\n        @router.post(\"/tealagents/v1alpha1/resume/{request_id}/sse\")\n        async def resume_sse(request_id: str, request: Request, body: ResumeRequest):\n            authorization = request.headers.get(\"authorization\", None)\n            teal_handler = Routes.get_task_handler(config, app_config, authorization, state_manager)\n\n            async def event_generator():\n                try:\n                    async for content in teal_handler.resume_task(\n                        authorization, request_id, body, stream=True\n                    ):\n                        yield get_sse_event_for_response(content)\n                except Exception as e:\n                    logger.exception(f\"Error in resume_sse: {e}\")\n                    raise HTTPException(status_code=500, detail=\"Internal Server Error\") from e\n\n            return StreamingResponse(event_generator(), media_type=\"text/event-stream\")\n\n        return router\n</code></pre> <code></code> sk_agents.routes.Routes.get_a2a_routes <code>staticmethod</code> <pre><code>get_a2a_routes(\n    name: str,\n    version: str,\n    description: str,\n    config: BaseConfig,\n    app_config: AppConfig,\n    chat_completion_builder: ChatCompletionBuilder,\n    task_store: TaskStore,\n    state_manager: StateManager,\n) -&gt; APIRouter\n</code></pre> <p>DEPRECATION NOTICE: A2A (Agent-to-Agent) routes are being deprecated as part of the framework migration evaluation. This method is maintained for backward compatibility only. New development should avoid using A2A functionality.</p> Source code in <code>src/sk_agents/routes.py</code> <pre><code>@staticmethod\ndef get_a2a_routes(\n    name: str,\n    version: str,\n    description: str,\n    config: BaseConfig,\n    app_config: AppConfig,\n    chat_completion_builder: ChatCompletionBuilder,\n    task_store: TaskStore,\n    state_manager: StateManager,\n) -&gt; APIRouter:\n    \"\"\"\n    DEPRECATION NOTICE: A2A (Agent-to-Agent) routes are being deprecated\n    as part of the framework migration evaluation. This method is maintained for\n    backward compatibility only. New development should avoid using A2A functionality.\n    \"\"\"\n    a2a_app = A2AStarletteApplication(\n        agent_card=Routes.get_agent_card(config, app_config),\n        http_handler=Routes.get_request_handler(\n            config, app_config, chat_completion_builder, state_manager, task_store\n        ),\n    )\n    a2a_router = APIRouter()\n\n    @a2a_router.post(\"\")\n    @docstring_parameter(description)\n    async def handle_a2a(request: Request):\n        \"\"\"\n        {0}\n\n        Agent-to-Agent Invocation\n        \"\"\"\n        return await a2a_app._handle_requests(request)\n\n    @a2a_router.get(\"/.well-known/agent.json\")\n    @docstring_parameter(f\"{name}:{version} - {description}\")\n    async def handle_get_agent_card(request: Request):\n        \"\"\"\n        Retrieve agent card for {0}\n        \"\"\"\n        return await a2a_app._handle_get_agent_card(request)\n\n    return a2a_router\n</code></pre> <code></code> sk_agents.routes.Routes.get_stateful_routes <code>staticmethod</code> <pre><code>get_stateful_routes(\n    name: str,\n    version: str,\n    description: str,\n    config: BaseConfig,\n    app_config: AppConfig,\n    state_manager: TaskPersistenceManager,\n    authorizer: RequestAuthorizer,\n    auth_storage_manager: SecureAuthStorageManager,\n    input_class: type[UserMessage],\n) -&gt; APIRouter\n</code></pre> <p>Get the stateful API routes for the given configuration.</p> Source code in <code>src/sk_agents/routes.py</code> <pre><code>@staticmethod\ndef get_stateful_routes(\n    name: str,\n    version: str,\n    description: str,\n    config: BaseConfig,\n    app_config: AppConfig,\n    state_manager: TaskPersistenceManager,\n    authorizer: RequestAuthorizer,\n    auth_storage_manager: SecureAuthStorageManager,\n    input_class: type[UserMessage],\n) -&gt; APIRouter:\n    \"\"\"\n    Get the stateful API routes for the given configuration.\n    \"\"\"\n    router = APIRouter()\n\n    async def get_user_id(authorization: str = Header(None)):\n        user_id = await authorizer.authorize_request(authorization)\n        if not user_id:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Authentication required\"\n            )\n        return user_id\n\n    @router.post(\n        \"\",\n        response_model=StateResponse,\n        summary=\"Send a message to the agent\",\n        response_description=\"Agent response with state identifiers\",\n        tags=[\"Agent\"],\n    )\n    async def chat(message: input_class, user_id: str = Depends(get_user_id)) -&gt; StateResponse:\n        # Handle new task creation or task retrieval\n        teal_handler = Routes.get_task_handler(config, app_config, user_id, state_manager)\n        response_content = await teal_handler.invoke(user_id, message)\n        # Return response with state identifiers\n        status = TaskStatus.COMPLETED.value\n        if type(response_content) is HitlResponse:\n            status = TaskStatus.PAUSED.value\n        return StateResponse(\n            session_id=response_content.session_id,\n            task_id=response_content.task_id,\n            request_id=response_content.request_id,\n            status=status,\n            content=response_content,  # Replace with actual response\n        )\n\n    return router\n</code></pre>"},{"location":"reference/#sk_agents.ska_types","title":"sk_agents.ska_types","text":"sk_agents.ska_types.HistoryMessage <p>               Bases: <code>BaseModel</code></p> <p>A single interaction in a chat history. 'role' - Either 'user' (requestor) or 'assistant' (responder) indicating who sent the message. 'content' - The content of the message</p> Source code in <code>src/sk_agents/ska_types.py</code> <pre><code>class HistoryMessage(BaseModel):\n    \"\"\"A single interaction in a chat history.&lt;br/&gt;\n    'role' - Either 'user' (requestor) or 'assistant' (responder) indicating\n    who sent the message.&lt;br/&gt;\n    'content' - The content of the message\"\"\"\n\n    role: Literal[\"user\", \"assistant\"]\n    content: str\n</code></pre> <code></code> sk_agents.ska_types.BaseInput <p>               Bases: <code>KernelBaseModel</code></p> <p>The history of a chat interaction between an automated assistant and a human.</p> Source code in <code>src/sk_agents/ska_types.py</code> <pre><code>class BaseInput(KernelBaseModel):\n    \"\"\"The history of a chat interaction between an automated assistant and a\n    human.\"\"\"\n\n    chat_history: list[HistoryMessage] | None = None\n</code></pre> <code></code> sk_agents.ska_types.BaseInputWithUserContext <p>               Bases: <code>KernelBaseModel</code></p> <p>The history of a chat interaction between an automated assistant and a human, along with context about the user.</p> Source code in <code>src/sk_agents/ska_types.py</code> <pre><code>class BaseInputWithUserContext(KernelBaseModel):\n    \"\"\"The history of a chat interaction between an automated assistant and a\n    human, along with context about the user.\"\"\"\n\n    chat_history: list[HistoryMessage] | None = None\n    user_context: dict[str, str] | None = None\n</code></pre>"},{"location":"reference/#sk_agents.state","title":"sk_agents.state","text":"sk_agents.state.redis_state_manager <p>Redis implementation of the StateManager interface. This implementation uses Redis as the persistent store for task state management.</p> sk_agents.state.redis_state_manager.RedisStateManager <p>               Bases: <code>StateManager</code></p> <p>Redis implementation of the StateManager interface.</p> <p>This class provides Redis-based persistence for task state management.</p> Source code in <code>src/sk_agents/state/redis_state_manager.py</code> <pre><code>class RedisStateManager(StateManager):\n    \"\"\"Redis implementation of the StateManager interface.\n\n    This class provides Redis-based persistence for task state management.\n    \"\"\"\n\n    def __init__(\n        self,\n        redis_client: Redis,\n        ttl: int | None = None,\n        key_prefix: str = \"task_state:\",\n    ):\n        \"\"\"Initialize the RedisStateManager with a Redis client.\n\n        Args:\n            redis_client: An instance of Redis client\n            key_prefix: Prefix used for Redis keys (default: \"task_state:\")\n        \"\"\"\n        self._redis = redis_client\n        self._key_prefix = key_prefix\n        self._ttl = ttl\n\n    def _get_message_key(self, task_id: str) -&gt; str:\n        \"\"\"Generate a Redis key for a task's messages.\n\n        Args:\n            task_id: The ID of the task\n\n        Returns:\n            A Redis key string for the task's messages\n        \"\"\"\n        return f\"{self._key_prefix}{task_id}:messages\"\n\n    def _get_canceled_key(self, task_id: str) -&gt; str:\n        \"\"\"Generate a Redis key for a task's canceled status.\n\n        Args:\n            task_id: The ID of the task\n\n        Returns:\n            A Redis key string for the task's canceled status\n        \"\"\"\n        return f\"{self._key_prefix}{task_id}:canceled\"\n\n    async def update_task_messages(\n        self, task_id: str, new_message: HistoryMultiModalMessage\n    ) -&gt; list[HistoryMultiModalMessage]:\n        \"\"\"Updates the messages for a specific task.\n\n        Appends a new message to the task's message history and returns\n        the complete list of messages.\n\n        Args:\n            task_id: The ID of the task\n            new_message: The new message to add to the task's history\n\n        Returns:\n            The complete list of messages for the task\n        \"\"\"\n        # Get the Redis key for this task's messages\n        message_key = self._get_message_key(task_id)\n\n        # Serialize the new message to JSON with mode='json' to ensure enums are properly serialized\n        message_json = json.dumps(new_message.model_dump(mode=\"json\"))\n\n        # Add the new message to the list in Redis\n        await self._redis.rpush(message_key, message_json)\n        if self._ttl:\n            await self._redis.expire(message_key, int(self._ttl))\n\n        # Retrieve all messages for the task\n        message_jsons = await self._redis.lrange(message_key, 0, -1)\n\n        # Deserialize each message from JSON\n        messages = [\n            HistoryMultiModalMessage.model_validate(json.loads(msg)) for msg in message_jsons\n        ]\n\n        return messages\n\n    async def set_canceled(self, task_id: str) -&gt; None:\n        \"\"\"Marks a task as canceled.\n\n        Args:\n            task_id: The ID of the task to mark as canceled\n        \"\"\"\n        # Set the canceled flag for the task\n        await self._redis.set(self._get_canceled_key(task_id), \"1\", ex=self._ttl)\n\n    async def is_canceled(self, task_id: str) -&gt; bool:\n        \"\"\"Checks if a task is marked as canceled.\n\n        Args:\n            task_id: The ID of the task to check\n\n        Returns:\n            True if the task is canceled, False otherwise\n        \"\"\"\n        # Check if the canceled flag is set\n        canceled = await self._redis.get(self._get_canceled_key(task_id))\n        return canceled == \"1\"\n</code></pre> <code></code> sk_agents.state.redis_state_manager.RedisStateManager.__init__ <pre><code>__init__(\n    redis_client: Redis,\n    ttl: int | None = None,\n    key_prefix: str = \"task_state:\",\n)\n</code></pre> <p>Initialize the RedisStateManager with a Redis client.</p> <p>Parameters:</p> Name Type Description Default <code>redis_client</code> <code>Redis</code> <p>An instance of Redis client</p> required <code>key_prefix</code> <code>str</code> <p>Prefix used for Redis keys (default: \"task_state:\")</p> <code>'task_state:'</code> Source code in <code>src/sk_agents/state/redis_state_manager.py</code> <pre><code>def __init__(\n    self,\n    redis_client: Redis,\n    ttl: int | None = None,\n    key_prefix: str = \"task_state:\",\n):\n    \"\"\"Initialize the RedisStateManager with a Redis client.\n\n    Args:\n        redis_client: An instance of Redis client\n        key_prefix: Prefix used for Redis keys (default: \"task_state:\")\n    \"\"\"\n    self._redis = redis_client\n    self._key_prefix = key_prefix\n    self._ttl = ttl\n</code></pre> <code></code> sk_agents.state.redis_state_manager.RedisStateManager.update_task_messages <code>async</code> <pre><code>update_task_messages(\n    task_id: str, new_message: HistoryMultiModalMessage\n) -&gt; list[HistoryMultiModalMessage]\n</code></pre> <p>Updates the messages for a specific task.</p> <p>Appends a new message to the task's message history and returns the complete list of messages.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task</p> required <code>new_message</code> <code>HistoryMultiModalMessage</code> <p>The new message to add to the task's history</p> required <p>Returns:</p> Type Description <code>list[HistoryMultiModalMessage]</code> <p>The complete list of messages for the task</p> Source code in <code>src/sk_agents/state/redis_state_manager.py</code> <pre><code>async def update_task_messages(\n    self, task_id: str, new_message: HistoryMultiModalMessage\n) -&gt; list[HistoryMultiModalMessage]:\n    \"\"\"Updates the messages for a specific task.\n\n    Appends a new message to the task's message history and returns\n    the complete list of messages.\n\n    Args:\n        task_id: The ID of the task\n        new_message: The new message to add to the task's history\n\n    Returns:\n        The complete list of messages for the task\n    \"\"\"\n    # Get the Redis key for this task's messages\n    message_key = self._get_message_key(task_id)\n\n    # Serialize the new message to JSON with mode='json' to ensure enums are properly serialized\n    message_json = json.dumps(new_message.model_dump(mode=\"json\"))\n\n    # Add the new message to the list in Redis\n    await self._redis.rpush(message_key, message_json)\n    if self._ttl:\n        await self._redis.expire(message_key, int(self._ttl))\n\n    # Retrieve all messages for the task\n    message_jsons = await self._redis.lrange(message_key, 0, -1)\n\n    # Deserialize each message from JSON\n    messages = [\n        HistoryMultiModalMessage.model_validate(json.loads(msg)) for msg in message_jsons\n    ]\n\n    return messages\n</code></pre> <code></code> sk_agents.state.redis_state_manager.RedisStateManager.set_canceled <code>async</code> <pre><code>set_canceled(task_id: str) -&gt; None\n</code></pre> <p>Marks a task as canceled.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to mark as canceled</p> required Source code in <code>src/sk_agents/state/redis_state_manager.py</code> <pre><code>async def set_canceled(self, task_id: str) -&gt; None:\n    \"\"\"Marks a task as canceled.\n\n    Args:\n        task_id: The ID of the task to mark as canceled\n    \"\"\"\n    # Set the canceled flag for the task\n    await self._redis.set(self._get_canceled_key(task_id), \"1\", ex=self._ttl)\n</code></pre> <code></code> sk_agents.state.redis_state_manager.RedisStateManager.is_canceled <code>async</code> <pre><code>is_canceled(task_id: str) -&gt; bool\n</code></pre> <p>Checks if a task is marked as canceled.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the task is canceled, False otherwise</p> Source code in <code>src/sk_agents/state/redis_state_manager.py</code> <pre><code>async def is_canceled(self, task_id: str) -&gt; bool:\n    \"\"\"Checks if a task is marked as canceled.\n\n    Args:\n        task_id: The ID of the task to check\n\n    Returns:\n        True if the task is canceled, False otherwise\n    \"\"\"\n    # Check if the canceled flag is set\n    canceled = await self._redis.get(self._get_canceled_key(task_id))\n    return canceled == \"1\"\n</code></pre>"},{"location":"reference/#sk_agents.stateful","title":"sk_agents.stateful","text":"sk_agents.stateful.UserMessage <p>               Bases: <code>BaseModel</code></p> <p>New input model for the tealagents/v1alpha1 API version. Unlike BaseMultiModalInput, chat history is maintained server-side.</p> Source code in <code>src/sk_agents/stateful.py</code> <pre><code>class UserMessage(BaseModel):\n    \"\"\"\n    New input model for the tealagents/v1alpha1 API version.\n    Unlike BaseMultiModalInput, chat history is maintained server-side.\n    \"\"\"\n\n    session_id: UUID4 | None = None\n    task_id: UUID4 | None = None\n    items: list[MultiModalItem]\n\n    @field_validator(\"session_id\", \"task_id\", mode=\"before\")\n    @classmethod\n    def validate_uuid(cls, v):\n        if v is not None and not isinstance(v, uuid.UUID):\n            try:\n                return uuid.UUID(v)\n            except (ValueError, AttributeError) as err:\n                raise ValueError(f\"Invalid UUID format: {v}\") from err\n        return v\n</code></pre> <code></code> sk_agents.stateful.TaskState <p>               Bases: <code>BaseModel</code></p> <p>Model for the state associated with a Task ID</p> Source code in <code>src/sk_agents/stateful.py</code> <pre><code>class TaskState(BaseModel):\n    \"\"\"Model for the state associated with a Task ID\"\"\"\n\n    task_id: UUID4\n    session_id: UUID4\n    user_id: str  # User identity for authorization\n    messages: list[dict[str, Any]]  # Chat history and execution trace\n    status: TaskStatus = TaskStatus.RUNNING\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    updated_at: datetime = Field(default_factory=datetime.utcnow)\n    metadata: dict[str, Any] = Field(default_factory=dict)\n</code></pre> <code></code> sk_agents.stateful.RequestState <p>               Bases: <code>BaseModel</code></p> <p>Model for the state associated with a Request ID</p> Source code in <code>src/sk_agents/stateful.py</code> <pre><code>class RequestState(BaseModel):\n    \"\"\"Model for the state associated with a Request ID\"\"\"\n\n    request_id: UUID4\n    task_id: UUID4\n    status: TaskStatus = TaskStatus.RUNNING\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    updated_at: datetime = Field(default_factory=datetime.utcnow)\n    metadata: dict[str, Any] = Field(default_factory=dict)\n</code></pre> <code></code> sk_agents.stateful.StateResponse <p>               Bases: <code>BaseModel</code></p> <p>Response model including state identifiers</p> Source code in <code>src/sk_agents/stateful.py</code> <pre><code>class StateResponse(BaseModel):\n    \"\"\"Response model including state identifiers\"\"\"\n\n    session_id: UUID4\n    task_id: UUID4\n    request_id: UUID4\n    status: TaskStatus\n    content: InvokeResponse | RejectedToolResponse | HitlResponse | TealAgentsResponse\n</code></pre> <code></code> sk_agents.stateful.StateManager <p>               Bases: <code>ABC</code></p> <p>Abstract base class for state management</p> Source code in <code>src/sk_agents/stateful.py</code> <pre><code>class StateManager(ABC):\n    \"\"\"Abstract base class for state management\"\"\"\n\n    @abstractmethod\n    async def create_task(self, session_id: UUID4 | None, user_id: str) -&gt; tuple[UUID4, UUID4]:\n        \"\"\"Create a new task and return session_id and task_id\"\"\"\n\n    @abstractmethod\n    async def get_task(self, task_id: UUID4) -&gt; TaskState:\n        \"\"\"Get a task by ID\"\"\"\n\n    @abstractmethod\n    async def update_task(self, task_state: TaskState) -&gt; None:\n        \"\"\"Update a task state\"\"\"\n\n    @abstractmethod\n    async def create_request(self, task_id: UUID4) -&gt; UUID4:\n        \"\"\"Create a new request and return request_id\"\"\"\n\n    @abstractmethod\n    async def get_request(self, request_id: UUID4) -&gt; RequestState:\n        \"\"\"Get a request by ID\"\"\"\n\n    @abstractmethod\n    async def update_request(self, request_state: RequestState) -&gt; None:\n        \"\"\"Update a request state\"\"\"\n</code></pre> <code></code> sk_agents.stateful.StateManager.create_task <code>abstractmethod</code> <code>async</code> <pre><code>create_task(\n    session_id: UUID4 | None, user_id: str\n) -&gt; tuple[UUID4, UUID4]\n</code></pre> <p>Create a new task and return session_id and task_id</p> Source code in <code>src/sk_agents/stateful.py</code> <pre><code>@abstractmethod\nasync def create_task(self, session_id: UUID4 | None, user_id: str) -&gt; tuple[UUID4, UUID4]:\n    \"\"\"Create a new task and return session_id and task_id\"\"\"\n</code></pre> <code></code> sk_agents.stateful.StateManager.get_task <code>abstractmethod</code> <code>async</code> <pre><code>get_task(task_id: UUID4) -&gt; TaskState\n</code></pre> <p>Get a task by ID</p> Source code in <code>src/sk_agents/stateful.py</code> <pre><code>@abstractmethod\nasync def get_task(self, task_id: UUID4) -&gt; TaskState:\n    \"\"\"Get a task by ID\"\"\"\n</code></pre> <code></code> sk_agents.stateful.StateManager.update_task <code>abstractmethod</code> <code>async</code> <pre><code>update_task(task_state: TaskState) -&gt; None\n</code></pre> <p>Update a task state</p> Source code in <code>src/sk_agents/stateful.py</code> <pre><code>@abstractmethod\nasync def update_task(self, task_state: TaskState) -&gt; None:\n    \"\"\"Update a task state\"\"\"\n</code></pre> <code></code> sk_agents.stateful.StateManager.create_request <code>abstractmethod</code> <code>async</code> <pre><code>create_request(task_id: UUID4) -&gt; UUID4\n</code></pre> <p>Create a new request and return request_id</p> Source code in <code>src/sk_agents/stateful.py</code> <pre><code>@abstractmethod\nasync def create_request(self, task_id: UUID4) -&gt; UUID4:\n    \"\"\"Create a new request and return request_id\"\"\"\n</code></pre> <code></code> sk_agents.stateful.StateManager.get_request <code>abstractmethod</code> <code>async</code> <pre><code>get_request(request_id: UUID4) -&gt; RequestState\n</code></pre> <p>Get a request by ID</p> Source code in <code>src/sk_agents/stateful.py</code> <pre><code>@abstractmethod\nasync def get_request(self, request_id: UUID4) -&gt; RequestState:\n    \"\"\"Get a request by ID\"\"\"\n</code></pre> <code></code> sk_agents.stateful.StateManager.update_request <code>abstractmethod</code> <code>async</code> <pre><code>update_request(request_state: RequestState) -&gt; None\n</code></pre> <p>Update a request state</p> Source code in <code>src/sk_agents/stateful.py</code> <pre><code>@abstractmethod\nasync def update_request(self, request_state: RequestState) -&gt; None:\n    \"\"\"Update a request state\"\"\"\n</code></pre> <code></code> sk_agents.stateful.InMemoryStateManager <p>               Bases: <code>StateManager</code></p> <p>In-memory implementation of state manager</p> Source code in <code>src/sk_agents/stateful.py</code> <pre><code>class InMemoryStateManager(StateManager):\n    \"\"\"In-memory implementation of state manager\"\"\"\n\n    def __init__(self):\n        self.tasks: dict[UUID4, TaskState] = {}\n        self.requests: dict[UUID4, RequestState] = {}\n\n    async def create_task(self, session_id: UUID4 | None, user_id: str) -&gt; tuple[UUID4, UUID4]:\n        session_id = session_id or uuid.uuid4()\n        task_id = uuid.uuid4()\n        self.tasks[task_id] = TaskState(\n            task_id=task_id, session_id=session_id, user_id=user_id, messages=[]\n        )\n        return session_id, task_id\n\n    async def get_task(self, task_id: UUID4) -&gt; TaskState:\n        if task_id not in self.tasks:\n            raise ValueError(f\"Task not found: {task_id}\")\n        return self.tasks[task_id]\n\n    async def update_task(self, task_state: TaskState) -&gt; None:\n        task_state.updated_at = datetime.utcnow()\n        self.tasks[task_state.task_id] = task_state\n\n    async def create_request(self, task_id: UUID4) -&gt; UUID4:\n        request_id = uuid.uuid4()\n        self.requests[request_id] = RequestState(request_id=request_id, task_id=task_id)\n        return request_id\n\n    async def get_request(self, request_id: UUID4) -&gt; RequestState:\n        if request_id not in self.requests:\n            raise ValueError(f\"Request not found: {request_id}\")\n        return self.requests[request_id]\n\n    async def update_request(self, request_state: RequestState) -&gt; None:\n        request_state.updated_at = datetime.utcnow()\n        self.requests[request_state.request_id] = request_state\n</code></pre> <code></code> sk_agents.stateful.RedisStateManager <p>               Bases: <code>StateManager</code></p> <p>Redis implementation of state manager</p> Source code in <code>src/sk_agents/stateful.py</code> <pre><code>class RedisStateManager(StateManager):\n    \"\"\"Redis implementation of state manager\"\"\"\n\n    def __init__(self, redis_client: Redis, ttl: int | None = None):\n        self.redis = redis_client\n        self.ttl = ttl  # Time-to-live in seconds\n\n    async def create_task(self, session_id: UUID4 | None, user_id: str) -&gt; tuple[UUID4, UUID4]:\n        session_id = session_id or uuid.uuid4()\n        task_id = uuid.uuid4()\n        task_state = TaskState(task_id=task_id, session_id=session_id, user_id=user_id, messages=[])\n        await self._set_task(task_state)\n        return session_id, task_id\n\n    async def get_task(self, task_id: UUID4) -&gt; TaskState:\n        key = f\"task:{task_id}\"\n        data = await self.redis.get(key)\n        if not data:\n            raise ValueError(f\"Task not found: {task_id}\")\n        return TaskState.parse_raw(data)\n\n    async def update_task(self, task_state: TaskState) -&gt; None:\n        task_state.updated_at = datetime.utcnow()\n        await self._set_task(task_state)\n\n    async def _set_task(self, task_state: TaskState) -&gt; None:\n        key = f\"task:{task_state.task_id}\"\n        await self.redis.set(key, task_state.json(), ex=self.ttl)\n\n    async def create_request(self, task_id: UUID4) -&gt; UUID4:\n        request_id = uuid.uuid4()\n        request_state = RequestState(request_id=request_id, task_id=task_id)\n        await self._set_request(request_state)\n        return request_id\n\n    async def get_request(self, request_id: UUID4) -&gt; RequestState:\n        key = f\"request:{request_id}\"\n        data = await self.redis.get(key)\n        if not data:\n            raise ValueError(f\"Request not found: {request_id}\")\n        return RequestState.parse_raw(data)\n\n    async def update_request(self, request_state: RequestState) -&gt; None:\n        request_state.updated_at = datetime.utcnow()\n        await self._set_request(request_state)\n\n    async def _set_request(self, request_state: RequestState) -&gt; None:\n        key = f\"request:{request_state.request_id}\"\n        await self.redis.set(key, request_state.json(), ex=self.ttl)\n</code></pre> <code></code> sk_agents.stateful.AuthenticationManager <p>               Bases: <code>ABC</code></p> <p>Abstract base class for authentication management</p> Source code in <code>src/sk_agents/stateful.py</code> <pre><code>class AuthenticationManager(ABC):\n    \"\"\"Abstract base class for authentication management\"\"\"\n\n    @abstractmethod\n    async def authorize_request(self, token: str) -&gt; str:\n        \"\"\"Authenticate a token and return the user ID\"\"\"\n        pass\n\n    @abstractmethod\n    async def validate_task_access(self, task_id: UUID4, user_id: str) -&gt; bool:\n        \"\"\"Validate if a user has access to a task\"\"\"\n        pass\n</code></pre> <code></code> sk_agents.stateful.AuthenticationManager.authorize_request <code>abstractmethod</code> <code>async</code> <pre><code>authorize_request(token: str) -&gt; str\n</code></pre> <p>Authenticate a token and return the user ID</p> Source code in <code>src/sk_agents/stateful.py</code> <pre><code>@abstractmethod\nasync def authorize_request(self, token: str) -&gt; str:\n    \"\"\"Authenticate a token and return the user ID\"\"\"\n    pass\n</code></pre> <code></code> sk_agents.stateful.AuthenticationManager.validate_task_access <code>abstractmethod</code> <code>async</code> <pre><code>validate_task_access(task_id: UUID4, user_id: str) -&gt; bool\n</code></pre> <p>Validate if a user has access to a task</p> Source code in <code>src/sk_agents/stateful.py</code> <pre><code>@abstractmethod\nasync def validate_task_access(self, task_id: UUID4, user_id: str) -&gt; bool:\n    \"\"\"Validate if a user has access to a task\"\"\"\n    pass\n</code></pre> <code></code> sk_agents.stateful.MockAuthenticationManager <p>               Bases: <code>AuthenticationManager</code></p> <p>Mock implementation of authentication manager for development</p> Source code in <code>src/sk_agents/stateful.py</code> <pre><code>class MockAuthenticationManager(AuthenticationManager):\n    \"\"\"Mock implementation of authentication manager for development\"\"\"\n\n    async def authorize_request(self, token: str) -&gt; str:\n        # In mock implementation, just return the token as the user ID\n        # In real implementation, this would validate the token with Entra ID\n        return token or \"anonymous-user\"\n\n    async def validate_task_access(self, task_id: UUID4, user_id: str) -&gt; bool:\n        # In mock implementation, always return True\n        # In real implementation, this would check if the user owns the task\n        return True\n</code></pre>"},{"location":"reference/#sk_agents.tealagents","title":"sk_agents.tealagents","text":"sk_agents.tealagents.kernel_builder sk_agents.tealagents.kernel_builder.KernelBuilder Source code in <code>src/sk_agents/tealagents/kernel_builder.py</code> <pre><code>class KernelBuilder:\n    def __init__(\n        self,\n        chat_completion_builder: ChatCompletionBuilder,\n        remote_plugin_loader: RemotePluginLoader,\n        app_config: AppConfig,\n        authorization: str | None = None,\n    ):\n        self.chat_completion_builder: ChatCompletionBuilder = chat_completion_builder\n        self.remote_plugin_loader = remote_plugin_loader\n        self.app_config: AppConfig = app_config\n        self.authorization = authorization\n        self.logger = logging.getLogger(__name__)\n\n        # Initialize auth storage and authorizer for token cache functionality\n        self.auth_storage_manager: SecureAuthStorageManager = AuthStorageFactory(\n            app_config\n        ).get_auth_storage_manager()\n        self.authorizer: RequestAuthorizer = AuthorizerFactory(app_config).get_authorizer()\n\n    async def build_kernel(\n        self,\n        model_name: str,\n        service_id: str,\n        plugins: list[str],\n        remote_plugins: list[str],\n        authorization: str | None = None,\n        extra_data_collector: ExtraDataCollector | None = None,\n    ) -&gt; Kernel:\n        try:\n            kernel = self._create_base_kernel(model_name, service_id)\n            kernel = await self._parse_plugins(plugins, kernel, authorization, extra_data_collector)\n            return self._load_remote_plugins(remote_plugins, kernel)\n        except Exception as e:\n            self.logger.exception(f\"Could build kernel with service ID {service_id}. - {e}\")\n            raise\n\n    def get_model_type_for_name(self, model_name: str) -&gt; ModelType:\n        try:\n            return self.chat_completion_builder.get_model_type_for_name(model_name)\n        except Exception as e:\n            self.logger.exception(f\"Could not get model type for {model_name}. - {e}\")\n            raise\n\n    def model_supports_structured_output(self, model_name: str) -&gt; bool:\n        return self.chat_completion_builder.model_supports_structured_output(model_name)\n\n    def _create_base_kernel(self, model_name: str, service_id: str) -&gt; Kernel:\n        try:\n            chat_completion = self.chat_completion_builder.get_chat_completion_for_model(\n                service_id=service_id,\n                model_name=model_name,\n            )\n\n            kernel = Kernel()\n            kernel.add_service(chat_completion)\n\n            return kernel\n        except Exception as e:\n            self.logger.exception(f\"Could not create base kernelwith service id {service_id}.-{e}\")\n            raise\n\n    def _load_remote_plugins(self, remote_plugins: list[str], kernel: Kernel) -&gt; Kernel:\n        if remote_plugins is None or len(remote_plugins) &lt; 1:\n            return kernel\n        try:\n            self.remote_plugin_loader.load_remote_plugins(kernel, remote_plugins)\n            return kernel\n        except Exception as e:\n            self.logger.exception(f\"Could not load remote plugings. -{e}\")\n            raise\n\n    async def _parse_plugins(\n        self,\n        plugin_names: list[str],\n        kernel: Kernel,\n        authorization: str | None = None,\n        extra_data_collector: ExtraDataCollector | None = None,\n    ) -&gt; Kernel:\n        if plugin_names is None or len(plugin_names) &lt; 1:\n            return kernel\n\n        plugin_loader = get_plugin_loader()\n        plugins = plugin_loader.get_plugins(plugin_names)\n\n        for plugin_name, plugin_class in plugins.items():\n            # Get plugin-specific authorization (with token cache if available)\n            plugin_authorization = await self._get_plugin_authorization(plugin_name, authorization)\n\n            # Create and add the plugin to the kernel\n            kernel.add_plugin(plugin_class(plugin_authorization, extra_data_collector), plugin_name)\n\n        return kernel\n\n    async def _get_plugin_authorization(\n        self, plugin_name: str, original_authorization: str | None = None\n    ) -&gt; str | None:\n        \"\"\"\n        Get plugin-specific authorization, checking token cache for stored OAuth2 tokens.\n\n        Args:\n            plugin_name: Name of the plugin requesting authorization\n            original_authorization: Original authorization header from the request\n\n        Returns:\n            Authorization string to use for the plugin (either cached token or original)\n        \"\"\"\n        if not original_authorization:\n            return None\n\n        try:\n            # Extract user ID from the authorization header\n            user_id = await self.authorizer.authorize_request(original_authorization)\n            if not user_id:\n                self.logger.warning(\n                    f\"Could not extract user ID from authorization for plugin {plugin_name}\"\n                )\n                return original_authorization\n\n            # Try to retrieve cached OAuth2 tokens for this user and plugin\n            cached_auth_data = self.auth_storage_manager.retrieve(user_id, plugin_name)\n\n            if cached_auth_data and hasattr(cached_auth_data, \"access_token\"):\n                self.logger.info(f\"Using cached token for plugin {plugin_name}, user {user_id}\")\n                # Return the cached access token in Bearer format\n                return f\"Bearer {cached_auth_data.access_token}\"\n            else:\n                self.logger.debug(\n                    f\"No cached tokens found for plugin {plugin_name}, user {user_id} - \"\n                    f\"returning None\"\n                )\n                return None\n\n        except Exception as e:\n            self.logger.warning(\n                f\"Error retrieving cached tokens for plugin {plugin_name}: {e} - returning None\"\n            )\n            return None\n</code></pre> <code></code> sk_agents.tealagents.models <code></code> sk_agents.tealagents.models.TaskStatus <p>               Bases: <code>Enum</code></p> <p>Enum representing the status of a task</p> Source code in <code>src/sk_agents/tealagents/models.py</code> <pre><code>class TaskStatus(Enum):\n    \"\"\"Enum representing the status of a task\"\"\"\n\n    RUNNING = \"Running\"\n    PAUSED = \"Paused\"\n    COMPLETED = \"Completed\"\n    FAILED = \"Failed\"\n</code></pre> <code></code> sk_agents.tealagents.v1alpha1 <code></code> sk_agents.tealagents.v1alpha1.agent <code></code> sk_agents.tealagents.v1alpha1.agent.handler <code></code> sk_agents.tealagents.v1alpha1.agent.handler.TealAgentsV1Alpha1Handler <p>               Bases: <code>BaseHandler</code></p> Source code in <code>src/sk_agents/tealagents/v1alpha1/agent/handler.py</code> <pre><code>class TealAgentsV1Alpha1Handler(BaseHandler):\n    def __init__(\n        self,\n        config: BaseConfig,\n        app_config: AppConfig,\n        agent_builder: AgentBuilder,\n        state_manager: TaskPersistenceManager,\n    ):\n        self.version = config.version\n        self.name = config.name\n        if hasattr(config, \"spec\"):\n            self.config = Config(config=config)\n        else:\n            raise ValueError(\"Invalid config\")\n        self.agent_builder = agent_builder\n        self.state = state_manager\n        self.authorizer = DummyAuthorizer()\n\n    @staticmethod\n    async def _invoke_function(\n        kernel: Kernel, fc_content: FunctionCallContent\n    ) -&gt; FunctionResultContent:\n        \"\"\"Helper to execute a single tool function call.\"\"\"\n        function = kernel.get_function(\n            fc_content.plugin_name,\n            fc_content.function_name,\n        )\n        kernel_argument = fc_content.to_kernel_arguments()\n        function_result = await function.invoke(kernel, kernel_argument)\n        return FunctionResultContent.from_function_call_content_and_result(\n            fc_content, function_result\n        )\n\n    @staticmethod\n    def _augment_with_user_context(inputs: UserMessage, chat_history: ChatHistory) -&gt; None:\n        if inputs.user_context:\n            content = \"The following user context was provided:\\n\"\n            for key, value in inputs.user_context.items():\n                content += f\"  {key}: {value}\\n\"\n            chat_history.add_message(\n                ChatMessageContent(role=AuthorRole.USER, items=[TextContent(text=content)])\n            )\n\n    @staticmethod\n    def _configure_agent_task(\n        session_id: str,\n        user_id: str,\n        task_id: str,\n        role: Literal[\"user\", \"assistant\"],\n        request_id: str,\n        inputs: UserMessage,\n        status: Literal[\"Running\", \"Paused\", \"Completed\", \"Failed\", \"Canceled\"],\n    ) -&gt; AgentTask:\n        agent_items = []\n        for item in inputs.items:\n            task_item = AgentTaskItem(\n                task_id=task_id, role=role, item=item, request_id=request_id, updated=datetime.now()\n            )\n            agent_items.append(task_item)\n\n        agent_task = AgentTask(\n            task_id=task_id,\n            session_id=session_id,\n            user_id=user_id,\n            items=agent_items,\n            created_at=datetime.now(),\n            last_updated=datetime.now(),\n            status=status,\n        )\n        return agent_task\n\n    async def authenticate_user(self, token: str) -&gt; str:\n        try:\n            user_id = await self.authorizer.authorize_request(auth_header=token)\n            return user_id\n        except Exception as e:\n            raise AuthenticationException(\n                message=(f\"Unable to authenticate user, exception message: {e}\")\n            ) from e\n\n    @staticmethod\n    def handle_state_id(inputs: UserMessage) -&gt; tuple[str, str, str]:\n        if inputs.session_id:\n            session_id = inputs.session_id\n        else:\n            session_id = str(uuid.uuid4())\n\n        if inputs.task_id:\n            task_id = inputs.task_id\n        else:\n            task_id = str(uuid.uuid4())\n\n        request_id = str(uuid.uuid4())\n\n        return session_id, task_id, request_id\n\n    async def _manage_incoming_task(\n        self, task_id: str, session_id: str, user_id: str, request_id: str, inputs: UserMessage\n    ) -&gt; AgentTask | None:\n        try:\n            agent_task = await self.state.load(task_id)\n            if not agent_task:\n                agent_task = TealAgentsV1Alpha1Handler._configure_agent_task(\n                    session_id=session_id,\n                    user_id=user_id,\n                    task_id=task_id,\n                    role=\"user\",\n                    request_id=request_id,\n                    inputs=inputs,\n                    status=\"Running\",\n                )\n                await self.state.create(agent_task)\n                return agent_task\n        except (PersistenceLoadError, PersistenceCreateError) as e:\n            raise AgentInvokeException(\n                f\"Failed to load or create task {task_id}: {e.message}\"\n            ) from e\n        except Exception as e:\n            raise AgentInvokeException(\n                f\"Unexpected error occurred while managing incoming task {task_id}: {str(e)}\"\n            ) from e\n\n    async def _manage_agent_response_task(\n        self, agent_task: AgentTask, agent_response: TealAgentsResponse\n    ) -&gt; None:\n        new_item = AgentTaskItem(\n            task_id=agent_response.task_id,\n            role=\"assistant\",\n            item=MultiModalItem(content_type=ContentType.TEXT, content=agent_response.output),\n            request_id=agent_response.request_id,\n            updated=datetime.now(),\n        )\n        agent_task.items.append(new_item)\n        agent_task.last_updated = datetime.now()\n        await self.state.update(agent_task)\n\n    @staticmethod\n    def _validate_user_id(user_id: str, task_id: str, agent_task: AgentTask) -&gt; None:\n        try:\n            assert user_id == agent_task.user_id\n        except AssertionError as e:\n            raise AgentInvokeException(\n                message=(f\"Invalid user ID {user_id}and task ID {task_id} provided. {e}\")\n            ) from e\n\n    @staticmethod\n    def _build_chat_history(agent_task: AgentTask, chat_history: ChatHistory) -&gt; ChatHistory:\n        chat_message_items: list[TextContent | ImageContent] = []\n        for task_item in agent_task.items:\n            chat_message_items.append(item_to_content(task_item.item))\n            message_content = ChatMessageContent(role=task_item.role, items=chat_message_items)\n            chat_history.add_message(message_content)\n        return chat_history\n\n    @staticmethod\n    def _rejected_task_item(task_id: str, request_id: str) -&gt; AgentTaskItem:\n        return AgentTaskItem(\n            task_id=task_id,\n            role=\"user\",\n            item=MultiModalItem(content_type=ContentType.TEXT, content=\"tool execution rejected\"),\n            request_id=request_id,\n            updated=datetime.now(),\n        )\n\n    @staticmethod\n    def _approved_task_item(task_id: str, request_id: str) -&gt; AgentTaskItem:\n        return AgentTaskItem(\n            task_id=task_id,\n            role=\"user\",\n            item=MultiModalItem(content_type=ContentType.TEXT, content=\"tool execution approved\"),\n            request_id=request_id,\n            updated=datetime.now(),\n        )\n\n    async def _manage_hitl_exception(\n        self,\n        agent_task: AgentTask,\n        session_id: str,\n        task_id: str,\n        request_id: str,\n        function_calls: list,\n        chat_history: ChatHistory,\n    ):\n        agent_task.status = \"Paused\"\n        assistant_item = AgentTaskItem(\n            task_id=task_id,\n            role=\"assistant\",\n            item=MultiModalItem(\n                content_type=ContentType.TEXT, content=\"HITL intervention required.\"\n            ),\n            request_id=request_id,\n            updated=datetime.now(),\n            pending_tool_calls=[fc.model_dump() for fc in function_calls],\n            chat_history=chat_history,\n        )\n        agent_task.items.append(assistant_item)\n        agent_task.last_updated = datetime.now()\n        await self.state.update(agent_task)\n\n        base_url = \"/tealagents/v1alpha1/resume\"\n        approval_url = f\"{base_url}/{request_id}?action=approve\"\n        rejection_url = f\"{base_url}/{request_id}?action=reject\"\n\n        hitl_response = HitlResponse(\n            session_id=session_id,\n            task_id=task_id,\n            request_id=request_id,\n            tool_calls=[fc.model_dump() for fc in function_calls],\n            approval_url=approval_url,\n            rejection_url=rejection_url,\n        )\n        return hitl_response\n\n    @staticmethod\n    async def _manage_function_calls(\n        function_calls: list[FunctionCallContent], chat_history: ChatHistory, kernel: Kernel\n    ) -&gt; None:\n        intervention_calls = []\n        non_intervention_calls = []\n\n        # Separate function calls into intervention and non-intervention\n        for fc in function_calls:\n            if hitl_manager.check_for_intervention(fc):\n                intervention_calls.append(fc)\n            else:\n                non_intervention_calls.append(fc)\n\n        # Process non-intervention function calls first\n        if non_intervention_calls:\n            results = await asyncio.gather(\n                *[\n                    TealAgentsV1Alpha1Handler._invoke_function(kernel, fc)\n                    for fc in non_intervention_calls\n                ]\n            )\n\n            # Add results to history\n            for result in results:\n                chat_history.add_message(result.to_chat_message_content())\n\n        # Handle intervention function calls\n        if intervention_calls:\n            logger.info(f\"Intervention required for{len(intervention_calls)} function calls.\")\n            raise hitl_manager.HitlInterventionRequired(intervention_calls)\n\n    async def prepare_agent_response(\n        self,\n        agent_task: AgentTask,\n        request_id: str,\n        response: ChatMessageContent | list[str],\n        token_usage: TokenUsage,\n        extra_data_collector: ExtraDataCollector,\n    ):\n        if isinstance(response, list):\n            agent_output = \"\".join(response)\n        else:\n            agent_output = response.content\n\n        total_tokens = token_usage.total_tokens\n        session_id = agent_task.session_id\n        task_id = agent_task.task_id\n        request_id = request_id\n\n        agent_response = TealAgentsResponse(\n            session_id=session_id,\n            task_id=task_id,\n            request_id=request_id,\n            output=agent_output,\n            source=f\"{self.name}:{self.version}\",\n            token_usage=token_usage,\n            extra_data=extra_data_collector.get_extra_data(),\n        )\n        await self._manage_agent_response_task(agent_task, agent_response)\n        logger.info(\n            f\"{self.name}:{self.version}\"\n            f\"successful invocation with {total_tokens} tokens. \"\n            f\"Session ID: {session_id}, Task ID: {task_id},\"\n            f\"Request ID {request_id}\"\n        )\n        return agent_response\n\n    async def resume_task(\n        self, auth_token: str, request_id: str, action_status: ResumeRequest, stream: bool\n    ) -&gt; (\n        TealAgentsResponse\n        | RejectedToolResponse\n        | HitlResponse\n        | AsyncIterable[TealAgentsResponse | TealAgentsPartialResponse | HitlResponse]\n    ):\n        user_id = await self.authenticate_user(token=auth_token)\n        agent_task = await self.state.load_by_request_id(request_id)\n        if agent_task is None:\n            raise AgentInvokeException(f\"No agent task found for request ID: {request_id}\")\n\n        # Validate task has items\n        if not agent_task.items:\n            raise AgentInvokeException(\n                f\"Cannot resume task {request_id}: task has no items. \"\n                f\"Task may be corrupted or improperly initialized.\"\n            )\n\n        session_id = agent_task.session_id\n        task_id = agent_task.task_id\n\n        # Retrieve chat history from last item with validation\n        last_item = agent_task.items[-1]\n        if last_item.chat_history is None:\n            raise AgentInvokeException(\n                f\"Cannot resume task {request_id}: chat history not preserved in paused state. \"\n                f\"This indicates a persistence layer issue during HITL pause.\"\n            )\n        chat_history = last_item.chat_history\n\n        TealAgentsV1Alpha1Handler._validate_user_id(user_id, task_id, agent_task)\n\n        # Validate task is in correct state for resumption\n        if agent_task.status != \"Paused\":\n            raise AgentInvokeException(\n                f\"Cannot resume task {task_id}: task is in '{agent_task.status}' state, \"\n                f\"expected 'Paused'. Task may have already been processed or cancelled.\"\n            )\n\n        if action_status.action != \"approve\":\n            agent_task.status = \"Canceled\"\n            agent_task.items.append(\n                TealAgentsV1Alpha1Handler._rejected_task_item(\n                    task_id=task_id, request_id=request_id\n                )\n            )\n            agent_task.last_updated = datetime.now()\n            await self.state.update(agent_task)\n            return RejectedToolResponse(\n                task_id=task_id, session_id=agent_task.session_id, request_id=request_id\n            )\n        # Record Approval state\n        agent_task.status = \"Running\"\n        agent_task.items.append(\n            TealAgentsV1Alpha1Handler._approved_task_item(\n                task_id=agent_task.task_id, request_id=request_id\n            )\n        )\n        agent_task.last_updated = datetime.now()\n        await self.state.update(agent_task)\n\n        # Retrieve the pending_tool_calls from the last AgentTaskItem before approval/rejection item\n        # Validate sufficient items exist\n        if len(agent_task.items) &lt; 2:\n            raise AgentInvokeException(\n                f\"Invalid task state for request ID {request_id}: \"\n                f\"expected at least 2 task items for HITL resume, found {len(agent_task.items)}\"\n            )\n\n        pending_tools_item = agent_task.items[-2]\n        if not pending_tools_item.pending_tool_calls:\n            raise AgentInvokeException(\n                f\"Pending tool calls not found for request ID: {request_id}. \"\n                f\"Task item at index -2 has no pending tool calls.\"\n            )\n\n        _pending_tools = list(pending_tools_item.pending_tool_calls)\n        pending_tools = [FunctionCallContent(**function_call) for function_call in _pending_tools]\n\n        # Execute the tool calls using asyncio.gather(),\n        # just as the agent would have.\n        extra_data_collector = ExtraDataCollector()\n        agent = await self.agent_builder.build_agent(self.config.get_agent(), extra_data_collector)\n        kernel = agent.agent.kernel\n\n        # Create ToolContent objects from the results\n        results = await asyncio.gather(\n            *[TealAgentsV1Alpha1Handler._invoke_function(kernel, fc) for fc in pending_tools]\n        )\n        # Add results to chat history\n        for result in results:\n            chat_history.add_message(result.to_chat_message_content())\n\n        if stream:\n            final_response_stream = self.recursion_invoke_stream(\n                chat_history, session_id, task_id, request_id\n            )\n            return final_response_stream\n        else:\n            final_response_invoke = await self.recursion_invoke(\n                inputs=chat_history, session_id=session_id, request_id=request_id, task_id=task_id\n            )\n\n            return final_response_invoke\n\n    async def invoke(\n        self, auth_token: str, inputs: UserMessage\n    ) -&gt; TealAgentsResponse | HitlResponse:\n        # Initial setup\n        logger.info(\"Beginning processing invoke\")\n\n        user_id = await self.authenticate_user(token=auth_token)\n        state_ids = TealAgentsV1Alpha1Handler.handle_state_id(inputs)\n        session_id, task_id, request_id = state_ids\n        inputs.session_id = session_id\n        inputs.task_id = task_id\n        agent_task = await self._manage_incoming_task(\n            task_id, session_id, user_id, request_id, inputs\n        )\n        if agent_task is None:\n            raise AgentInvokeException(\"Agent task not created\")\n        # Check user_id match request and state\n        TealAgentsV1Alpha1Handler._validate_user_id(user_id, task_id, agent_task)\n\n        chat_history = ChatHistory()\n        TealAgentsV1Alpha1Handler._augment_with_user_context(\n            inputs=inputs, chat_history=chat_history\n        )\n        TealAgentsV1Alpha1Handler._build_chat_history(agent_task, chat_history)\n        logger.info(\"Building the final response\")\n        final_response_invoke = await self.recursion_invoke(\n            inputs=chat_history, session_id=session_id, request_id=request_id, task_id=task_id\n        )\n        logger.info(\"Final response complete\")\n        return final_response_invoke\n\n    async def invoke_stream(\n        self, auth_token: str, inputs: UserMessage\n    ) -&gt; AsyncIterable[TealAgentsResponse | TealAgentsPartialResponse | HitlResponse]:\n        # Initial setup\n        logger.info(\"Beginning processing invoke\")\n        user_id = await self.authenticate_user(token=auth_token)\n        state_ids = TealAgentsV1Alpha1Handler.handle_state_id(inputs)\n        session_id, task_id, request_id = state_ids\n        agent_task = await self._manage_incoming_task(\n            task_id, session_id, user_id, request_id, inputs\n        )\n        if agent_task is None:\n            raise AgentInvokeException(\"Agent task not created\")\n        # Check user_id match request and state\n        TealAgentsV1Alpha1Handler._validate_user_id(user_id, task_id, agent_task)\n\n        chat_history = ChatHistory()\n        TealAgentsV1Alpha1Handler._augment_with_user_context(\n            inputs=inputs, chat_history=chat_history\n        )\n        logger.info(\"Building the final response\")\n        TealAgentsV1Alpha1Handler._build_chat_history(agent_task, chat_history)\n        final_response_stream = self.recursion_invoke_stream(\n            chat_history, session_id, task_id, request_id\n        )\n        logger.info(\"Final response complete\")\n        return final_response_stream\n\n    async def recursion_invoke(\n        self, inputs: ChatHistory, session_id: str, task_id: str, request_id: str\n    ) -&gt; TealAgentsResponse | HitlResponse:\n        # Initial setup\n\n        chat_history = inputs\n        agent_task = await self.state.load_by_request_id(request_id)\n        if not agent_task:\n            raise PersistenceLoadError(f\"Agent task with ID {task_id} not found in state.\")\n\n        extra_data_collector = ExtraDataCollector()\n        agent = await self.agent_builder.build_agent(self.config.get_agent(), extra_data_collector)\n\n        # Prepare metadata\n        completion_tokens: int = 0\n        prompt_tokens: int = 0\n        total_tokens: int = 0\n\n        try:\n            # Manual tool calling implementation (existing logic)\n            kernel = agent.agent.kernel\n            arguments = agent.agent.arguments\n            chat_completion_service, settings = kernel.select_ai_service(\n                arguments=arguments, type=ChatCompletionClientBase\n            )\n\n            assert isinstance(chat_completion_service, ChatCompletionClientBase)\n\n            # Initial call to the LLM\n            response_list = []\n            responses = await chat_completion_service.get_chat_message_contents(\n                chat_history=chat_history,\n                settings=settings,\n                kernel=kernel,\n                arguments=arguments,\n            )\n            for response_chunk in responses:\n                # response_list.extend(response_chunk)\n                chat_history.add_message(response_chunk)\n                response_list.append(response_chunk)\n\n            function_calls = []\n            final_response = None\n\n            # Separate content and tool calls\n            for response in response_list:\n                # Update token usage\n                call_usage = get_token_usage_for_response(agent.get_model_type(), response)\n                completion_tokens += call_usage.completion_tokens\n                prompt_tokens += call_usage.prompt_tokens\n                total_tokens += call_usage.total_tokens\n\n                # A response may have multiple items, e.g., multiple tool calls\n                fc_in_response = [\n                    item for item in response.items if isinstance(item, FunctionCallContent)\n                ]\n\n                if fc_in_response:\n                    # chat_history.add_message(response)\n                    # Add assistant's message to history\n                    function_calls.extend(fc_in_response)\n                else:\n                    # If no function calls, it's a direct answer\n                    final_response = response\n            token_usage = TokenUsage(\n                completion_tokens=completion_tokens,\n                prompt_tokens=prompt_tokens,\n                total_tokens=total_tokens,\n            )\n            # If tool calls were returned, execute them\n            if function_calls:\n                await self._manage_function_calls(function_calls, chat_history, kernel)\n\n                # Make a recursive call to get the final response from the LLM\n                recursive_response = await self.recursion_invoke(\n                    inputs=chat_history,\n                    session_id=session_id,\n                    task_id=task_id,\n                    request_id=request_id,\n                )\n                return recursive_response\n\n            # No tool calls, return the direct response\n            if final_response is None:\n                error_msg = (\n                    f\"No response received from LLM for Session ID {session_id}, \"\n                    f\"Task ID {task_id}, Request ID {request_id}. \"\n                    f\"Function calls processed: {len(function_calls)}\"\n                )\n                logger.error(error_msg)\n                raise AgentInvokeException(error_msg)\n        except hitl_manager.HitlInterventionRequired as hitl_exc:\n            return await self._manage_hitl_exception(\n                agent_task, session_id, task_id, request_id, hitl_exc.function_calls, chat_history\n            )\n\n        except Exception as e:\n            logger.exception(\n                f\"Error invoking {self.name}:{self.version}\"\n                f\"for Session ID {session_id}, Task ID {task_id},\"\n                f\"Request ID {request_id}, Error message: {str(e)}\",\n                exc_info=True,\n            )\n            raise AgentInvokeException(\n                f\"Error invoking {self.name}:{self.version}\"\n                f\"for Session ID {session_id}, Task ID {task_id},\"\n                f\" Request ID {request_id}, Error message: {str(e)}\"\n            ) from e\n\n        # Persist and return response\n        return await self.prepare_agent_response(\n            agent_task, request_id, final_response, token_usage, extra_data_collector\n        )\n\n    async def recursion_invoke_stream(\n        self, inputs: ChatHistory, session_id: str, task_id: str, request_id: str\n    ) -&gt; AsyncIterable[TealAgentsResponse | TealAgentsPartialResponse | HitlResponse]:\n        chat_history = inputs\n        agent_task = await self.state.load_by_request_id(request_id)\n        if not agent_task:\n            raise PersistenceLoadError(f\"Agent task with ID {task_id} not found in state.\")\n\n        extra_data_collector = ExtraDataCollector()\n        agent = await self.agent_builder.build_agent(self.config.get_agent(), extra_data_collector)\n\n        # Prepare metadata\n        final_response = []\n        completion_tokens: int = 0\n        prompt_tokens: int = 0\n        total_tokens: int = 0\n\n        try:\n            kernel = agent.agent.kernel\n            arguments = agent.agent.arguments\n            kernel_configs = kernel.select_ai_service(\n                arguments=arguments, type=ChatCompletionClientBase\n            )\n            chat_completion_service, settings = kernel_configs\n            assert isinstance(chat_completion_service, ChatCompletionClientBase)\n\n            all_responses = []\n            # Stream the initial response from the LLM\n            response_list = []\n            responses = await chat_completion_service.get_chat_message_contents(\n                chat_history=chat_history,\n                settings=settings,\n                kernel=kernel,\n                arguments=arguments,\n            )\n            for response_chunk in responses:\n                chat_history.add_message(response_chunk)\n                response_list.append(response_chunk)\n\n            for response in response_list:\n                all_responses.append(response)\n                # Calculate usage metrics\n                call_usage = get_token_usage_for_response(agent.get_model_type(), response)\n                completion_tokens += call_usage.completion_tokens\n                prompt_tokens += call_usage.prompt_tokens\n                total_tokens += call_usage.total_tokens\n\n                if response.content:\n                    try:\n                        # Attempt to parse as ExtraDataPartial\n                        extra_data_partial: ExtraDataPartial = ExtraDataPartial.new_from_json(\n                            response.content\n                        )\n                        extra_data_collector.add_extra_data_items(extra_data_partial.extra_data)\n                    except Exception:\n                        if len(response.content) &gt; 0:\n                            # Handle and return partial response\n                            final_response.append(response.content)\n                            yield TealAgentsPartialResponse(\n                                session_id=session_id,\n                                task_id=task_id,\n                                request_id=request_id,\n                                output_partial=response.content,\n                                source=f\"{self.name}:{self.version}\",\n                            )\n\n            token_usage = TokenUsage(\n                completion_tokens=completion_tokens,\n                prompt_tokens=prompt_tokens,\n                total_tokens=total_tokens,\n            )\n            # Aggregate the full response to check for tool calls\n            if not all_responses:\n                return\n\n            full_completion: StreamingChatMessageContent = reduce(lambda x, y: x + y, all_responses)\n            function_calls = [\n                item for item in full_completion.items if isinstance(item, FunctionCallContent)\n            ]\n\n            # If tool calls are present, execute them\n            if function_calls:\n                await self._manage_function_calls(function_calls, chat_history, kernel)\n                # Make a recursive call to get the final streamed response\n                async for final_response_chunk in self.recursion_invoke_stream(\n                    chat_history, session_id, task_id, request_id\n                ):\n                    yield final_response_chunk\n                return\n        except hitl_manager.HitlInterventionRequired as hitl_exc:\n            yield await self._manage_hitl_exception(\n                agent_task, session_id, task_id, request_id, hitl_exc.function_calls, chat_history\n            )\n            return\n\n        except Exception as e:\n            logger.exception(\n                f\"Error invoking stream for {self.name}:{self.version} \"\n                f\"for Session ID {session_id}, Task ID {task_id},\"\n                f\" Request ID {request_id}, Error message: {str(e)}\",\n                exc_info=True,\n            )\n            raise AgentInvokeException(\n                f\"Error invoking stream for {self.name}:{self.version}\"\n                f\"for Session ID {session_id}, Task ID {task_id},\"\n                f\"Request ID {request_id}, Error message: {str(e)}\"\n            ) from e\n\n        # # Persist and return response\n        yield await self.prepare_agent_response(\n            agent_task, request_id, final_response, token_usage, extra_data_collector\n        )\n</code></pre>"},{"location":"demos/01_getting_started/","title":"Configuring an Agent","text":"<p>All agents are configured using a YAML configuration file. For a very simple agent that simply interacts with the user using a specified LLM, your agent config file might look something like:</p> <pre><code>apiVersion: skagents/v1\nkind: Sequential\ndescription: &gt;\n  A simple chat agent\nservice_name: ChatBot\nversion: 0.1\ninput_type: BaseInput\nspec:\n  agents:\n    - name: default\n      role: Default Agent\n      model: gpt-4o\n      system_prompt: &gt;\n        You are a helpful assistant.\n  tasks:\n    - name: action_task\n      task_no: 1\n      description: Chat with user\n      instructions: &gt;\n        Work with the user to assist them in whatever they need.\n      agent: default\n</code></pre> <p>An agent configuration file can contain the following elements:</p> <ul> <li>apiVersion - At present, this should always be <code>skagents/v1</code></li> <li>kind - The way in which an agent will execute its tasks. Currently only the   value <code>Sequential</code> is supported, which means, for each invocation, the agent   will execute all tasks in the defined order.</li> <li>description (optional) - A description of the agent</li> <li>service_name - The name of the agent (and thus its service). This, in   combination with the version will make up the agent's REST and streaming   endpoints. In this example, said endpoints would be<ul> <li><code>/ChatBot/0.1</code></li> <li><code>/ChatBot/0.1/stream</code></li> </ul> </li> <li>version - The version of the agent (see above)</li> <li>input_type - The payload format for requests to this agent (more on this   later)</li> <li>output_type (optional - not shown) - The payload format for responses from   this agent (more on this later)</li> <li>spec - Agent and task configuration</li> <li>agents - A list of agents that can be used by tasks<ul> <li>name - The name of the agent</li> <li>role - The role/description of the agent</li> <li>model - The LLM model to use</li> <li>system_prompt - A system prompt for the agent</li> </ul> </li> <li>tasks - A list of tasks to be executed by the agent<ul> <li>name - The name of the task</li> <li>task_no - The order in which the task should be executed</li> <li>description - A description of the task</li> <li>instructions - Instructions for the task</li> <li>agent - The agent to use for the task (must match agent defined in the agents section)</li> </ul> </li> </ul>"},{"location":"demos/01_getting_started/#currently-available-models","title":"Currently available models","text":"<p>The models currently available for agent configuration include:</p> <ul> <li>gpt-4o (Not for MSD usage)</li> <li>gpt-4o-mini (Not for MSD usage)</li> </ul>"},{"location":"demos/02_input_output/","title":"Working with custom input and output types","text":"<p>When building an agent, you must specify what types of input it should receive. This input can be either one of the standard types included with the SK Agents Framework or a type you define yourself.</p>"},{"location":"demos/02_input_output/#available-standard-types","title":"Available Standard Types","text":"<ul> <li>BaseInput - A base input type containing chat history for   chat-like interactions</li> </ul> <p>You also have the option to specify a custom output type which will be used in REST calls as the output format for the response from the agent.</p> <p>To define either a custom input or output type, simply create a new Python file and create classes which inherit from <code>KernelBaseModel</code> in the <code>semantic_kernel.kernel_pydantic</code> package. Once defined, you can specify the types in your agent's configuration file.</p>"},{"location":"demos/02_input_output/#sk_agents.ska_types.BaseInput","title":"sk_agents.ska_types.BaseInput","text":"<p>               Bases: <code>KernelBaseModel</code></p> <p>The history of a chat interaction between an automated assistant and a human.</p> Source code in <code>src/sk_agents/ska_types.py</code> <pre><code>class BaseInput(KernelBaseModel):\n    \"\"\"The history of a chat interaction between an automated assistant and a\n    human.\"\"\"\n\n    chat_history: list[HistoryMessage] | None = None\n</code></pre>"},{"location":"demos/02_input_output/#rest-output","title":"REST Output","text":"<p>When invoking an agent using the REST endpoint, your output will always follow the below format: <pre><code>{\n  \"token_usage\": {\n    \"completion_tokens\": 0,\n    \"prompt_tokens\": 0,\n    \"total_tokens\": 0\n  },\n  \"extra_data\": {},\n  \"output_raw\": \"string\",\n  \"output_pydantic\": \"null or user-defined output type\"\n}\n</code></pre> <code>extra_data</code> provides a mechanism by which plugins can return additional data along with the output.</p> <p><code>output_raw</code> will contain the raw output from the agent, as a string.</p> <p>If you have defined a custom output type, the <code>output_pydantic</code> field will contain the output in the format of your defined class.</p> <p>Note: It is likely that future versions of the Framework will do away with the redundant output fields and your output will be either the raw string (if no custom output type was defined) or the output in the format of your defined class.</p>"},{"location":"demos/02_input_output/#streaming-output","title":"Streaming Output","text":"<p>When invoking an agent using the streaming endpoint, the output will always be the raw text output as structured output would not make sense in the streaming context.</p> <p><code>extra_data</code>, if populated, will be sent as a final message after all other text has been sent. The message will be in the format of: <pre><code>{\n  \"extra_data\": {\n    \"key\": \"value\",\n    ...\n  }\n}\n</code></pre></p> <p>Note: Currently, token usage metrics are not available via the streaming endpoint as it is not currently supported for any models by Semantic Kernel. There is planned support for this, however, so it will likely be included in a future version.</p>"},{"location":"demos/02_input_output/#number-adder-example","title":"Number Adder Example","text":"<p>For example, if we wanted to create an agent which adds two numbers together, and returns the result, we could define input and output types which looked like the following:</p> <pre><code># custom_types.py\nfrom semantic_kernel.kernel_pydantic import KernelBaseModel\n\nclass NumbersInput(KernelBaseModel):\n    number_1: int\n    number_2: int\n\nclass AddOutput(KernelBaseModel):\n    result: int\n</code></pre> <p>In the agent's configuration file, we would specify the input and output types by setting the <code>input_type</code> and <code>output_type</code> fields. <pre><code>apiVersion: skagents/v1\nkind: Sequential\ndescription: &gt;\n  A number adder\nservice_name: AdderAgent\nversion: 0.1\ninput_type: NumbersInput\noutput_type: AddOutput\nspec:\n  agents:\n    - name: default\n      role: Default Agent\n      model: gpt-4o\n      system_prompt: &gt;\n        You are a helpful assistant.\n  tasks:\n    - name: action_task\n      task_no: 1\n      description: Add two number\n      instructions: &gt;\n        Add the following two numbers together\n        {{number_1}} {{number_2}}\n      agent: default\n</code></pre></p> <p>Finally, to let the Framework know where our custom types have been defined, we'll need to set an environment variable defining the location of our custom types file:</p> <pre><code>TA_API_KEY=&lt;your-API-key&gt;\nTA_SERVICE_CONFIG=demos/02_input_output/config.yaml\nTA_TYPES_MODULE=demos/02_input_output/custom_types.py\n</code></pre> <p>Now, when we run the agent with the above environment file:</p> <pre><code>$ fastapi run src/sk_agents/app.py\n</code></pre> <p>We'll see that the request payload now matches our defined input type: </p> <p>Additionally, we'll see that the response payload contains a key called <code>output_pydantic</code> which matches the format of our defined output class.</p> <p></p>"},{"location":"demos/03_plugins/","title":"Plugins","text":"<p>Plugins are a concept unique to Semantic Kernel, in the agent framework space. Rather than giving agents access to individual tools, SK introduces the concept of plugins, which can be bundles of similar tools, thus more closely aligning with traditional concepts in software development around the creation of APIs.</p> <p>In the SK Agent Framework, plugins can be included in two ways: 1. Local/Custom Plugins 2. OpenAPI API Plugins</p>"},{"location":"demos/03_plugins/#localcustom-plugins","title":"Local/Custom Plugins","text":"<p>Local plugins are plugins that are created by the user and are specific to this agent. To create one, simply create a new Python file which will be included with your agent. The file should contain one or more plugin classes which are derived from <code>BasePlugin</code> in the <code>ska_types</code> module and which contain methods annotated with the <code>kernel_function</code> annotation from Semantic Kernel (<code>semantic_kernel.functions.kernel_function_decorator</code>).</p>"},{"location":"demos/03_plugins/#authorization-extra-data","title":"Authorization &amp; Extra Data","text":"<p>Your custom plugin classes MUST inherit from BasePlugin. This base class has an <code>__init__</code> method which accepts two arguments:</p> <ul> <li><code>authorization</code> which contains the value contained in the <code>Authorization</code>    header received from the client, if one is present. You can access the    authorization token (if present) via <code>self.authorization</code>.</li> <li><code>extra_data_collector</code> which contains an instance of <code>ExtraDataCollector</code>    which can be used to add extra data to the response. Extra data comes in the    format of key/value pairs. Use the <code>add_extra_data</code> method within the plugin    to include extra data.</li> </ul> <p>If you're overriding the <code>__init__</code> method in your custom plugin, make sure to call the base class's <code>__init__</code> method with the <code>authorization</code> and <code>extra_data</code> arguments.</p>"},{"location":"demos/03_plugins/#example","title":"Example","text":"<p>In this example, we've defined a <code>WeatherPlugin</code> which contains two annotated methods <code>gat_lat_lng_for_location</code> and <code>get_temperature</code>. The first method takes as input a location search string and returns the latitude, longitude, and timezone of the location. The second method takes as input the latitude, longitude, and timezone of a location and returns the low and high temperatures.</p> <pre><code>...\nclass WeatherPlugin(BasePlugin):\n   @staticmethod\n   def _get_temp_url_for_location(lat: float, lng: float, timezone: str) -&gt; str:\n      return f\"https://api.open-meteo.com/v1/forecast?latitude={str(lat)}&amp;longitude={str(lng)}&amp;daily=temperature_2m_max,temperature_2m_min&amp;temperature_unit=fahrenheit&amp;wind_speed_unit=mph&amp;precipitation_unit=inch&amp;timezone={timezone}&amp;forecast_days=1\"\n\n   @staticmethod\n   def _get_loc_url_for_location(self, location_string: str) -&gt; str:\n      return f\"http://api.geonames.org/searchJSON?formatted=true&amp;q={location_string}&amp;maxRows=1&amp;lang=en&amp;username=tealagents&amp;style=full\"\n\n   @kernel_function(\n      description=\"Retrieve low and high temperatures for the day for a given location\"\n   )\n   def get_temperature(\n           self, lat: float, lng: float, timezone: str\n   ) -&gt; TemperatureResponse:\n      url = WeatherPlugin._get_temp_url_for_location(lat, lng, timezone)\n\n      response = requests.get(url).json()\n      if response:\n         response_int: TemperatureResponseInt = TemperatureResponseInt(**response)\n         return TemperatureResponse(\n            low=response_int.daily.temperature_2m_min[0],\n            high=response_int.daily.temperature_2m_max[0],\n         )\n      else:\n         raise ValueError(f\"Error retrieving temperature\")\n\n   @kernel_function(\n      description=\"Retrieve the latitude, longitude, and timezone for a given location search string\"\n   )\n   def get_lat_lng_for_location(self, location_string: str) -&gt; LocationCoordinates:\n      url = WeatherPlugin._get_loc_url_for_location(self, location_string)\n\n      response = requests.get(url).json()\n      if response:\n         response_int: CoordsResponse = CoordsResponse(**response)\n         return LocationCoordinates(\n            latitude=response_int.geonames[0].lat,\n            longitude=response_int.geonames[0].lng,\n            timezone=response_int.geonames[0].timezone.timeZoneId,\n         )\n      else:\n         raise ValueError(f\"Error retrieving location coordinates\")\n</code></pre> <p>Once the custom plugin has been defined, you need to make it available to a configured agent in your agent configuration file. Do this by populating the plugins portion of the agent configuration, which takes a list of defined plugins.</p> <pre><code>...\n    spec:\n      agents:\n        - name: default\n          role: Default Agent\n          model: gpt-4o\n          system_prompt: &gt;\n            You are a helpful assistant.\n          plugins:\n          - WeatherPlugin\n...\n</code></pre> <p>Finally, we need to update our environment to specify the python file which contains the custom plugin.</p> <pre><code>TA_API_KEY=&lt;your-API-key&gt;\nTA_SERVICE_CONFIG=demos/03_plugins/config.yaml\nTA_PLUGIN_MODULE=demos/03_plugins/custom_plugins.py\n</code></pre> <p>And that's all you need to do. In this example, the agent is a chat agent, similar to example 1, but now it has the ability to retrieve the temperature for a specified location.</p> <p></p> <p></p>"},{"location":"demos/04_remote_plugins/","title":"Plugins","text":"<p>Plugins are a concept unique to Semantic Kernel, in the agent framework space. Rather than giving agents access to individual tools, SK introduces the concept of plugins, which can be bundles of similar tools, thus more closely aligning with traditional concepts in software development around the creation of APIs.</p> <p>In the Teal Agent Framework, plugins can be included in two ways:</p> <ol> <li>Local/Custom Plugins</li> <li>OpenAPI API Plugins</li> </ol>"},{"location":"demos/04_remote_plugins/#remote-plugins","title":"Remote Plugins","text":"<p>Remote plugins allow you to re-use existing, published APIs as plugins for your agent without having to write any code. To enable an API as a remote plugin for your agent, two conditions must be met:</p> <ol> <li>The API has a valid OpenAPI Swagger document</li> <li>The API is defined in the Remote Plugin Catalog</li> </ol> <p>Note: At present, the Remote Plugin Catalog is simply a YAML file you will define when creating an agent. In the future, there are plans to manage the available remote plugins via a centralized catalog.</p>"},{"location":"demos/04_remote_plugins/#example","title":"Example","text":"<p>In this example, we'll use two APIs.</p> <ol> <li>An API which, given a location search string, returns a number of    geographical details about the location, including its latitude, longitude,    and timezone.</li> <li>An API which, given a latitude and longitude, returns the high and low    temperatures for the location.</li> </ol> <p>To set up the remote plugin, we've provided the OpenAPI Swagger documents for both APIs in this directory (<code>openapi_weather.json</code> and <code>openapi_geonames.json</code>). Note, the Swagger document locations could also be URLs, rather than local files.</p> <p>Additionally, we've created a <code>remote-plugin-catalog.yaml</code> file which defines the details of the remote APIs.</p> <pre><code>remote_plugins:\n  - plugin_name: api_weather\n    openapi_json_path: ./demos/04_remote_plugins/openapi_weather.json\n    server_url: https://api.open-meteo.com\n  - plugin_name: api_geonames\n    openapi_json_path: ./demos/04_remote_plugins/openapi_geonames.json\n</code></pre> <p>In the configuration file, we reference the remote plugins in the agent section. Note that the remote plugin names are defined in the catalog file.</p> <pre><code>...\nspec:\n  agents:\n    - name: default\n      role: Default Agent\n      model: gpt-4o\n      system_prompt: &gt;\n        You are a helpful assistant.\n      remote_plugins:\n      - api_weather\n      - api_geonames\n...\n</code></pre> <p>Finally, in our environment variables, we provide the path to the local remote plugin catalog.</p> <pre><code>TA_API_KEY=&lt;your-API-key&gt;\nTA_SERVICE_CONFIG=demos/04_remote_plugins/config.yaml\nTA_REMOTE_PLUGIN_PATH=demos/04_remote_plugins/remote-plugin-catalog.yaml\n</code></pre> <p>Now when we run and execute the agent (still using the chat-style input from earlier examples), requesting the temperature for Rahway, we see that the agent leverages both of the remote plugins to satisfy the request, first searching for the location coordinates using the geonames API, and then retrieving temperature using the openmeteo API.</p> <p></p> <p></p>"},{"location":"demos/05_deployment/","title":"Deployment","text":"<p>Agents will be packaged and deployed as docker containers. While this capability is not fully developed, yet, this example will give you an idea of how it might eventually be realized.</p>"},{"location":"demos/05_deployment/#building-the-base-image","title":"Building the base image","text":"<p>Eventually, the base image would be available in Docker Hub, and to get started you'd need to simply pull that image down. Until then, you'll need to first build the base image, locally.  To do so, once you've cloned the repository, locally, build the base image by running the following command from the root.</p> <pre><code>$ git clone https://github.com/MSDLLCpapers/teal-agents.git\n$ cd teal-agents\n$ make teal-agents\n</code></pre> <p></p>"},{"location":"demos/05_deployment/#running-the-agent","title":"Running the agent","text":"<p>To run your agent with the base image, you'll need to make your configuration code files available to a running container and provide it with the appropriate environment variables referencing where you've mounted your files.</p> <p>Note: We'll be running the same example as shown in demo 4, but now we'll be running it within the container.</p> <p>First, set up your environment (.env) file as follows:</p> <pre><code>TA_API_KEY=&lt;your-API-key&gt;\nTA_SERVICE_CONFIG=agents/config.yaml\nTA_PLUGIN_MODULE=agents/custom_plugins.py\nTA_REMOTE_PLUGIN_PATH=agents/remote-plugin-catalog.yaml\n</code></pre> <p>We'll use this file to set the environment for our running container. Note that the path we're specifying to all of our configuration is in the <code>agents</code> folder. That means we'll have to mount all of these files to that location in the container.</p> <p>Also, since we're now moving everything inside the container, we'll need to update the remote plugin catalog (which references the local swagger file).</p> <pre><code>remote_plugins:\n  - plugin_name: api_weather\n    openapi_json_path: ./agents/openapi_weather.json\n    server_url: https://api.open-meteo.com\n</code></pre> <p>For this example, we'll use docker compose to start the agent using the base container. In our <code>compose.yaml</code> file, we expose port 8000, leverage the environment file we previously created, and tell it to mount all of our configuration files in the <code>/app/src/sk-agents/agents</code> directory in the container.</p> <pre><code>services:\n  teal-agents:\n    image: localhost/teal-agents:latest\n    ports:\n      - \"8000:8000\"\n    env_file: \".env\"\n    volumes:\n      - ./agents:/app/src/sk-agents/agents\n</code></pre> <p>Start the container</p> <pre><code>$ docker compose up -d\n</code></pre> <p>The agent will now be running and available on port 8000, just as in demo 4.</p> <p></p> <p></p>"},{"location":"demos/05_deployment/#adding-dependencies","title":"Adding Dependencies","text":"<p>If your agent plugins require additional pip dependencies, simply add a <code>requirements.txt</code> file to your agent directory. When you start the agent, the listed dependencies will be automatically installed in the container and available for your plugins. If your additional dependencies are listed in a file named something other than <code>requirements.txt</code>, you can specify the file name using the environment variable <code>TA_ADDL_REQUIREMENTS</code> (note that this variable must prefix the file name with /src/sk-agents/agents/ as this is where the files are available within the container).</p>"},{"location":"demos/06_deployment_github/","title":"Deployment from Github","text":"<p>For most common use cases, you will not need to work with this repo directly for anything other than debugging if you're writing custom code. Rather, you will store all of your agent configuration, custom_plugins/types.py, and requirements files in an agent-specific folder in a separate Github repository.</p> <p>When the agent starts up with your configuration, the Teal Agents framework will automatically download your agent configuration and start the agent from the existing framework container.</p>"},{"location":"demos/06_deployment_github/#testing-it-out-locally","title":"Testing it out locally","text":"<p>In this demonstration, we'll make use of an existing agent configuration from the shared repository, teal-agents-configs.</p> <p>For reference, the configuration in the shared repo is the same as that found in demo 03_plugins.</p> <p>In order to run this demonstration, you'll need to set up your environment file (<code>.env</code>) to contain the following: <pre><code>TA_API_KEY=&lt;Your API key&gt;\nTA_GITHUB=true\nTA_GH_ORG=teal-agents\nTA_GH_REPO=teal-agents-configs\nTA_GH_BRANCH=main\nTA_AGENT_NAME=ChatWeatherAgent\n</code></pre></p> <ul> <li>TA_API_KEY - Same as for other use cases, enter your appropriate API key</li> <li>TA_GITHUB - Set to true to indicate that your agent configuration resides   in a shared github repository</li> <li>TA_GH_ORG - The github organization that contains the shared agent   configurations</li> <li>TA_GH_REPO - The repository within the organization that contains the shared   agent configurations</li> <li>TA_GH_BRANCH - The branch within the repository that contains the shared   agent configurations</li> <li>TA_AGENT_NAME - The name of the agent configuration folder within the   repository</li> <li>TA_GH_TOKEN (not shown) - A github personal access token with read access to   the repository (if not public)</li> </ul> <p>To run this example, you'll need <code>docker compose</code> installed on your machine. After setting up your environment file, simply run <code>docker compose up -d</code>. The agent will start on port 8000 and can be accessed via http://localhost:8000/docs.</p>"},{"location":"demos/07_task_output/","title":"Multiple, Sequential Tasks","text":"<p>A Sequential Teal Agent allows you to perform multiple tasks, which should be performed in sequence. Each task can have its own agent, or the same agent can be shared by multiple tasks. Additionally, downstream tasks can leverage the output from previous tasks to complete their instructions.</p> <p>Similar to input variables, output from previous tasks can be injected in to the instructions of a given task using the <code>{{}}</code> curly brace syntax. Each task has unique variable name which is simply the name of the previously performed task preceded by a <code>_</code>.</p>"},{"location":"demos/07_task_output/#example","title":"Example","text":"<p>In the following configuration example, we define a single agent that will perform two tasks, in sequence, using the input provided by the consumer.</p> <pre><code>apiVersion: skagents/v1\nkind: Sequential\ndescription: &gt;\n  Add numbers 1 &amp; 2, then multiply the result by number 3 and add 10.\nservice_name: MathAgent\nversion: 0.1\ninput_type: NumbersInput\noutput_type: MathOutput\nspec:\n  agents:\n    - name: default\n      role: Default Agent\n      model: gpt-4o\n      system_prompt: &gt;\n        You are a helpful assistant.\n  tasks:\n    - name: action_task\n      task_no: 1\n      description: Add two numbers\n      instructions: &gt;\n        Add the following two numbers together\n        {{number_1}} {{number_2}}\n      agent: default\n    - name: follow_on_task\n      task_no: 2\n      description: Perform a final operation\n      instructions: &gt;\n        Multiply the result of the previous answer by {{number_3}} and then add\n        10 to it.\n\n        Previous operation:\n        {{_action_task}}\n      agent: default\n</code></pre> <p>NumbersInput is an object containing three fields: <pre><code>class NumbersInput(KernelBaseModel):\n    number_1: int\n    number_2: int\n    number_3: int\n</code></pre></p> <p>In the first task, we simply add <code>number_1</code> and <code>number_2</code> together to get the sum. In the second task, we multiply the result of the <code>action_task</code> by <code>number_3</code> and add 10 to it.</p> <p>Note: The <code>{{_action_task}}</code> variable is used to reference the output of the <code>action_task</code> task. This is a special variable that is automatically created by the Teal Agents Framework when a task is completed. The variable name is simply the name of the task, preceded by an underscore.</p> <p>Additional Note: The input to a downstream task that is a result from a previous task will be the agent's raw response. Take care to phrase the follow -on task's instructions in a way that the agent can understand the context.</p>"},{"location":"demos/08_multi_modal/","title":"Multi-Modal Input","text":"<p>In addition to text prompts, agents can work with multi-modal input (currently limited to images, but more are planned). There are two ways to leverage image input in an agent:</p>"},{"location":"demos/08_multi_modal/#basemultimodalinput","title":"BaseMultiModalInput","text":"<p>If you set the <code>input_type</code> to <code>BaseMultiModalInput</code>, the agent will expect a chat history that can include images as items in a user message.</p> <pre><code>apiVersion: skagents/v1\nkind: Sequential\ndescription: &gt;\n  A simple chat agent\nservice_name: ChatBot\nversion: 0.1\ninput_type: BaseMultiModalInput\nspec:\n  agents:\n    - name: default\n      role: Default Agent\n      model: gpt-4o\n      system_prompt: &gt;\n        You are a helpful assistant.\n  tasks:\n    - name: action_task\n      task_no: 1\n      description: Chat with user\n      instructions: &gt;\n        Work with the user to assist them in whatever they need.\n      agent: default\n</code></pre> <p>The <code>items</code> key within the request payload can now include both text and images. The <code>content_type</code> key specifies the type of item and <code>content</code> contains the actual content. <pre><code>{\n  \"chat_history\": [\n    {\n      \"role\": \"user\",\n      \"items\": [\n        {\n          \"content_type\": \"text or image\",\n          \"content\": \"content\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre> When specifying an image, it must be base64-encoded, and prefixed with <code>data:image/jpeg;base64,</code> (substituting the appropriate format).  For example, to have the agent count the number of buttons, in this image:</p> <p></p> <p>Our request payload would look like: <pre><code>{\n  \"chat_history\": [\n    {\n      \"role\": \"user\",\n      \"items\": [\n        {\n          \"content_type\": \"text\",\n          \"content\": \"How many buttons are in this image\"\n        },\n        {\n          \"content_type\": \"image\",\n          \"content\": \"data:image/jpeg;base64,/9j/4QF...\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre></p> <p>Note: To simplify testing of this demo, the example request payload is stored in request_payload.json.</p>"},{"location":"demos/08_multi_modal/#result","title":"Result","text":""},{"location":"demos/08_multi_modal/#embedded-image","title":"Embedded Image","text":"<p>An alternative method of including images for your agent to process would be to define a custom input type that includes a field called <code>embedded_image</code> whose structure matches:</p> <pre><code>{\n  ...\n  \"embedded_image\": {\n    \"format\": \"image/jpeg\",\n    \"content\": \"/9j/4QF...\"\n  }\n}\n</code></pre> <p>When including images in this way, the image will be sent along with your first task's instructions.</p>"},{"location":"demos/08_multi_modal/#example","title":"Example","text":"<p>Define a custom input type: <pre><code>from semantic_kernel.kernel_pydantic import KernelBaseModel\n\nfrom sk_agents.ska_types import EmbeddedImage\n\n\nclass ButtonGuess(KernelBaseModel):\n    guess: int\n    embedded_image: EmbeddedImage\n</code></pre></p> <p>And your agent configuration looked like this: <pre><code>apiVersion: skagents/v1\nkind: Sequential\ndescription: &gt;\n  A simple chat agent\nservice_name: ChatBot\nversion: 0.1\ninput_type: ButtonGuess\nspec:\n  agents:\n    - name: default\n      role: Default Agent\n      model: gpt-4o\n      system_prompt: &gt;\n        You are a helpful assistant.\n  tasks:\n    - name: action_task\n      task_no: 1\n      description: Chat with user\n      instructions: &gt;\n        Does the image contain {{guess}} buttons?\n      agent: default\n</code></pre></p> <p>You could send a payload that looked like this: <pre><code>{\n  \"guess\": 10,\n  \"embedded_image\": {\n    \"format\": \"image/jpeg\",\n    \"data\": \"/9j/4Q...\"\n  }\n}\n</code></pre></p> <p>The image in the payload would be detected and sent along with the user message \"Does the image contain 10 buttons?\". Your response would look something like: <pre><code>{\n  \"token_usage\": {\n    \"completion_tokens\": 9,\n    \"prompt_tokens\": 235,\n    \"total_tokens\": 244\n  },\n  \"extra_data\": null,\n  \"output_raw\": \"No, the image contains 12 buttons.\",\n  \"output_pydantic\": null\n}\n</code></pre></p>"},{"location":"demos/09_chat_simple/","title":"Chat-Only Agent","text":"<p>In addition to Sequential agents, there is also a chat-only type agent. The difference between the two is that, with chat-only, there are no tasks in which additional instructions can be provided. Rather, a chat-only agent expects input of one of the following types: * <code>BaseInput</code> - A simple text input * <code>BaseInputWithUserContext</code> - A text input with user context * <code>BaseMultiModalInput</code> - Input supporting both images and text</p> <p>A chat-only agent will use the chat history that's provided and attempt to perform any requested actions.</p>"},{"location":"demos/09_chat_simple/#example-configuration","title":"Example Configuration","text":"<pre><code>apiVersion: skagents/v1\nkind: Chat\ndescription: &gt;\n  A simple chat agent\nservice_name: ChatBot\nversion: 0.1\ninput_type: BaseInput\nspec:\n  agent:\n    name: default\n    role: Default Agent\n    model: gpt-4o-mini\n    system_prompt: &gt;\n      You are a helpful assistant.\n</code></pre>"},{"location":"demos/10_chat_plugins/","title":"Chat-Only Agents with PlugIns","text":"<p>Chat-only agents do support the same plug-in architecture as sequential agents.</p>"},{"location":"demos/10_chat_plugins/#example-configuration","title":"Example Configuration","text":"<pre><code>apiVersion: skagents/v1\nkind: Chat\ndescription: &gt;\n  A weather chat agent\nservice_name: WeatherBot\nversion: 0.1\ninput_type: BaseInputWithUserContext\nspec:\n  agent:\n    name: default\n    role: Default Agent\n    model: gpt-4o\n    system_prompt: &gt;\n      You are a helpful assistant.\n    plugins:\n    - WeatherPlugin\n</code></pre>"},{"location":"demos/10_chat_plugins/#example-custom-plugin","title":"Example Custom Plugin","text":"<pre><code>import requests\nfrom pydantic import BaseModel, ConfigDict\nfrom semantic_kernel.functions.kernel_function_decorator import kernel_function\n\nfrom sk_agents.ska_types import BasePlugin\n\n\nclass LocationCoordinates(BaseModel):\n    latitude: float\n    longitude: float\n    timezone: str\n\n\nclass DailyUnits(BaseModel):\n    time: str\n    temperature_2m_max: str\n    temperature_2m_min: str\n\n\nclass Daily(BaseModel):\n    time: list[str]\n    temperature_2m_max: list[float]\n    temperature_2m_min: list[float]\n\n\nclass TemperatureResponseInt(BaseModel):\n    latitude: float\n    longitude: float\n    generationtime_ms: float\n    utc_offset_seconds: int\n    timezone: str\n    timezone_abbreviation: str\n    elevation: int\n    daily_units: DailyUnits\n    daily: Daily\n\n\nclass TemperatureResponse(BaseModel):\n    low: float\n    high: float\n\n\nclass TimeZone(BaseModel):\n    model_config = ConfigDict(extra=\"allow\")\n    timeZoneId: str\n\n\nclass GeoName(BaseModel):\n    model_config = ConfigDict(extra=\"allow\")\n    timezone: TimeZone\n    lat: float\n    lng: float\n\n\nclass CoordsResponse(BaseModel):\n    model_config = ConfigDict(extra=\"allow\")\n    geonames: list[GeoName]\n\n\nclass WeatherPlugin(BasePlugin):\n    @staticmethod\n    def _get_temp_url_for_location(lat: float, lng: float, timezone: str) -&gt; str:\n        return f\"https://api.open-meteo.com/v1/forecast?latitude={str(lat)}&amp;longitude={str(lng)}&amp;daily=temperature_2m_max,temperature_2m_min&amp;temperature_unit=fahrenheit&amp;wind_speed_unit=mph&amp;precipitation_unit=inch&amp;timezone={timezone}&amp;forecast_days=1\"\n\n    @staticmethod\n    def _get_loc_url_for_location(self, location_string: str) -&gt; str:\n        return f\"http://api.geonames.org/searchJSON?formatted=true&amp;q={location_string}&amp;maxRows=1&amp;lang=en&amp;username=tealagents&amp;style=full\"\n\n    @kernel_function(\n        description=\"Retrieve low and high temperatures for the day for a given location\"\n    )\n    def get_temperature(self, lat: float, lng: float, timezone: str) -&gt; TemperatureResponse:\n        url = WeatherPlugin._get_temp_url_for_location(lat, lng, timezone)\n\n        response = requests.get(url).json()\n        if response:\n            response_int: TemperatureResponseInt = TemperatureResponseInt(**response)\n            return TemperatureResponse(\n                low=response_int.daily.temperature_2m_min[0],\n                high=response_int.daily.temperature_2m_max[0],\n            )\n        else:\n            raise ValueError(\"Error retrieving temperature\")\n\n    @kernel_function(\n        description=\"Retrieve the latitude, longitude, and timezone \\\n            for a given location search string\"\n    )\n    def get_lat_lng_for_location(self, location_string: str) -&gt; LocationCoordinates:\n        url = WeatherPlugin._get_loc_url_for_location(self, location_string)\n\n        response = requests.get(url).json()\n        if response:\n            response_int: CoordsResponse = CoordsResponse(**response)\n            return LocationCoordinates(\n                latitude=response_int.geonames[0].lat,\n                longitude=response_int.geonames[0].lng,\n                timezone=response_int.geonames[0].timezone.timeZoneId,\n            )\n        else:\n            raise ValueError(\"Error retrieving location coordinates\")\n</code></pre>"},{"location":"demos/11_hitl/","title":"Human-in-the-Loop (HITL) Agent Demo","text":"<p>This demo showcases how to configure an agent with Human-in-the-Loop (HITL) capabilities, which allows you to require human approval before sensitive or high-risk plugin functions are executed by the AI agent.</p>"},{"location":"demos/11_hitl/#overview","title":"Overview","text":"<p>Human-in-the-Loop is a critical security and governance feature that enables:</p> <ul> <li>Risk Mitigation: Prevent potentially dangerous operations from executing without human oversight</li> <li>Compliance: Meet regulatory requirements for human approval on sensitive data operations</li> <li>Security: Add a safety layer between AI decision-making and critical actions</li> <li>Auditability: Track and approve all high-risk operations with full traceability</li> </ul>"},{"location":"demos/11_hitl/#how-hitl-works","title":"How HITL Works","text":"<ol> <li>Agent Execution: The agent processes a user request and determines it needs to call a plugin function</li> <li>Governance Check: The framework checks the plugin catalog to see if the function requires HITL approval</li> <li>Execution Pause: If HITL is required, execution halts and returns an <code>HitlResponse</code> with approval URLs</li> <li>Human Review: A human reviewer examines the function call details and either approves or rejects it</li> <li>Execution Resume: If approved, the agent resumes and executes the function; if rejected, the agent is notified</li> </ol>"},{"location":"demos/11_hitl/#configuration-components","title":"Configuration Components","text":""},{"location":"demos/11_hitl/#1-agent-configuration-configyaml","title":"1. Agent Configuration (<code>config.yaml</code>)","text":"<p>The agent configuration defines the agent's behavior and which plugins it has access to:</p> <pre><code>apiVersion: tealagents/v1alpha1\nkind: Chat\ndescription: &gt;\n  A simple Hello World agent that greets users with their user ID from the user context\nname: MathAgent\nversion: 0.1\nspec:\n  agent:\n    name: default\n    role: MathAgent\n    model: gpt-4o-2024-05-13\n    system_prompt: &gt;\n        Your task is to provide a help with Math problems, and invoke the plugin\n        when you finish the math problem before responding\n    plugins:\n        - sensitive_plugin\n</code></pre> <p>Key Elements: - <code>apiVersion</code>: Uses <code>tealagents/v1alpha1</code> which supports HITL features - <code>kind</code>: Set to <code>Chat</code> for conversational agents - <code>plugins</code>: Lists the plugins available to the agent (in this case, <code>sensitive_plugin</code>) - <code>system_prompt</code>: Instructs the agent when to use the plugin</p>"},{"location":"demos/11_hitl/#2-custom-plugin-implementation-custom_pluginspy","title":"2. Custom Plugin Implementation (<code>custom_plugins.py</code>)","text":"<p>Define your plugin with functions that may require human oversight:</p> <pre><code>from semantic_kernel.functions.kernel_function_decorator import kernel_function\nfrom sk_agents.ska_types import BasePlugin\n\n\nclass sensitive_plugin(BasePlugin):\n    @kernel_function(description=\"invoke when a math problem is solved\")\n    def delete_user_data(self):\n        return \"you shouldnt see me\"\n</code></pre> <p>Key Elements: - Inherit from <code>BasePlugin</code>: Ensures proper integration with the framework - <code>@kernel_function</code> decorator: Marks methods as callable by the agent - Function description: Tells the agent when to invoke this function - Function logic: The actual operation that will execute after approval</p>"},{"location":"demos/11_hitl/#3-plugin-catalog-configuration-catalogjson","title":"3. Plugin Catalog Configuration (<code>catalog.json</code>)","text":"<p>The plugin catalog is where you define governance rules, including HITL requirements:</p> <pre><code>{\n  \"plugins\": [\n    {\n      \"plugin_id\": \"sensitive_plugin\",\n      \"name\": \"sensitive_plugin\",\n      \"description\": \"Executes shell commands.\",\n      \"version\": \"1.0\",\n      \"owner\": \"system\",\n      \"plugin_type\": { \"type_name\": \"code\" },\n      \"tools\": [\n        {\n          \"tool_id\": \"sensitive_plugin-delete_user_data\",\n          \"name\": \"delete_user_data\",\n          \"description\": \"Executes a command in the shell to delete user.\",\n          \"governance\": {\n            \"requires_hitl\": true,\n            \"cost\": \"high\",\n            \"data_sensitivity\": \"sensitive\"\n          },\n          \"auth\": null\n        }\n      ]\n    }\n  ]\n}\n</code></pre> <p>Key Elements: - <code>plugin_id</code>: Must match the plugin class name in your <code>custom_plugins.py</code> - <code>tool_id</code>: Format is <code>{plugin_id}-{function_name}</code> (e.g., <code>sensitive_plugin-delete_user_data</code>) - <code>governance</code>: Defines the governance controls for this tool   - <code>requires_hitl: true</code>: Enables human-in-the-loop for this function   - <code>cost</code>: Resource classification (<code>low</code>, <code>medium</code>, <code>high</code>)   - <code>data_sensitivity</code>: Sensitivity level (<code>public</code>, <code>proprietary</code>, <code>confidential</code>, <code>sensitive</code>) - <code>auth</code>: Optional authentication requirements (null in this example)</p>"},{"location":"demos/11_hitl/#environment-configuration","title":"Environment Configuration","text":"<p>To run this demo, you need to configure the following environment variables:</p> <pre><code># API Key for LLM access\nTA_API_KEY=&lt;your-API-key&gt;\n\n# Path to your agent configuration\nTA_SERVICE_CONFIG=demos/11_hitl/config.yaml\n\n# Path to your custom plugin implementation\nTA_PLUGIN_MODULE=demos/11_hitl/custom_plugins.py\n\n# Path to the plugin catalog (defines HITL governance)\nTA_PLUGIN_CATALOG_MODULE=src/sk_agents/plugin_catalog/local_plugin_catalog.py\nTA_PLUGIN_CATALOG_CLASS=FileBasedPluginCatalog\nTA_PLUGIN_CATALOG_PATH=src/sk_agents/plugin_catalog/catalog.json\n</code></pre> <p>Important Notes: - The <code>TA_PLUGIN_CATALOG_PATH</code> should point to your <code>catalog.json</code> file - You can create custom catalog implementations by extending the <code>PluginCatalog</code> abstract class - The catalog is loaded as a singleton, so all agents in the application share the same governance rules</p>"},{"location":"demos/11_hitl/#hitl-workflow-example","title":"HITL Workflow Example","text":""},{"location":"demos/11_hitl/#step-1-initial-request","title":"Step 1: Initial Request","text":"<p>User sends a request to the agent:</p> <pre><code>POST /MathAgent/0.1\n{\n  \"user_id\": \"user123\",\n  \"input\": \"What is 5 + 3? After you solve it, delete my data.\"\n}\n</code></pre>"},{"location":"demos/11_hitl/#step-2-agent-processing","title":"Step 2: Agent Processing","text":"<p>The agent: 1. Solves the math problem (5 + 3 = 8) 2. Determines it needs to call <code>delete_user_data</code> 3. Checks the plugin catalog and finds <code>requires_hitl: true</code> 4. Raises an <code>HitlInterventionRequired</code> exception</p>"},{"location":"demos/11_hitl/#step-3-hitl-response","title":"Step 3: HITL Response","text":"<p>The framework returns a <code>HitlResponse</code> instead of executing the function:</p> <pre><code>{\n  \"task_id\": \"task_abc123\",\n  \"session_id\": \"session_xyz789\",\n  \"request_id\": \"req_def456\",\n  \"human_message\": \"HITL intervention required for sensitive_plugin.delete_user_data\",\n  \"tool_calls\": [\n    {\n      \"plugin_name\": \"sensitive_plugin\",\n      \"function_name\": \"delete_user_data\",\n      \"arguments\": {}\n    }\n  ],\n  \"approval_url\": \"/approve/req_def456\",\n  \"rejection_url\": \"/reject/req_def456\"\n}\n</code></pre>"},{"location":"demos/11_hitl/#step-4-human-review","title":"Step 4: Human Review","text":"<p>A human reviewer examines the function call details and makes a decision.</p> <p>To Approve: <pre><code>POST /approve/req_def456\n{\n  \"action\": \"approved\",\n  \"reason\": \"User requested data deletion, verified identity\"\n}\n</code></pre></p> <p>To Reject: <pre><code>POST /reject/req_def456\n{\n  \"action\": \"rejected\",\n  \"reason\": \"Insufficient verification\"\n}\n</code></pre></p>"},{"location":"demos/11_hitl/#step-5-resume-execution","title":"Step 5: Resume Execution","text":"<p>After approval/rejection, use the resume endpoint:</p> <pre><code>POST /resume/req_def456\n{\n  \"action_status\": \"approved\"  # or \"rejected\"\n}\n</code></pre> <p>If approved, the agent executes <code>delete_user_data</code> and completes the response. If rejected, the agent is informed the action was not allowed and responds accordingly.</p>"},{"location":"demos/11_hitl/#governance-options","title":"Governance Options","text":"<p>The <code>governance</code> object in the plugin catalog supports multiple control mechanisms:</p>"},{"location":"demos/11_hitl/#hitl-requirement","title":"HITL Requirement","text":"<pre><code>\"governance\": {\n  \"requires_hitl\": true  // Set to false to allow automatic execution\n}\n</code></pre>"},{"location":"demos/11_hitl/#cost-classification","title":"Cost Classification","text":"<p>Used for resource tracking and budgeting: <pre><code>\"governance\": {\n  \"cost\": \"high\"  // Options: \"low\", \"medium\", \"high\"\n}\n</code></pre></p>"},{"location":"demos/11_hitl/#data-sensitivity","title":"Data Sensitivity","text":"<p>Used for data governance and compliance: <pre><code>\"governance\": {\n  \"data_sensitivity\": \"sensitive\"\n  // Options: \"public\", \"proprietary\", \"confidential\", \"sensitive\"\n}\n</code></pre></p>"},{"location":"demos/11_hitl/#common-use-cases","title":"Common Use Cases","text":""},{"location":"demos/11_hitl/#1-financial-transactions","title":"1. Financial Transactions","text":"<pre><code>{\n  \"tool_id\": \"finance_plugin-initiate_transfer\",\n  \"governance\": {\n    \"requires_hitl\": true,\n    \"cost\": \"high\",\n    \"data_sensitivity\": \"sensitive\"\n  }\n}\n</code></pre>"},{"location":"demos/11_hitl/#2-system-administration","title":"2. System Administration","text":"<pre><code>{\n  \"tool_id\": \"admin_tools-shutdown_service\",\n  \"governance\": {\n    \"requires_hitl\": true,\n    \"cost\": \"high\",\n    \"data_sensitivity\": \"confidential\"\n  }\n}\n</code></pre>"},{"location":"demos/11_hitl/#3-data-deletion","title":"3. Data Deletion","text":"<pre><code>{\n  \"tool_id\": \"sensitive_plugin-delete_user_data\",\n  \"governance\": {\n    \"requires_hitl\": true,\n    \"cost\": \"medium\",\n    \"data_sensitivity\": \"sensitive\"\n  }\n}\n</code></pre>"},{"location":"demos/11_hitl/#4-low-risk-operations","title":"4. Low-Risk Operations","text":"<pre><code>{\n  \"tool_id\": \"finance_plugin-get_balance\",\n  \"governance\": {\n    \"requires_hitl\": false,  // No human approval needed\n    \"cost\": \"low\",\n    \"data_sensitivity\": \"proprietary\"\n  }\n}\n</code></pre>"},{"location":"demos/11_hitl/#best-practices","title":"Best Practices","text":""},{"location":"demos/11_hitl/#1-plugin-naming-conventions","title":"1. Plugin Naming Conventions","text":"<ul> <li>Use descriptive plugin IDs that indicate their purpose</li> <li>Keep function names clear and action-oriented</li> <li>Tool IDs must follow the format: <code>{plugin_id}-{function_name}</code></li> </ul>"},{"location":"demos/11_hitl/#2-governance-configuration","title":"2. Governance Configuration","text":"<ul> <li>Mark all destructive operations as <code>requires_hitl: true</code></li> <li>Set appropriate cost and sensitivity levels</li> <li>Document governance decisions in plugin descriptions</li> </ul>"},{"location":"demos/11_hitl/#3-system-prompts","title":"3. System Prompts","text":"<ul> <li>Clearly instruct the agent when to use HITL-protected functions</li> <li>Provide context about why certain operations require approval</li> <li>Set expectations for users about approval workflows</li> </ul>"},{"location":"demos/11_hitl/#4-error-handling","title":"4. Error Handling","text":"<ul> <li>Always handle HITL responses in your client application</li> <li>Provide clear UI for approval/rejection workflows</li> <li>Implement timeout handling for pending approvals</li> </ul>"},{"location":"demos/11_hitl/#5-audit-trail","title":"5. Audit Trail","text":"<ul> <li>Log all HITL intervention requests</li> <li>Track approval/rejection decisions with timestamps and reasons</li> <li>Maintain records for compliance requirements</li> </ul>"},{"location":"demos/11_hitl/#architecture-integration","title":"Architecture Integration","text":"<p>The HITL system integrates with several framework components:</p> <ol> <li>Plugin Catalog (Singleton): Centralized governance rules</li> <li>HITL Manager: Checks for intervention requirements</li> <li>Agent Handler: Catches HITL exceptions and generates responses</li> <li>Persistence Layer: Tracks task state during approval workflows</li> <li>REST API: Provides approval/rejection endpoints</li> </ol>"},{"location":"demos/11_hitl/#troubleshooting","title":"Troubleshooting","text":""},{"location":"demos/11_hitl/#hitl-not-triggering","title":"HITL Not Triggering","text":"<p>Problem: Function executes without requiring approval</p> <p>Solutions: - Verify <code>requires_hitl: true</code> is set in <code>catalog.json</code> - Confirm <code>tool_id</code> matches the format: <code>{plugin_id}-{function_name}</code> - Check that <code>TA_PLUGIN_CATALOG_PATH</code> points to the correct catalog file - Ensure the plugin catalog is properly loaded (check logs)</p>"},{"location":"demos/11_hitl/#tool-not-found-in-catalog","title":"Tool Not Found in Catalog","text":"<p>Problem: Tool is not recognized by the catalog</p> <p>Solutions: - Verify the <code>plugin_id</code> matches your plugin class name - Check the <code>tool_id</code> format is correct - Ensure the catalog JSON is valid (use a JSON validator) - Restart the service after updating the catalog</p>"},{"location":"demos/11_hitl/#approval-urls-not-working","title":"Approval URLs Not Working","text":"<p>Problem: Approval/rejection endpoints return errors</p> <p>Solutions: - Confirm the request ID is valid and not expired - Check that persistence is configured correctly - Verify the resume endpoint is being called properly - Review service logs for detailed error messages</p>"},{"location":"demos/11_hitl/#further-reading","title":"Further Reading","text":"<ul> <li>HITL System Documentation</li> <li>Plugin Catalog Documentation</li> <li>Persistence Management</li> <li>Authorization &amp; Auth Storage</li> </ul>"},{"location":"hitl/auth_storage/","title":"Authentication Storage System","text":"<p>This document describes the authentication storage system for the Teal Agents framework.</p>"},{"location":"hitl/auth_storage/#overview","title":"Overview","text":"<p>The authentication storage system securely stores OAuth 2.0 and other authentication credentials. It provides:</p> <ul> <li>In-Memory Storage (default): Zero configuration, perfect for development</li> <li>Redis Storage (optional): Persistent, scalable, production-ready</li> <li>Custom Storage: Support for user-defined implementations</li> </ul>"},{"location":"hitl/auth_storage/#configuration","title":"Configuration","text":""},{"location":"hitl/auth_storage/#environment-variables","title":"Environment Variables","text":"<ul> <li><code>TA_AUTH_STORAGE_MANAGER_MODULE</code>: Path to custom auth storage module</li> <li><code>TA_AUTH_STORAGE_MANAGER_CLASS</code>: Class name for custom implementation</li> </ul>"},{"location":"hitl/auth_storage/#examples","title":"Examples","text":""},{"location":"hitl/auth_storage/#development-default","title":"Development (Default)","text":"<pre><code># No configuration needed - uses in-memory storage\n</code></pre>"},{"location":"hitl/auth_storage/#production-with-redis","title":"Production with Redis","text":"<pre><code>export TA_AUTH_STORAGE_MANAGER_MODULE=src/sk_agents/auth_storage/custom/example_redis_auth_storage.py\nexport TA_AUTH_STORAGE_MANAGER_CLASS=RedisSecureAuthStorageManager\nexport TA_REDIS_HOST=redis.production.com\nexport TA_REDIS_PORT=6379\nexport TA_REDIS_PWD=secure_password\n</code></pre>"},{"location":"hitl/auth_storage/#usage","title":"Usage","text":"<pre><code>from ska_utils import AppConfig\nfrom sk_agents.auth_storage.auth_storage_factory import AuthStorageFactory\nfrom sk_agents.auth_storage.models import OAuth2AuthData\n\n# Get auth storage manager\napp_config = AppConfig()\nfactory = AuthStorageFactory(app_config)\nauth_storage = factory.get_auth_storage_manager()\n\n# Store, retrieve, and delete auth data\nauth_storage.store(\"user123\", \"tool_a\", auth_data)\nretrieved_data = auth_storage.retrieve(\"user123\", \"tool_a\")\nauth_storage.delete(\"user123\", \"tool_a\")\n</code></pre>"},{"location":"hitl/auth_storage/#custom-implementation","title":"Custom Implementation","text":"<p>Create custom storage by extending <code>SecureAuthStorageManager</code>:</p> <pre><code>from sk_agents.auth_storage.secure_auth_storage_manager import SecureAuthStorageManager\n\nclass MyCustomAuthStorageManager(SecureAuthStorageManager):\n    def store(self, user_id: str, key: str, data: AuthData) -&gt; None:\n        # Your implementation\n        pass\n\n    def retrieve(self, user_id: str, key: str) -&gt; AuthData | None:\n        # Your implementation\n        return None\n\n    def delete(self, user_id: str, key: str) -&gt; None:\n        # Your implementation\n        pass\n</code></pre>"},{"location":"hitl/authorization/","title":"Authorization Module","text":"<p>This module provides a flexible authorization system for the SK Agents framework. It implements a factory pattern to dynamically load and manage request authorization mechanisms, with support for pluggable authorization strategies.</p>"},{"location":"hitl/authorization/#architecture-overview","title":"Architecture Overview","text":"<p>The authorization module follows a factory pattern with an abstract base class that defines the authorization interface. This design allows for easy extension and customization of authorization mechanisms while maintaining a consistent API.</p>"},{"location":"hitl/authorization/#files-and-classes","title":"Files and Classes","text":""},{"location":"hitl/authorization/#__init__py","title":"<code>__init__.py</code>","text":"<p>Empty initialization file that marks this directory as a Python package.</p>"},{"location":"hitl/authorization/#request_authorizerpy","title":"<code>request_authorizer.py</code>","text":""},{"location":"hitl/authorization/#requestauthorizer-abstract-base-class","title":"<code>RequestAuthorizer</code> (Abstract Base Class)","text":"<p>An abstract base class that defines the contract for all authorization implementations.</p> <p>Purpose: Provides a standardized interface for authorization mechanisms across the application.</p> <p>Key Method:</p> <ul> <li><code>authorize_request(auth_header: str) -&gt; str</code>: Abstract method that validates an authorization header and returns a unique user identifier.</li> </ul> <p>Parameters:</p> <ul> <li><code>auth_header</code>: The value of the 'Authorization' HTTP header (typically \"Bearer token\" format)</li> </ul> <p>Returns:</p> <ul> <li>A unique string identifier for the authenticated user (e.g., user ID, username, email)</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: For missing, malformed, or invalid authorization headers</li> <li><code>AuthenticationError</code>: (Optional) For authentication failures in implementations</li> </ul> <p>Usage: All custom authorization implementations must inherit from this class and implement the <code>authorize_request</code> method.</p>"},{"location":"hitl/authorization/#dummy_authorizerpy","title":"<code>dummy_authorizer.py</code>","text":""},{"location":"hitl/authorization/#dummyauthorizer-concrete-implementation","title":"<code>DummyAuthorizer</code> (Concrete Implementation)","text":"<p>A simple test/development implementation of the <code>RequestAuthorizer</code> interface.</p> <p>Purpose: Provides a no-op authorization mechanism for development, testing, or scenarios where authentication is not required.</p> <p>Behavior:</p> <ul> <li>Always returns \"dummyuser\" regardless of the input authorization header</li> <li>Does not perform any actual validation or authentication</li> <li>Useful for development environments or testing scenarios</li> </ul> <p>Implementation:</p> <pre><code>async def authorize_request(self, auth_header: str) -&gt; str:\n    return \"dummyuser\"\n</code></pre> <p>Use Cases:</p> <ul> <li>Local development without authentication setup</li> <li>Testing environments</li> <li>Placeholder implementation during development</li> </ul>"},{"location":"hitl/authorization/#singletonpy","title":"<code>singleton.py</code>","text":""},{"location":"hitl/authorization/#singleton-metaclass","title":"<code>Singleton</code> (Metaclass)","text":"<p>A thread-safe implementation of the Singleton design pattern using a metaclass.</p> <p>Purpose: Ensures that only one instance of a class exists throughout the application lifecycle while being thread-safe.</p> <p>Features:</p> <ul> <li>Thread Safety: Uses <code>threading.Lock()</code> to prevent race conditions in multi-threaded environments</li> <li>Instance Management: Maintains a dictionary of class instances (<code>_instances</code>)</li> <li>Metaclass Implementation: Implemented as a metaclass (<code>ABCMeta</code> subclass) for clean integration</li> </ul> <p>Key Components:</p> <ul> <li><code>_instances</code>: Class-level dictionary storing singleton instances</li> <li><code>_lock</code>: Threading lock for thread-safe instance creation</li> <li><code>__call__</code>: Overridden method that controls instance creation</li> </ul> <p>Usage: Classes that need singleton behavior inherit this as their metaclass:</p> <pre><code>class MyClass(metaclass=Singleton):\n    pass\n</code></pre> <p>Thread Safety: The implementation ensures that even in multi-threaded environments, only one instance of each class is created.</p>"},{"location":"hitl/authorization/#authorizer_factorypy","title":"<code>authorizer_factory.py</code>","text":""},{"location":"hitl/authorization/#authorizerfactory-singleton-factory","title":"<code>AuthorizerFactory</code> (Singleton Factory)","text":"<p>A factory class that dynamically loads and creates authorization implementations based on configuration.</p> <p>Purpose: Provides a centralized way to create and manage authorization instances while supporting dynamic loading of custom authorization implementations.</p> <p>Design Pattern: Factory pattern combined with Singleton pattern for application-wide consistency.</p> <p>Key Features:</p> <ul> <li>Dynamic Loading: Loads authorization classes from modules specified by file paths in configuration</li> <li>Type Safety: Validates that loaded classes are proper <code>RequestAuthorizer</code> subclasses</li> <li>Configuration-Driven: Uses environment variables to determine which authorization implementation to use</li> <li>Singleton: Ensures consistent authorization behavior across the application</li> </ul> <p>Constructor Parameters:</p> <ul> <li><code>app_config</code>: An <code>AppConfig</code> instance containing application configuration</li> </ul> <p>Key Methods:</p>"},{"location":"hitl/authorization/#get_authorizer-requestauthorizer","title":"<code>get_authorizer() -&gt; RequestAuthorizer</code>","text":"<p>Returns an instance of the configured authorization class.</p> <p>Returns: A configured <code>RequestAuthorizer</code> implementation</p>"},{"location":"hitl/authorization/#_get_authorizer_config-tuplestr-str-private","title":"<code>_get_authorizer_config() -&gt; tuple[str, str]</code> (Private)","text":"<p>Retrieves the module and class names from configuration.</p> <p>Returns: Tuple containing (module_name, class_name)</p> <p>Raises:</p> <ul> <li><code>ValueError</code>: If required environment variables are not set</li> </ul> <p>Configuration Requirements:</p> <ul> <li><code>TA_AUTHORIZER_MODULE</code>: Environment variable specifying the file path to the module containing the authorization class (e.g., <code>src/sk_agents/authorization/dummy_authorizer.py</code>)</li> <li><code>TA_AUTHORIZER_CLASS</code>: Environment variable specifying the authorization class name</li> </ul> <p>Error Handling:</p> <ul> <li><code>ImportError</code>: Raised if the specified module cannot be loaded or the class is not found</li> <li><code>TypeError</code>: Raised if the loaded class is not a subclass of <code>RequestAuthorizer</code></li> <li><code>ValueError</code>: Raised if required configuration is missing</li> </ul> <p>Usage Example:</p> <pre><code># Configuration (environment variables)\nTA_AUTHORIZER_MODULE = \"src/sk_agents/authorization/dummy_authorizer.py\"\nTA_AUTHORIZER_CLASS = \"DummyAuthorizer\"\n\n# Usage\nfactory = AuthorizerFactory(app_config)\nauthorizer = factory.get_authorizer()\nuser_id = await authorizer.authorize_request(\"Bearer token123\")\n</code></pre>"},{"location":"hitl/authorization/#configuration","title":"Configuration","text":"<p>The authorization system is configured through environment variables:</p> <ul> <li><code>TA_AUTHORIZER_MODULE</code>: Specifies the file path to the Python module containing the authorization implementation (e.g., <code>src/sk_agents/authorization/dummy_authorizer.py</code>)</li> <li><code>TA_AUTHORIZER_CLASS</code>: Specifies the class name within the module that implements authorization</li> </ul>"},{"location":"hitl/authorization/#usage-patterns","title":"Usage Patterns","text":""},{"location":"hitl/authorization/#1-using-the-default-dummy-authorization","title":"1. Using the Default (Dummy) Authorization","text":"<pre><code># Set environment variables\nTA_AUTHORIZER_MODULE = \"src/sk_agents/authorization/dummy_authorizer.py\"\nTA_AUTHORIZER_CLASS = \"DummyAuthorizer\"\n\n# Create factory and get authorizer\nfactory = AuthorizerFactory(app_config)\nauthorizer = factory.get_authorizer()\n</code></pre>"},{"location":"hitl/authorization/#2-implementing-custom-authorization","title":"2. Implementing Custom Authorization","text":"<pre><code># Create custom authorizer\nclass MyCustomAuthorizer(RequestAuthorizer):\n    async def authorize_request(self, auth_header: str) -&gt; str:\n        # Custom validation logic\n        if not auth_header.startswith(\"Bearer \"):\n            raise ValueError(\"Invalid authorization header format\")\n\n        token = auth_header[7:]  # Remove \"Bearer \" prefix\n        # Validate token and return user ID\n        return validate_and_extract_user_id(token)\n\n# Configure to use custom authorizer\nTA_AUTHORIZER_MODULE = \"my_module/custom_auth.py\"\nTA_AUTHORIZER_CLASS = \"MyCustomAuthorizer\"\n</code></pre>"},{"location":"hitl/authorization/#3-integration-in-web-applications","title":"3. Integration in Web Applications","text":"<pre><code># In request handlers\nasync def protected_endpoint(request):\n    auth_header = request.headers.get(\"Authorization\")\n    if not auth_header:\n        raise ValueError(\"Authorization header required\")\n\n    factory = AuthorizerFactory(app_config)\n    authorizer = factory.get_authorizer()\n    user_id = await authorizer.authorize_request(auth_header)\n\n    # Proceed with authorized request\n    return handle_request_for_user(user_id)\n</code></pre>"},{"location":"hitl/authorization/#design-benefits","title":"Design Benefits","text":"<ol> <li>Flexibility: Easy to swap authorization mechanisms without code changes</li> <li>Extensibility: Simple to add new authorization strategies</li> <li>Testability: Dummy implementation available for testing</li> <li>Configuration-Driven: No hardcoded authorization logic</li> <li>Thread Safety: Singleton implementation ensures consistent behavior</li> <li>Type Safety: Factory validates loaded classes at runtime</li> </ol>"},{"location":"hitl/authorization/#dependencies","title":"Dependencies","text":"<ul> <li><code>ska_utils.AppConfig</code>: For configuration management</li> <li><code>ska_utils.ModuleLoader</code>: For dynamic module loading</li> <li><code>sk_agents.configs</code>: For configuration constants</li> <li><code>threading</code>: For thread-safe singleton implementation</li> <li><code>abc</code>: For abstract base class definition</li> </ul>"},{"location":"hitl/authorization/#thread-safety","title":"Thread Safety","text":"<p>The module is designed to be thread-safe:</p> <ul> <li>The <code>Singleton</code> metaclass uses threading locks to prevent race conditions</li> <li>The <code>AuthorizerFactory</code> is a singleton, ensuring consistent authorization across threads</li> <li>Authorization instances can be safely shared across multiple threads</li> </ul>"},{"location":"hitl/authorization/#error-handling","title":"Error Handling","text":"<p>The module provides comprehensive error handling:</p> <ul> <li>Configuration Errors: Clear messages for missing environment variables</li> <li>Import Errors: Detailed error messages for module loading failures</li> <li>Type Errors: Validation that loaded classes implement the correct interface</li> <li>Authorization Errors: Proper propagation of authentication failures</li> </ul>"},{"location":"hitl/hitl/","title":"Human-in-the-Loop (HITL) System","text":"<p>This document provides a comprehensive overview of the Human-in-the-Loop (HITL) system for the Teal Agents framework, including detailed documentation of all classes, functions, and implementation patterns.</p>"},{"location":"hitl/hitl/#overview","title":"Overview","text":"<p>The HITL system provides a security and governance layer that enables human oversight and approval for high-risk or sensitive tool calls before they are executed by AI agents. This system ensures that potentially dangerous operations require explicit human authorization, adding a critical safety layer to autonomous agent execution.</p>"},{"location":"hitl/hitl/#core-features","title":"Core Features","text":"<ul> <li>Tool Call Interception: Automatic detection and interception of high-risk function calls</li> <li>Policy-Based Governance: Integration with plugin catalog for configurable tool governance</li> <li>Exception-Based Flow Control: Clean exception handling for intervention requirements</li> <li>Request Tracking: Full traceability of intervention requests and responses</li> <li>URL-Based Approval: RESTful approval/rejection mechanism for human reviewers</li> </ul>"},{"location":"hitl/hitl/#folder-structure","title":"Folder Structure","text":"<pre><code>hitl/\n\u251c\u2500\u2500 __init__.py                    # Package initialization (empty)\n\u251c\u2500\u2500 README.md                      # This documentation file\n\u2514\u2500\u2500 hitl_manager.py               # Core HITL functionality and exception handling\n</code></pre>"},{"location":"hitl/hitl/#core-classes-and-functions-documentation","title":"Core Classes and Functions Documentation","text":""},{"location":"hitl/hitl/#1-check_for_intervention-function","title":"1. check_for_intervention() Function","text":"<p>File: <code>hitl_manager.py</code></p> <p>The primary function responsible for determining whether a tool call requires human intervention.</p>"},{"location":"hitl/hitl/#function-signature","title":"Function Signature","text":"<pre><code>def check_for_intervention(tool_call: FunctionCallContent) -&gt; bool\n</code></pre>"},{"location":"hitl/hitl/#parameters","title":"Parameters","text":"<ul> <li><code>tool_call: FunctionCallContent</code>: A Semantic Kernel function call object containing:</li> <li><code>plugin_name</code>: The name of the plugin containing the function</li> <li><code>function_name</code>: The specific function being called</li> <li>Additional metadata about the function call</li> </ul>"},{"location":"hitl/hitl/#returns","title":"Returns","text":"<ul> <li><code>bool</code>: <code>True</code> if the tool call requires human intervention, <code>False</code> otherwise</li> </ul>"},{"location":"hitl/hitl/#implementation-details","title":"Implementation Details","text":"<p>The function performs the following operations:</p> <ol> <li>Plugin Catalog Integration: Creates a <code>PluginCatalogFactory</code> instance to access the tool governance catalog</li> <li>Tool Identification: Constructs a unique tool ID using the format <code>{plugin_name}-{function_name}</code></li> <li>Governance Check: Queries the catalog for the tool's governance settings</li> <li>Policy Evaluation: Returns the value of <code>tool.governance.requires_hitl</code> if the tool is found in the catalog</li> <li>Fallback Behavior: Returns <code>False</code> (no intervention required) if:</li> <li>The catalog is not configured</li> <li>The tool is not found in the catalog</li> </ol>"},{"location":"hitl/hitl/#sk_agents.hitl.hitl_manager.check_for_intervention","title":"sk_agents.hitl.hitl_manager.check_for_intervention","text":"<pre><code>check_for_intervention(\n    tool_call: FunctionCallContent,\n) -&gt; bool\n</code></pre> <p>Checks the plugin catalog to determine if a tool call requires Human-in-the-Loop intervention.</p> Source code in <code>src/sk_agents/hitl/hitl_manager.py</code> <pre><code>def check_for_intervention(tool_call: FunctionCallContent) -&gt; bool:\n    \"\"\"\n    Checks the plugin catalog to determine if a tool call requires\n    Human-in-the-Loop intervention.\n    \"\"\"\n    plugin_factory = PluginCatalogFactory()\n    catalog = plugin_factory.get_catalog()\n    if not catalog:\n        # Fallback if catalog is not configured\n        return False\n\n    tool_id = f\"{tool_call.plugin_name}-{tool_call.function_name}\"\n    tool = catalog.get_tool(tool_id)\n\n    if tool:\n        logger.debug(\n            f\"HITL Check: Intercepted call to {tool_id}. \"\n            f\"Requires HITL: {tool.governance.requires_hitl}\"\n        )\n        return tool.governance.requires_hitl\n    # Default to no intervention if tool is not in the catalog\n    return False\n</code></pre>"},{"location":"hitl/hitl/#usage-in-agent-workflow","title":"Usage in Agent Workflow","text":"<p>This function is called by the agent handler during tool call processing:</p> <pre><code># In agent handler\nfor fc in function_calls:\n    if hitl_manager.check_for_intervention(fc):\n        intervention_calls.append(fc)\n\nif intervention_calls:\n    raise hitl_manager.HitlInterventionRequired(intervention_calls)\n</code></pre>"},{"location":"hitl/hitl/#debug-output","title":"Debug Output","text":"<p>The function includes diagnostic logging that outputs:</p> <ul> <li>The tool ID being checked</li> <li>Whether HITL intervention is required for that tool</li> </ul>"},{"location":"hitl/hitl/#2-hitlinterventionrequired-exception","title":"2. HitlInterventionRequired Exception","text":"<p>File: <code>hitl_manager.py</code></p> <p>A custom exception class that signals when tool calls require human intervention and halts agent execution until approval is received.</p>"},{"location":"hitl/hitl/#class-definition","title":"Class Definition","text":"<pre><code>class HitlInterventionRequired(Exception):\n    def __init__(self, function_calls: list[FunctionCallContent])\n</code></pre>"},{"location":"hitl/hitl/#attributes","title":"Attributes","text":"<ul> <li><code>function_calls: list[FunctionCallContent]</code>: List of all function calls that require intervention</li> <li><code>plugin_name: str</code>: Name of the plugin from the first function call (for convenience)</li> <li><code>function_name: str</code>: Name of the function from the first function call (for convenience)</li> </ul>"},{"location":"hitl/hitl/#constructor-behavior","title":"Constructor Behavior","text":"<ol> <li>Stores Function Calls: Preserves the complete list of function calls requiring intervention</li> <li>Extracts Metadata: Sets <code>plugin_name</code> and <code>function_name</code> from the first function call for easy access</li> <li>Generates Message: Creates a descriptive error message indicating which plugin and function requires intervention</li> <li>Handles Empty Lists: Provides a fallback message if no function calls are provided</li> </ol>"},{"location":"hitl/hitl/#exception-message-format","title":"Exception Message Format","text":"<ul> <li>With function calls: <code>\"HITL intervention required for {plugin_name}.{function_name}\"</code></li> <li>Without function calls: <code>\"HITL intervention required\"</code></li> </ul>"},{"location":"hitl/hitl/#usage-in-error-handling","title":"Usage in Error Handling","text":"<p>The exception is caught by agent handlers to generate <code>HitlResponse</code> objects:</p> <pre><code>try:\n    # Agent execution code\n    pass\nexcept hitl_manager.HitlInterventionRequired as hitl_exc:\n    # Generate HITL response with approval/rejection URLs\n    return HitlResponse(\n        task_id=task_id,\n        session_id=session_id,\n        request_id=request_id,\n        tool_calls=[fc.model_dump() for fc in hitl_exc.function_calls],\n        approval_url=f\"/approve/{request_id}\",\n        rejection_url=f\"/reject/{request_id}\"\n    )\n</code></pre>"},{"location":"hitl/hitl/#sk_agents.hitl.hitl_manager.HitlInterventionRequired","title":"sk_agents.hitl.hitl_manager.HitlInterventionRequired","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when a tool call requires human-in-the-loop intervention.</p> Source code in <code>src/sk_agents/hitl/hitl_manager.py</code> <pre><code>class HitlInterventionRequired(Exception):\n    \"\"\"\n    Exception raised when a tool call\n    requires human-in-the-loop intervention.\n    \"\"\"\n\n    def __init__(self, function_calls: list[FunctionCallContent]):\n        self.function_calls = function_calls\n        if function_calls:\n            self.plugin_name = function_calls[0].plugin_name\n            self.function_name = function_calls[0].function_name\n            message = f\"HITL intervention required for {self.plugin_name}.{self.function_name}\"\n\n        else:\n            message = \"HITL intervention required but no function calls provided (internal error)\"\n        super().__init__(message)\n</code></pre>"},{"location":"hitl/hitl/#integration-with-teal-agents-framework","title":"Integration with Teal Agents Framework","text":""},{"location":"hitl/hitl/#agent-handler-integration","title":"Agent Handler Integration","text":"<p>The HITL system is integrated into the main agent execution flow at multiple points:</p> <ol> <li>Import: <code>from sk_agents.hitl import hitl_manager</code></li> <li>Tool Call Screening: Each function call is checked before execution</li> <li>Exception Handling: HITL exceptions are caught and converted to HTTP responses</li> <li>State Management: HITL requests are tracked through the agent's state system</li> </ol>"},{"location":"hitl/hitl/#plugin-catalog-dependency","title":"Plugin Catalog Dependency","text":"<p>The HITL system relies on the plugin catalog for governance policies:</p> <ul> <li>Tool Registration: Tools must be registered in the catalog with governance metadata</li> <li>Policy Configuration: The <code>requires_hitl</code> flag in tool governance determines intervention requirements</li> <li>Dynamic Updates: Governance policies can be updated without code changes</li> </ul>"},{"location":"hitl/hitl/#response-model-integration","title":"Response Model Integration","text":"<p>The system generates <code>HitlResponse</code> objects (defined in <code>sk_agents.tealagents.models</code>) containing:</p> <ul> <li>Task Metadata: <code>task_id</code>, <code>session_id</code>, <code>request_id</code></li> <li>Human Message: Descriptive message about the intervention requirement</li> <li>Approval URLs: RESTful endpoints for human approval/rejection</li> <li>Tool Call Data: Serialized function calls awaiting approval</li> </ul>"},{"location":"hitl/hitl/#security-considerations","title":"Security Considerations","text":""},{"location":"hitl/hitl/#fail-safe-design","title":"Fail-Safe Design","text":"<ul> <li>Default Deny: Unknown tools default to no intervention (configurable)</li> <li>Catalog Dependency: Missing catalog configuration falls back to permissive behavior</li> <li>Exception Isolation: HITL exceptions don't crash the agent, they pause execution</li> </ul>"},{"location":"hitl/hitl/#governance-integration","title":"Governance Integration","text":"<ul> <li>Centralized Policy: All governance rules are managed through the plugin catalog</li> <li>Audit Trail: All intervention requests are tracked and logged</li> <li>Configurable Risk Levels: Tools can be classified with different risk levels and policies</li> </ul>"},{"location":"hitl/hitl/#future-enhancements","title":"Future Enhancements","text":""},{"location":"hitl/hitl/#planned-features","title":"Planned Features","text":"<ul> <li>Risk Level Classification: Support for different intervention policies based on risk levels</li> <li>Batch Approval: Ability to approve/reject multiple tool calls simultaneously</li> <li>Timeout Handling: Automatic rejection of approval requests after timeout</li> <li>User Context: Integration with user authentication for personalized approval flows</li> </ul>"},{"location":"hitl/hitl/#extension-points","title":"Extension Points","text":"<ul> <li>Custom Policies: Support for custom intervention logic beyond simple boolean flags</li> <li>Approval Workflows: Integration with enterprise approval systems</li> <li>Notification Systems: Email/Slack notifications for pending approvals</li> <li>Analytics: Metrics on intervention frequency and approval rates</li> </ul>"},{"location":"hitl/hitl/#error-handling","title":"Error Handling","text":""},{"location":"hitl/hitl/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>Exception\n\u2514\u2500\u2500 HitlInterventionRequired\n    \u251c\u2500\u2500 function_calls: list[FunctionCallContent]\n    \u251c\u2500\u2500 plugin_name: str\n    \u2514\u2500\u2500 function_name: str\n</code></pre>"},{"location":"hitl/hitl/#error-recovery","title":"Error Recovery","text":"<ul> <li>Graceful Degradation: System continues operation even if HITL components fail</li> <li>Logging: All intervention decisions are logged for audit purposes</li> <li>Fallback Behavior: Clear fallback policies when governance data is unavailable</li> </ul>"},{"location":"hitl/hitl/#testing-considerations","title":"Testing Considerations","text":""},{"location":"hitl/hitl/#unit-testing","title":"Unit Testing","text":"<ul> <li>Mock Plugin Catalog: Test with various catalog configurations</li> <li>Exception Flow: Verify exception handling and response generation</li> <li>Edge Cases: Test with empty function call lists and missing catalog data</li> </ul>"},{"location":"hitl/hitl/#integration-testing","title":"Integration Testing","text":"<ul> <li>End-to-End Flow: Test complete approval/rejection workflows</li> <li>State Persistence: Verify that HITL requests are properly tracked</li> <li>URL Generation: Validate approval/rejection URL correctness</li> </ul>"},{"location":"hitl/hitl/#development-guidelines","title":"Development Guidelines","text":""},{"location":"hitl/hitl/#adding-new-hitl-policies","title":"Adding New HITL Policies","text":"<ol> <li>Register Tools: Add tools to the plugin catalog with appropriate governance flags</li> <li>Test Integration: Verify that <code>check_for_intervention</code> correctly identifies the tools</li> <li>Update Documentation: Document new governance policies and their implications</li> </ol>"},{"location":"hitl/hitl/#debugging-hitl-issues","title":"Debugging HITL Issues","text":"<ol> <li>Check Logs: Look for \"HITL Check: Intercepted call\" messages</li> <li>Verify Catalog: Ensure the plugin catalog is properly configured</li> <li>Test Isolation: Use unit tests to isolate HITL logic from agent execution</li> </ol>"},{"location":"hitl/persistence/","title":"Task Persistence System","text":"<p>This document provides a comprehensive overview of the task persistence system for the Teal Agents framework, including detailed documentation of all classes, interfaces, and implementation patterns.</p>"},{"location":"hitl/persistence/#overview","title":"Overview","text":"<p>The task persistence system provides a flexible, pluggable architecture for storing and retrieving agent tasks and their state. The system supports multiple storage backends through a factory pattern with dependency injection.</p>"},{"location":"hitl/persistence/#core-features","title":"Core Features","text":"<ul> <li>Pluggable Architecture: Factory pattern with configurable implementations</li> <li>Thread-Safe Operations: Async-safe with proper locking mechanisms</li> <li>In-Memory Storage (default): Zero configuration, perfect for development</li> <li>Redis Storage (optional): Persistent, scalable, production-ready</li> <li>Custom Storage: Support for user-defined implementations</li> <li>Request ID Indexing: Fast lookups by request ID across all implementations</li> </ul>"},{"location":"hitl/persistence/#folder-structure","title":"Folder Structure","text":"<pre><code>persistence/\n\u251c\u2500\u2500 __init__.py                           # Package initialization (empty)\n\u251c\u2500\u2500 README.md                            # This documentation file\n\u251c\u2500\u2500 singleton.py                         # Thread-safe singleton metaclass\n\u251c\u2500\u2500 task_persistence_manager.py         # Abstract base class interface\n\u251c\u2500\u2500 in_memory_persistence_manager.py    # Default in-memory implementation\n\u251c\u2500\u2500 persistence_factory.py              # Factory pattern with dependency injection\n\u2514\u2500\u2500 custom/                              # Custom implementations directory\n    \u2514\u2500\u2500 example_redis_persistence.py    # Production-ready Redis implementation\n</code></pre>"},{"location":"hitl/persistence/#core-classes-documentation","title":"Core Classes Documentation","text":""},{"location":"hitl/persistence/#1-taskpersistencemanager-abstract-base-class","title":"1. TaskPersistenceManager (Abstract Base Class)","text":"<p>File: <code>task_persistence_manager.py</code></p> <p>The abstract base class that defines the interface for all persistence implementations.</p>"},{"location":"hitl/persistence/#methods","title":"Methods","text":"<ul> <li><code>async create(task: AgentTask) -&gt; None</code></li> <li>Creates a new task in the persistence layer</li> <li> <p>Should raise <code>PersistenceCreateError</code> if task already exists or on failure</p> </li> <li> <p><code>async load(task_id: str) -&gt; AgentTask | None</code></p> </li> <li>Loads a task by its unique task ID</li> <li>Returns <code>None</code> if task not found</li> <li> <p>Should raise <code>PersistenceLoadError</code> on failure</p> </li> <li> <p><code>async update(task: AgentTask) -&gt; None</code></p> </li> <li>Updates an existing task in the persistence layer</li> <li> <p>Should raise <code>PersistenceUpdateError</code> if task doesn't exist or on failure</p> </li> <li> <p><code>async delete(task_id: str) -&gt; None</code></p> </li> <li>Deletes a task by its unique task ID</li> <li> <p>Should raise <code>PersistenceDeleteError</code> if task doesn't exist or on failure</p> </li> <li> <p><code>async load_by_request_id(request_id: str) -&gt; AgentTask | None</code></p> </li> <li>Loads a task by request ID (for tasks containing items with specific request IDs)</li> <li>Returns the first matching task if multiple exist</li> <li>Returns <code>None</code> if no task found</li> </ul>"},{"location":"hitl/persistence/#2-inmemorypersistencemanager-default-implementation","title":"2. InMemoryPersistenceManager (Default Implementation)","text":"<p>File: <code>in_memory_persistence_manager.py</code></p> <p>Production-ready in-memory implementation with thread safety and request ID indexing.</p>"},{"location":"hitl/persistence/#implementation-features","title":"Implementation Features","text":"<ul> <li>Thread Safety: Uses <code>asyncio.Lock()</code> for concurrent access protection</li> <li>Dual Indexing: Primary storage by task_id + secondary index by request_id</li> <li>Memory Efficient: Automatic cleanup of empty index entries</li> <li>Error Handling: Comprehensive exception handling with custom error types</li> </ul>"},{"location":"hitl/persistence/#internal-data-structures","title":"Internal Data Structures","text":"<ul> <li><code>in_memory: dict[str, AgentTask]</code>: Primary storage mapping task_id to AgentTask</li> <li><code>item_request_id_index: dict[str, set[str]]</code>: Secondary index mapping request_id to set of task_ids</li> </ul>"},{"location":"hitl/persistence/#thread-safety-implementation","title":"Thread Safety Implementation","text":"<pre><code>async with self._lock:\n    # All operations are protected by asyncio.Lock\n</code></pre>"},{"location":"hitl/persistence/#3-persistencefactory-factory-pattern","title":"3. PersistenceFactory (Factory Pattern)","text":"<p>File: <code>persistence_factory.py</code></p> <p>Singleton factory responsible for creating and managing persistence manager instances with dependency injection support.</p>"},{"location":"hitl/persistence/#key-features","title":"Key Features","text":"<ul> <li>Singleton Pattern: Ensures single instance per application lifecycle</li> <li>Dynamic Module Loading: Loads custom implementations via <code>ModuleLoader</code></li> <li>Configuration-Driven: Uses environment variables for custom implementations</li> <li>Validation: Ensures custom classes inherit from <code>TaskPersistenceManager</code></li> <li>Graceful Fallback: Falls back to in-memory implementation if custom module fails</li> </ul>"},{"location":"hitl/persistence/#configuration-methods","title":"Configuration Methods","text":"<ul> <li><code>_get_custom_persistence_config() -&gt; tuple[str | None, str | None]</code></li> <li>Retrieves module and class names from environment variables</li> <li> <p>Returns <code>(None, None)</code> if using default configuration</p> </li> <li> <p><code>_validate_custom_class()</code></p> </li> <li>Validates that custom class exists and inherits from <code>TaskPersistenceManager</code></li> <li>Raises appropriate exceptions for missing or invalid classes</li> </ul>"},{"location":"hitl/persistence/#dependency-injection","title":"Dependency Injection","text":"<p>The factory attempts to pass <code>app_config</code> to custom implementations:</p> <pre><code>try:\n    return custom_class(app_config=self.app_config)\nexcept TypeError:\n    # Fallback if app_config not accepted\n    return custom_class()\n</code></pre>"},{"location":"hitl/persistence/#4-singleton-metaclass","title":"4. Singleton (Metaclass)","text":"<p>File: <code>singleton.py</code></p> <p>Thread-safe singleton metaclass implementation using Python's <code>threading.Lock</code>.</p>"},{"location":"hitl/persistence/#features","title":"Features","text":"<ul> <li>Thread Safety: Uses <code>threading.Lock()</code> to prevent race conditions</li> <li>Metaclass Pattern: Implements singleton at the class level</li> <li>Instance Caching: Maintains <code>_instances</code> dictionary for created instances</li> </ul>"},{"location":"hitl/persistence/#usage-pattern","title":"Usage Pattern","text":"<pre><code>class MyClass(metaclass=Singleton):\n    def __init__(self):\n        # Initialization code\n        pass\n</code></pre>"},{"location":"hitl/persistence/#custom-implementations-directory","title":"Custom Implementations Directory","text":""},{"location":"hitl/persistence/#redistaskpersistencemanager-production-example","title":"RedisTaskPersistenceManager (Production Example)","text":"<p>File: <code>custom/example_redis_persistence.py</code></p> <p>A complete, production-ready Redis-based persistence implementation demonstrating advanced patterns.</p>"},{"location":"hitl/persistence/#architecture-features","title":"Architecture Features","text":"<ul> <li>Connection Management: Robust Redis connection with retry logic</li> <li>Serialization: JSON-based task serialization using Pydantic models</li> <li>TTL Support: Configurable time-to-live for all stored data</li> <li>Index Management: Maintains request_id to task_id mapping in Redis sets</li> <li>Error Recovery: Handles corrupted data with automatic cleanup</li> <li>Health Monitoring: Built-in health check capabilities</li> </ul>"},{"location":"hitl/persistence/#configuration-environment-variables","title":"Configuration Environment Variables","text":"<pre><code>TA_REDIS_HOST        # Redis server hostname (default: localhost)\nTA_REDIS_PORT        # Redis server port (default: 6379)\nTA_REDIS_DB          # Redis database number (default: 0)\nTA_REDIS_TTL         # Time-to-live in seconds (default: 3600)\nTA_REDIS_PWD         # Redis password (optional)\nTA_REDIS_SSL         # Enable SSL connection (default: false)\n</code></pre>"},{"location":"hitl/persistence/#redis-key-patterns","title":"Redis Key Patterns","text":"<ul> <li>Task Storage: <code>task_persistence:task:{task_id}</code></li> <li>Request Index: <code>task_persistence:request_index:{request_id}</code></li> </ul>"},{"location":"hitl/persistence/#advanced-methods","title":"Advanced Methods","text":"<ul> <li><code>health_check() -&gt; bool</code>: Tests Redis connectivity</li> <li><code>clear_all_tasks() -&gt; int</code>: Utility method for testing/cleanup</li> <li><code>_serialize_task(task: AgentTask) -&gt; str</code>: JSON serialization</li> <li><code>_deserialize_task(task_str: str) -&gt; AgentTask</code>: JSON deserialization</li> </ul>"},{"location":"hitl/persistence/#error-handling-strategy","title":"Error Handling Strategy","text":"<pre><code>try:\n    # Redis operation\nexcept redis.RedisError as e:\n    raise PersistenceCreateError(f\"Redis error: {e}\") from e\nexcept json.JSONDecodeError as e:\n    # Handle corrupted data with cleanup\n    self.redis_client.delete(task_key)\n    raise PersistenceLoadError(f\"Corrupted data: {e}\") from e\n</code></pre>"},{"location":"hitl/persistence/#configuration-system","title":"Configuration System","text":""},{"location":"hitl/persistence/#environment-variables","title":"Environment Variables","text":"<p>The persistence system uses the following environment variables:</p> <ul> <li><code>TA_PERSISTENCE_MODULE</code>: Path to custom task persistence module</li> <li><code>TA_PERSISTENCE_CLASS</code>: Class name for custom implementation</li> </ul>"},{"location":"hitl/persistence/#configuration-examples","title":"Configuration Examples","text":""},{"location":"hitl/persistence/#development-default-in-memory","title":"Development (Default - In-Memory)","text":"<pre><code># No configuration needed - uses in-memory storage\n</code></pre>"},{"location":"hitl/persistence/#production-with-redis","title":"Production with Redis","text":"<pre><code>export TA_PERSISTENCE_MODULE=src/sk_agents/persistence/custom/example_redis_persistence.py\nexport TA_PERSISTENCE_CLASS=RedisTaskPersistenceManager\nexport TA_REDIS_HOST=redis.production.com\nexport TA_REDIS_PORT=6379\nexport TA_REDIS_PWD=secure_password\nexport TA_REDIS_SSL=true\nexport TA_REDIS_TTL=7200\n</code></pre>"},{"location":"hitl/persistence/#custom-implementation","title":"Custom Implementation","text":"<pre><code>export TA_PERSISTENCE_MODULE=my_custom_module.py\nexport TA_PERSISTENCE_CLASS=MyCustomPersistenceManager\n</code></pre>"},{"location":"hitl/persistence/#usage-patterns","title":"Usage Patterns","text":""},{"location":"hitl/persistence/#basic-usage","title":"Basic Usage","text":"<pre><code>from ska_utils import AppConfig\nfrom sk_agents.persistence.persistence_factory import PersistenceFactory\nfrom sk_agents.tealagents.models import AgentTask\n\n# Get task persistence manager\napp_config = AppConfig()\nfactory = PersistenceFactory(app_config)\npersistence_manager = factory.get_persistence_manager()\n\n# Store, retrieve, and manage task data\nawait persistence_manager.create(agent_task)\nretrieved_task = await persistence_manager.load(\"task_id_123\")\nawait persistence_manager.update(agent_task)\nawait persistence_manager.delete(\"task_id_123\")\n\n# Load by request ID (useful for resuming workflows)\ntask = await persistence_manager.load_by_request_id(\"request_123\")\n</code></pre>"},{"location":"hitl/persistence/#advanced-usage-with-error-handling","title":"Advanced Usage with Error Handling","text":"<pre><code>from sk_agents.exceptions import PersistenceCreateError, PersistenceLoadError\n\ntry:\n    await persistence_manager.create(task)\nexcept PersistenceCreateError as e:\n    logger.error(f\"Failed to create task: {e.message}\")\n    # Handle creation failure\n\ntry:\n    task = await persistence_manager.load(task_id)\n    if task is None:\n        logger.info(f\"Task {task_id} not found\")\n    else:\n        # Process loaded task\n        pass\nexcept PersistenceLoadError as e:\n    logger.error(f\"Failed to load task: {e.message}\")\n</code></pre>"},{"location":"hitl/persistence/#creating-custom-implementations","title":"Creating Custom Implementations","text":""},{"location":"hitl/persistence/#step-1-implement-the-interface","title":"Step 1: Implement the Interface","text":"<p>Create a new class that inherits from <code>TaskPersistenceManager</code>:</p> <pre><code>from sk_agents.persistence.task_persistence_manager import TaskPersistenceManager\nfrom sk_agents.tealagents.models import AgentTask\nfrom sk_agents.exceptions import (\n    PersistenceCreateError,\n    PersistenceDeleteError,\n    PersistenceLoadError,\n    PersistenceUpdateError,\n)\n\nclass MyCustomTaskPersistenceManager(TaskPersistenceManager):\n    def __init__(self, app_config=None):\n        # Initialize your storage backend\n        self.storage = self._initialize_storage(app_config)\n\n    async def create(self, task: AgentTask) -&gt; None:\n        try:\n            # Your implementation\n            if await self._task_exists(task.task_id):\n                raise PersistenceCreateError(\n                    f\"Task {task.task_id} already exists\"\n                )\n            await self._store_task(task)\n        except Exception as e:\n            raise PersistenceCreateError(f\"Create failed: {e}\") from e\n\n    async def load(self, task_id: str) -&gt; AgentTask | None:\n        try:\n            return await self._retrieve_task(task_id)\n        except Exception as e:\n            raise PersistenceLoadError(f\"Load failed: {e}\") from e\n\n    async def update(self, task: AgentTask) -&gt; None:\n        try:\n            if not await self._task_exists(task.task_id):\n                raise PersistenceUpdateError(\n                    f\"Task {task.task_id} does not exist\"\n                )\n            await self._update_task(task)\n        except Exception as e:\n            raise PersistenceUpdateError(f\"Update failed: {e}\") from e\n\n    async def delete(self, task_id: str) -&gt; None:\n        try:\n            if not await self._task_exists(task_id):\n                raise PersistenceDeleteError(\n                    f\"Task {task_id} does not exist\"\n                )\n            await self._remove_task(task_id)\n        except Exception as e:\n            raise PersistenceDeleteError(f\"Delete failed: {e}\") from e\n\n    async def load_by_request_id(self, request_id: str) -&gt; AgentTask | None:\n        try:\n            task_ids = await self._find_tasks_by_request_id(request_id)\n            if not task_ids:\n                return None\n            return await self.load(task_ids[0])\n        except Exception as e:\n            raise PersistenceLoadError(f\"Load by request_id failed: {e}\") from e\n</code></pre>"},{"location":"hitl/persistence/#step-2-configuration","title":"Step 2: Configuration","text":"<p>Set the environment variables to use your custom implementation:</p> <pre><code>export TA_PERSISTENCE_MODULE=path/to/your/custom_module.py\nexport TA_PERSISTENCE_CLASS=MyCustomTaskPersistenceManager\n</code></pre>"},{"location":"hitl/persistence/#step-3-integration","title":"Step 3: Integration","text":"<p>The factory will automatically load and validate your implementation when the application starts.</p>"},{"location":"hitl/persistence/#error-handling","title":"Error Handling","text":"<p>The persistence system uses custom exception types for different failure scenarios:</p> <ul> <li><code>PersistenceCreateError</code>: Task creation failures</li> <li><code>PersistenceLoadError</code>: Task retrieval failures</li> <li><code>PersistenceUpdateError</code>: Task update failures</li> <li><code>PersistenceDeleteError</code>: Task deletion failures</li> </ul> <p>All implementations should raise these specific exceptions to maintain consistent error handling across the system.</p>"},{"location":"hitl/persistence/#testing-considerations","title":"Testing Considerations","text":"<p>When implementing custom persistence managers:</p> <ol> <li>Unit Tests: Test all CRUD operations with various edge cases</li> <li>Concurrency Tests: Verify thread safety with concurrent operations</li> <li>Error Scenarios: Test network failures, corrupted data, etc.</li> <li>Performance Tests: Measure latency and throughput under load</li> <li>Integration Tests: Test with actual AgentTask objects</li> </ol> <p>Example test pattern:</p> <pre><code>import pytest\nfrom sk_agents.tealagents.models import AgentTask\n\n@pytest.mark.asyncio\nasync def test_create_and_load():\n    persistence_manager = MyCustomPersistenceManager()\n\n    # Create test task\n    task = AgentTask(task_id=\"test_123\", ...)\n    await persistence_manager.create(task)\n\n    # Verify retrieval\n    loaded_task = await persistence_manager.load(\"test_123\")\n    assert loaded_task is not None\n    assert loaded_task.task_id == \"test_123\"\n</code></pre>"},{"location":"hitl/persistence/#best-practices","title":"Best Practices","text":"<ol> <li>Thread Safety: Always implement proper locking for concurrent access</li> <li>Error Handling: Use the standard exception types for consistency</li> <li>Resource Management: Properly close connections and clean up resources</li> <li>Configuration: Support dependency injection via <code>app_config</code> parameter</li> <li>Logging: Include comprehensive logging for debugging and monitoring</li> <li>Validation: Validate input parameters and handle edge cases</li> <li>Documentation: Document configuration requirements and usage patterns</li> </ol>"},{"location":"hitl/plugin_catalog/","title":"Plugin Catalog Module","text":"<p>The Plugin Catalog module provides a comprehensive system for managing, cataloging, and accessing plugins and their associated tools within the Teal Agents framework. This module implements a flexible architecture that supports different plugin types, governance controls, authentication mechanisms, and data loading strategies.</p>"},{"location":"hitl/plugin_catalog/#module-overview","title":"Module Overview","text":"<p>The plugin catalog system is designed to:</p> <ul> <li>Provide a standardized way to define and catalog plugins</li> <li>Implement governance controls for plugin tools (cost, data sensitivity, human-in-the-loop requirements)</li> <li>Support different plugin types (code-based, MCP-based)</li> <li>Enable dynamic loading and configuration of plugin catalogs</li> <li>Maintain a registry of available tools with their metadata</li> </ul>"},{"location":"hitl/plugin_catalog/#file-structure-and-components","title":"File Structure and Components","text":""},{"location":"hitl/plugin_catalog/#1-modelspy-data-models-and-schema-definitions","title":"1. <code>models.py</code> - Data Models and Schema Definitions","text":"<p>This file contains all Pydantic data models that define the structure and validation rules for the plugin catalog system.</p>"},{"location":"hitl/plugin_catalog/#core-classes","title":"Core Classes","text":"<p>Plugin Type Models:</p> <ul> <li><code>CodePluginType</code>: Represents plugins that contain executable code</li> <li> <p><code>type_name</code>: Literal[\"code\"] - Identifies this as a code-based plugin</p> </li> <li> <p><code>McpPluginType</code>: Represents Model Context Protocol (MCP) plugins</p> </li> <li><code>type_name</code>: Literal[\"mcp\"] - Identifies this as an MCP plugin</li> <li> <p>Future-proofed for additional MCP-specific metadata</p> </li> <li> <p><code>PluginType</code>: Union type that can be either CodePluginType or McpPluginType</p> </li> </ul> <p>Governance Model:</p> <ul> <li><code>Governance</code>: Defines security and operational controls for plugin tools</li> <li><code>requires_hitl</code>: Boolean flag indicating if human-in-the-loop approval is required</li> <li><code>cost</code>: Enum [\"low\", \"medium\", \"high\"] - Resource cost classification</li> <li><code>data_sensitivity</code>: Enum [\"public\", \"proprietary\", \"confidential\", \"sensitive\"] - Data sensitivity level</li> </ul> <p>Authentication Models:</p> <ul> <li><code>Oauth2PluginAuth</code>: OAuth2 authentication configuration</li> <li><code>auth_type</code>: Literal[\"oauth2\"] - Authentication method identifier</li> <li><code>auth_server</code>: Server URL for OAuth2 authentication</li> <li> <p><code>scopes</code>: List of OAuth2 scopes required</p> </li> <li> <p><code>PluginAuth</code>: Union type for authentication methods (currently only OAuth2)</p> </li> </ul> <p>Core Plugin Models:</p> <ul> <li><code>PluginTool</code>: Represents an individual tool within a plugin</li> <li><code>tool_id</code>: Unique identifier (e.g., \"Shell-execute\")</li> <li><code>name</code>: Human-readable tool name</li> <li><code>description</code>: Tool functionality description</li> <li><code>governance</code>: Governance controls for the tool</li> <li> <p><code>auth</code>: Optional authentication requirements</p> </li> <li> <p><code>Plugin</code>: Represents a complete plugin with its tools</p> </li> <li><code>plugin_id</code>: Unique plugin identifier</li> <li><code>name</code>: Human-readable plugin name</li> <li><code>description</code>: Plugin functionality description</li> <li><code>version</code>: Plugin version string</li> <li><code>owner</code>: Plugin owner/maintainer</li> <li><code>plugin_type</code>: Type of plugin (code or MCP)</li> <li> <p><code>tools</code>: List of tools provided by the plugin</p> </li> <li> <p><code>PluginCatalogDefinition</code>: Top-level container for plugin catalog data</p> </li> <li><code>plugins</code>: List of all plugins in the catalog</li> </ul>"},{"location":"hitl/plugin_catalog/#2-plugin_catalogpy-abstract-base-class","title":"2. <code>plugin_catalog.py</code> - Abstract Base Class","text":"<p>This file defines the abstract interface that all plugin catalog implementations must follow.</p>"},{"location":"hitl/plugin_catalog/#interface-definition","title":"Interface Definition","text":"<p>PluginCatalog (ABC):</p> <ul> <li>Abstract base class defining the contract for plugin catalog implementations</li> <li>Methods:</li> <li><code>get_plugin(plugin_id: str) -&gt; Plugin | None</code>: Retrieve a plugin by its ID</li> <li><code>get_tool(tool_id: str) -&gt; PluginTool | None</code>: Retrieve a tool by its ID</li> </ul> <p>This abstraction allows for different storage backends (file-based, database, remote API, etc.) while maintaining a consistent interface.</p>"},{"location":"hitl/plugin_catalog/#3-local_plugin_catalogpy-file-based-implementation","title":"3. <code>local_plugin_catalog.py</code> - File-Based Implementation","text":"<p>This file contains the concrete implementation of the plugin catalog that loads plugins from local JSON files.</p>"},{"location":"hitl/plugin_catalog/#implementation-details","title":"Implementation Details","text":"<p>FileBasedPluginCatalog:</p> <ul> <li>Concrete implementation of PluginCatalog that loads from JSON files</li> <li>Constructor Parameters:</li> <li> <p><code>app_config</code>: AppConfig instance for configuration management</p> </li> <li> <p>Instance Variables:</p> </li> <li><code>app_config</code>: Configuration manager</li> <li><code>catalog_path</code>: Path to the JSON catalog file</li> <li><code>_plugins</code>: Dictionary mapping plugin IDs to Plugin objects</li> <li> <p><code>_tools</code>: Dictionary mapping tool IDs to PluginTool objects</p> </li> <li> <p>Methods:</p> </li> <li><code>get_plugin(plugin_id: str) -&gt; Plugin | None</code>: Retrieves plugin from internal cache</li> <li><code>get_tool(tool_id: str) -&gt; PluginTool | None</code>: Retrieves tool from internal cache</li> <li> <p><code>_load_plugins()</code>: Private method that loads and validates plugins from JSON file</p> </li> <li> <p>Error Handling:</p> </li> <li>Validates JSON structure against Pydantic models</li> <li>Raises <code>PluginCatalogDefinitionException</code> for validation errors</li> <li>Raises <code>PluginFileReadException</code> for file I/O errors</li> </ul>"},{"location":"hitl/plugin_catalog/#4-plugin_catalog_factorypy-singleton-factory","title":"4. <code>plugin_catalog_factory.py</code> - Singleton Factory","text":"<p>This file implements a factory pattern with singleton behavior for creating plugin catalog instances.</p>"},{"location":"hitl/plugin_catalog/#factory-implementation","title":"Factory Implementation","text":"<p>PluginCatalogFactory:</p> <ul> <li>Singleton factory that creates and manages plugin catalog instances</li> <li>Uses environment variables to determine which catalog implementation to load</li> <li> <p>Singleton Behavior: Ensures only one factory instance exists per application</p> </li> <li> <p>Instance Variables:</p> </li> <li><code>app_config</code>: Configuration manager</li> <li> <p><code>_catalog_instance</code>: Cached catalog instance</p> </li> <li> <p>Methods:</p> </li> <li><code>get_catalog() -&gt; PluginCatalog</code>: Returns the catalog instance, creating it if needed</li> <li> <p><code>_create_catalog() -&gt; PluginCatalog</code>: Creates new catalog instance based on environment configuration</p> </li> <li> <p>Configuration:</p> </li> <li>Uses <code>TA_PLUGIN_CATALOG_MODULE</code> environment variable to specify the module</li> <li>Uses <code>TA_PLUGIN_CATALOG_CLASS</code> environment variable to specify the class name</li> <li> <p>Dynamically loads and instantiates the specified catalog class</p> </li> <li> <p>Error Handling:</p> </li> <li>Validates that environment variables are set</li> <li>Ensures the specified class inherits from PluginCatalog</li> <li>Handles import and instantiation errors gracefully</li> </ul>"},{"location":"hitl/plugin_catalog/#5-catalogjson-plugin-definitions","title":"5. <code>catalog.json</code> - Plugin Definitions","text":"<p>This JSON file contains the actual plugin and tool definitions used by the file-based catalog implementation.</p>"},{"location":"hitl/plugin_catalog/#plugin-structure","title":"Plugin Structure","text":"<p>The file contains a <code>plugins</code> array with the following sample plugins:</p> <p>sensitive_plugin:</p> <ul> <li>Plugin for executing sensitive shell commands</li> <li>Tools: <code>delete_user_data</code> - requires human approval due to high sensitivity</li> </ul> <p>finance_plugin:</p> <ul> <li>Plugin for financial operations</li> <li>Tools:</li> <li><code>initiate_transfer</code> - requires human approval for financial transactions</li> <li><code>get_balance</code> - low-cost balance inquiry operation</li> </ul> <p>admin_tools:</p> <ul> <li>Administrative system tools</li> <li>Tools: <code>shutdown_service</code> - requires human approval for service management</li> </ul> <p>utility_plugin:</p> <ul> <li>General utility operations</li> <li>Tools: <code>ShellCommand</code> - general shell command execution with approval requirements</li> </ul> <p>Each plugin includes:</p> <ul> <li>Unique identification and metadata</li> <li>Version and ownership information</li> <li>Plugin type classification</li> <li>List of available tools with their governance requirements</li> </ul>"},{"location":"hitl/plugin_catalog/#usage-patterns","title":"Usage Patterns","text":""},{"location":"hitl/plugin_catalog/#1-basic-usage","title":"1. Basic Usage","text":"<pre><code>from sk_agents.plugin_catalog.plugin_catalog_factory import PluginCatalogFactory\n\n# Get the catalog instance\nfactory = PluginCatalogFactory()\ncatalog = factory.get_catalog()\n\n# Retrieve a specific plugin\nplugin = catalog.get_plugin(\"finance_plugin\")\n\n# Retrieve a specific tool\ntool = catalog.get_tool(\"finance_plugin-get_balance\")\n</code></pre>"},{"location":"hitl/plugin_catalog/#2-governance-checks","title":"2. Governance Checks","text":"<pre><code>tool = catalog.get_tool(\"sensitive_plugin-delete_user_data\")\nif tool and tool.governance.requires_hitl:\n    # Request human approval before execution\n    await request_human_approval(tool)\n</code></pre>"},{"location":"hitl/plugin_catalog/#3-custom-catalog-implementation","title":"3. Custom Catalog Implementation","text":"<pre><code>from sk_agents.plugin_catalog.plugin_catalog import PluginCatalog\n\nclass DatabasePluginCatalog(PluginCatalog):\n    def get_plugin(self, plugin_id: str) -&gt; Plugin | None:\n        # Custom implementation using database\n        pass\n\n    def get_tool(self, tool_id: str) -&gt; PluginTool | None:\n        # Custom implementation using database\n        pass\n</code></pre>"},{"location":"hitl/plugin_catalog/#configuration","title":"Configuration","text":"<p>The module uses environment variables for configuration:</p> <ul> <li><code>TA_PLUGIN_CATALOG_MODULE</code>: Python module containing the catalog class</li> <li><code>TA_PLUGIN_CATALOG_CLASS</code>: Class name within the module</li> <li><code>TA_PLUGIN_CATALOG_FILE</code>: Path to the JSON catalog file (for file-based implementation)</li> </ul>"},{"location":"hitl/plugin_catalog/#security-considerations","title":"Security Considerations","text":"<p>The plugin catalog system includes several security features:</p> <ol> <li>Governance Controls: Each tool specifies its risk level and requirements</li> <li>Human-in-the-Loop: Critical operations can require human approval</li> <li>Data Sensitivity Classification: Tools are classified by data sensitivity</li> <li>Authentication Support: OAuth2 and other auth methods can be specified</li> <li>Validation: All plugin definitions are validated against strict schemas</li> </ol>"},{"location":"hitl/plugin_catalog/#extensibility","title":"Extensibility","text":"<p>The modular design allows for easy extension:</p> <ol> <li>New Plugin Types: Add new plugin type models to support additional architectures</li> <li>Additional Auth Methods: Extend the PluginAuth union with new authentication types</li> <li>Custom Catalogs: Implement the PluginCatalog interface for different storage backends</li> <li>Enhanced Governance: Add new governance controls and validation rules</li> </ol>"},{"location":"hitl/plugin_catalog/#dependencies","title":"Dependencies","text":"<ul> <li><code>pydantic</code>: For data validation and serialization</li> <li><code>ska_utils</code>: For configuration management and module loading</li> <li><code>pathlib</code>: For file system operations</li> <li><code>json</code>: For JSON file parsing</li> <li><code>typing</code>: For type hints and annotations</li> </ul> <p>This plugin catalog system provides a robust foundation for managing plugins in the Teal Agents framework, with strong typing, validation, and governance controls to ensure secure and reliable plugin execution.</p>"},{"location":"planning/2507-state-hitl-auth/00-teal-agents-overview/","title":"Overview of Teal Agents - Agent component","text":"<p>This project is one component of a larger, Agent Platform, known as Teal Agents. Its purpose is to enable the simplified creation of AI Agents using a low-code approach consisting of a YAML configuration file and optional Python Plug-in definitions (tools).</p> <p>The application is built using FastAPI as the primary hosting framework and Semantic Kernel for LLM integration. The source code can be found in the <code>src/sk_agents</code> subdirectory of this workspace.</p> <p>Currently, there are two versions of the YAML configuration API:</p> <ul> <li>skagents/v1 - The original version which, while still supported, is     deprecated (although we currently lack a stable successor).</li> <li>skagents/v2alpha1 - An prototype version which was never stabilized but     which does provide a base from which we'll build during this refactoring     initiative. An example of the <code>v2alpha1</code> configuration can be found in the     <code>demos/ZZ_wikipedia_demo</code> directory.</li> </ul> <p>The main entrypoint of the application is the <code>app.py</code> file which performs some basic setup and then, depending on the API version specified in the configuration file, branches to either AppV1 or AppV2 (found in <code>appv1.py</code> and <code>appv2.py</code>, respectively). For the purposes of this refactoring, we will use only <code>appv2.py</code> as a reference.</p> <p><code>appv2.py</code> sets up the pulls in the applicable routes and handlers from the <code>routes.py</code> file which specifies the following endpoints:</p> <ul> <li>POST // - Direct REST invocation <li>POST ///sse - SSE streaming invocation <p>NOTE: There is an additional <code>streaming</code> endpoint which handles websocket connections, but this should be considered deprecated and will not need to considered for future development.</p> <p>The route handlers parse the provided configuration file and then, based on the defined API version, call the appropriate handlers provided in the <code>__init__.py</code> files in the like-named directories (e.g. <code>skagents/v1</code> first invokes the handler in the <code>__init__.py</code> file in the <code>skagents</code> subdirectory which then invokes the handler in the <code>__init__.py</code> file in the <code>skagents/v1</code> subdirectory).  Because <code>v2alpha1</code> was able to leverage the exising <code>v1</code> logic for the <code>Chat</code> <code>kind</code>, no additional subdirectory was introduced, but that will change for this refactor.  The <code>__init__.py</code> file in <code>skagents/v1</code> directory then parses the <code>kind</code> from the configuration file and instantiates the appropriate handler (an implementation of the <code>BaseHandler</code> class) and then passes the request on to that handler for processing.</p> <p>NOTES:</p> <ul> <li>There's a lot that goes in to instantiating the appropriate handler class   including leveraging kernel and agent builders which define the intersection of   this application with Semantic Kernel.</li> <li>Teal Agents is an Open Source project and, as such, it is   implemented to generally support the publicly available LLM endpoints (e.g.   OpenAI).  However, since we're running it inside of our corporate network and we   have a custom LLM gateway, it can be extended with custom implementations of the   <code>ChatCompletionFactory</code> class available in <code>src/sk_agents/ska_types</code> directory.   For us, this has been done and the custom implementation can be found in the   <code>customization/teal-agents/merck_custom_chat_completion_factory.py</code> file.</li> <li>This application is designed in a very extendable manner and its   runtime behavior is heavily dependent on both the provided configuration file as   well as a number of environment variables. Every attempt should be made to   continue developing this in the same, open and extendable manner.</li> <li>This application strives to maintain backwards compatibility with currently   available API versions (e.g. <code>skagents/v1</code>) and, as such, whenever performing   any refactoring, you should ensure that the new functionality is isolated and   does not change anything about existing functionality.</li> <li>The Agent component of Teal Agents is one piece of a much larger overall   platform.  That said, it is also a standalone component.  Since it exposes   agents as APIs, it can run by itself and can be invoked directly, but it's also   common for it to be invoked by \"Orchestrators\" which are different components   which provide multi-agent orchestration capabilities. It's important to keep   this in mind when designing any new feature.</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/","title":"Phase 1 - State Refactoring of Teal Agents - Agent component","text":""},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#objective","title":"Objective","text":"<p>The Agent component of Teal Agents was originally designed to be completely stateless.  Each invocation accepted a list of \"Chat History\" messages which were to contain the entirety of the conversation, thus far. While this would be ideal to maintain, we have reached a point in its evolution where we will have to pivot and begin maintaining state in order to support more complex use cases (e.g. HITL and Authorization for tool use). The purpose of this document is to provide an overview and required context which should be considered while designing the implementation of state for this Agent component.</p> <p>When refactoring, the API version which should act as the base pattern for the new capability should be <code>skagents/v2alpha1</code>. The configuration file structure should remain the same, but the new API version should be called <code>tealagents/v1alpha1</code>.</p>"},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#core-concepts","title":"Core Concepts","text":"<p>To enable stateful agent invocation, we will need to introduce three new concepts in to the agent invocation flow: Session, Task, and Request.</p>"},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#1-session-id-s","title":"1. Session ID (S)","text":"<ul> <li>Purpose: Represents the highest-level grouping, corresponding to a continuous interaction or \"conversation\" with a client.</li> <li>Scope: It logically groups together multiple related tasks initiated by a user. For example, a user's entire interaction with a chatbot for a specific purpose would be one session.</li> <li>Relevance: While not directly used for the internal mechanics of agent/orchestrator state, it provides the essential client-facing context and allows clients to manage and reference logical units of work.</li> <li>Lifecycle: Sessions persist across multiple tasks and can span extended periods of user interaction.</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#2-task-id-t","title":"2. Task ID (T)","text":"<ul> <li>Purpose: Represents a single, stateful \"job\" or goal that the system is asked to accomplish. A task can be simple (a single agent invocation) or complex (an orchestration involving multiple agents and sub-orchestrators).</li> <li>State: This is the lynchpin of the stateful architecture. The state associated with a Task ID must include:<ul> <li>Interaction History: A \"chat history\" or log of all invocations and responses related to the task. This is critical for providing context in follow-on invocations.</li> <li>Execution Trace: A record of the steps taken, tools used, and intermediate results generated.</li> <li>Status: The current state of the task (e.g., <code>Running</code>, <code>Paused</code>, <code>Completed</code>, <code>Failed</code>).</li> <li>User Identity: The unique identifier of the user who created the task for authorization purposes.</li> <li>Timestamps: Creation time, last updated time, and optional expiration time.</li> <li>Metadata: Additional context and configuration data specific to the task.</li> </ul> </li> <li>Lifecycle: A task is created upon the initial invocation and persists until it is fully completed. Follow-on invocations from the client reference the same Task ID to leverage its history and state.</li> <li>Concurrency: Multiple concurrent access attempts to the same task must be handled safely to prevent data corruption.</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#3-request-id-r","title":"3. Request ID (R)","text":"<ul> <li>Purpose: Represents a single, atomic attempt or invocation within a task. It provides the finest level of granularity for tracking and control.</li> <li>Scope: A unique Request ID is generated for each invocation of an agent or orchestrator. All actions performed within that invocation, including tool calls, belong to that single Request ID.</li> <li>Criticality for HITL: The Request ID is the key to enabling HITL. It allows the system to pause not just a general task, but the specific agent invocation that requires human approval. This prevents ambiguity and allows for precise control. When a <code>Resume Handler</code> approves an action, it targets the specific Request ID.</li> <li>Benefits:<ul> <li>Idempotency: If a resume signal is received multiple times, the system can check the status of the Request ID and prevent duplicate execution.</li> <li>Auditing: Provides a detailed, auditable log of every single action taken by the system.</li> <li>Traceability: Links all telemetry and logging data to specific request instances.</li> </ul> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#example-flow","title":"Example Flow","text":""},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#new-request","title":"New Request","text":"<ol> <li>An agent receives a request from either a client or an orchestrator that    may or may not include a \"Session ID\" but which DOES NOT contain a \"Task ID\"</li> <li>If not provided, the agent generates a new \"Session ID\"</li> <li>The agent generates a new \"Task ID\" and a new \"Request ID\"</li> <li>The agent persists the request in its state store with the associated \"Task ID\"</li> <li>The agent builds the appropriate chat history and invokes the LLM</li> <li>The agent receives the response from the LLM and persists this, associated    with the same \"Task ID\". For now we'll focus on getting state implemented    ignore future HITL or authorization requirements.</li> <li>The agent returns the response along with the \"Session ID\", \"Task ID\",    and \"Request ID\" to the client or orchestrator</li> </ol>"},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#follow-on-request","title":"Follow-on Request","text":"<ol> <li>An agent receives a follow-on request from either a client or an orchestrator    that includes a \"Task ID\".</li> <li>The agent generates a new \"Request ID\"</li> <li>The agent verifies that the requesting identity (user) was the same    as the one who initiated the task in the first place (if not, 401).</li> <li>The agent retrieves all associated messages with the provided \"Task ID\",    builds the chat history (including the newly received message), and invokes    the LLM.\"</li> <li>The agent receives the response from the LLM and persists this, associated    with the same \"Task ID\".</li> <li>The agent returns the response along with the \"Session ID\", \"Task ID\",    and \"Request ID\" to the client or orchestrator</li> </ol>"},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#implementation-requirements","title":"Implementation Requirements","text":""},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#application-integration","title":"Application Integration","text":"<ul> <li>The new <code>tealagents/v1alpha1</code> API version should follow the same pattern as existing versions:</li> <li>Create an <code>AppV3</code> class similar to <code>AppV1</code> and <code>AppV2</code></li> <li>Attempt to reuse the existing <code>routes.py</code> <code>get_rest_routes</code> function if possible by passing appropriate configuration values</li> <li>If reuse is not feasible due to authentication requirements and scope of changes, create new route handling logic that maintains existing capabilities (especially telemetry)</li> <li>Exclude websocket routes (<code>get_websocket_routes</code>) from the new version as they are deprecated</li> <li>The main <code>app.py</code> should detect the new API version and route to <code>AppV3</code> accordingly</li> <li>Complete isolation from existing API versions to maintain 100% backward compatibility</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#data-models","title":"Data Models","text":"<ul> <li>Define a new input type called <code>UserMessage</code> which:</li> <li>Does NOT inherit from <code>BaseMultiModalInput</code> but has a similar structure</li> <li>Contains a list of <code>MultiModalItem</code> objects for the current message (text, images, etc.)</li> <li>Removes the <code>chat_history</code> field since history is now managed server-side</li> <li>Optionally accepts \"Session ID\" and \"Task ID\" parameters</li> <li>Includes proper validation for UUID formats and required fields</li> <li>Should look like: <code>{ session_id?, task_id?, items: MultiModalItem[] }</code></li> <li>Implement comprehensive response models that include all state identifiers</li> <li>Define state data models for Session, Task, and Request entities with proper relationships and constraints</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#authentication-and-authorization","title":"Authentication and Authorization","text":"<ul> <li>Implement a robust authentication system using Entra ID app registration:</li> <li>Clients must send authorization tokens with appropriate scopes to access the platform</li> <li>Implement middleware or route-level logic to verify tokens and extract unique user identifiers (OID)</li> <li>Store user identity with persistent tasks for ownership verification</li> <li>Verify user identity on follow-on requests (return 401 if user doesn't match task owner)</li> <li>For initial implementation, abstract this logic and provide mock implementations</li> <li>This authentication requirement may preclude reusing the existing <code>routes.py</code> file</li> <li>Plan follow-up tasks for actual Entra ID integration and token validation</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#configuration-system","title":"Configuration System","text":"<ul> <li>The new API version is indicated by <code>apiVersion: tealagents/v1alpha1</code> in the configuration file</li> <li>Configuration file structure remains the same as existing versions (see <code>demos/ZZ_wikipedia_demo/config.yaml</code>)</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#state-management","title":"State Management","text":"<ul> <li>Abstract out the persistence management to support multiple providers</li> <li>Implement an in-memory persistence provider for initial testing (no need for actual persistent implementation initially)</li> <li>Design for future Redis or DynamoDB implementations</li> <li>Include \"last updated\" timestamps for future cleanup capabilities</li> <li>Do not implement automatic cleanup initially - preserve all task data</li> <li>Handle concurrent access to the same task safely to prevent data corruption</li> <li>State should include sufficient information to rebuild chat history and context</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#error-handling","title":"Error Handling","text":"<ul> <li>Persistence failures should result in 5xx response codes</li> <li>Corrupted or inconsistent state data should cause invocation failures with 5xx responses</li> <li>Implement appropriate timeout handling for long-running operations</li> <li>Consider implementing keepalive mechanisms for SSE streams (similar to previous 30-second dummy events for long LLM calls)</li> <li>Provide comprehensive error messages for debugging and troubleshooting</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#implementation-details","title":"Implementation Details","text":""},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#api-version-detection-and-routing","title":"API Version Detection and Routing","text":"<ul> <li>Define a new logic path for API version <code>tealagents/v1alpha1</code> following the same pattern as earlier API versions</li> <li>The main <code>app.py</code> should detect the new <code>tealagents/v1alpha1</code> API version and route to the appropriate <code>AppV3</code> class</li> <li>Complete isolation ensures this new capability doesn't affect existing functionality</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#usermessage-input-model","title":"UserMessage Input Model","text":"<ul> <li>Create a new <code>UserMessage</code> class that looks similar to <code>BaseMultiModalInput</code> but simplified for single-message input</li> <li>Structure: Contains a list of <code>MultiModalItem</code> objects (content_type and content) for the current message</li> <li>Optional parameters: \"Session ID\" and \"Task ID\" for state management</li> <li>Validation: Proper UUID format validation and required field checks</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#state-aware-handler-implementation","title":"State-Aware Handler Implementation","text":"<ul> <li>Implement a new handler for the new API version that performs state management tasks:</li> <li>Save new state for initial requests</li> <li>Load existing state for follow-on requests</li> <li>Save responses and update state after processing</li> <li>Handle authentication and user identity verification</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-01-state-refactor/#persistence-abstraction","title":"Persistence Abstraction","text":"<ul> <li>Abstract out the persistence management to support multiple persistence providers</li> <li>Implement an in-memory persistence provider for testing and initial development</li> <li>Design interfaces to support future Redis or DynamoDB implementations</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/","title":"Refined State Management Implementation Plan","text":"<p>This plan is based on the practical implementation approach outlined in <code>my-list.md</code> with necessary additions for completeness.</p>"},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#phase-1-core-infrastructure-week-1","title":"Phase 1: Core Infrastructure (Week 1)","text":""},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#1-authorization-infrastructure","title":"1. Authorization Infrastructure","text":"<p>Files to create: - <code>src/sk_agents/authorization/request_authorizer.py</code> - Abstract base class - <code>src/sk_agents/authorization/dummy_authorizer.py</code> - Mock implementation - <code>src/sk_agents/authorization/authorizer_factory.py</code> - Factory implementation</p> <p>Tasks:</p> <ul> <li> Create abstract <code>RequestAuthorizer</code> class:   <pre><code>@abstractmethod\ndef authorize_request(self, auth_header: str) -&gt; str:\n    \"\"\"Returns authorized unique user identifier\"\"\"\n    pass\n</code></pre></li> <li> Implement <code>DummyAuthorizer</code> that always returns 'dummyuser'</li> <li> Create <code>AuthorizerFactory</code> with environment variable configuration:<ul> <li><code>TA_AUTHORIZER_MODULE</code> - Module path for authorizer implementation</li> <li><code>TA_AUTHORIZER_CLASS</code> - Class name for authorizer implementation</li> </ul> </li> <li> Add thread-safe singleton pattern to factory for performance</li> <li> Include comprehensive error handling for import failures and misconfigurations</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#2-persistence-infrastructure","title":"2. Persistence Infrastructure","text":"<p>Files to create:</p> <ul> <li><code>src/sk_agents/persistence/task_persistence_manager.py</code> - Abstract base class</li> <li><code>src/sk_agents/persistence/in_memory_persistence_manager.py</code> - In-memory implementation</li> <li><code>src/sk_agents/persistence/persistence_factory.py</code> - Factory implementation</li> </ul> <p>Tasks:</p> <ul> <li> Create abstract <code>TaskPersistenceManager</code> class with methods:<ul> <li><code>create(task: AgentTask) -&gt; None</code></li> <li><code>load(task_id: str) -&gt; AgentTask | None</code></li> <li><code>update(task: AgentTask) -&gt; None</code></li> <li><code>delete(task_id: str) -&gt; None</code></li> </ul> </li> <li> Implement <code>InMemoryPersistenceManager</code> with thread-safe concurrent access using proper locking mechanisms</li> <li> Create <code>PersistenceFactory</code> with environment variable configuration:<ul> <li><code>TA_PERSISTENCE_MODULE</code> - Module path for persistence implementation</li> <li><code>TA_PERSISTENCE_CLASS</code> - Class name for persistence implementation</li> </ul> </li> <li> Add proper error handling for persistence failures (should result in 5xx responses)</li> <li> Include memory management and monitoring for in-memory implementation</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#3-data-models","title":"3. Data Models","text":"<p>Files to create: - <code>src/sk_agents/tealagents/models.py</code> - All data models for tealagents</p> <p>Tasks:</p> <ul> <li> Create <code>UserMessage</code> model (does NOT inherit from <code>BaseMultiModalInput</code>):   <pre><code>class UserMessage(BaseModel):\n    session_id: str | None = None\n    task_id: str | None = None\n    items: list[MultiModalItem]\n</code></pre></li> <li> Create <code>AgentTaskItem</code> model:   <pre><code>class AgentTaskItem(BaseModel):\n    task_id: str\n    role: Literal[\"user\", \"assistant\"]\n    item: MultiModalItem\n    request_id: str\n    updated: datetime\n</code></pre></li> <li> Create <code>AgentTask</code> model:   <pre><code>class AgentTask(BaseModel):\n    task_id: str\n    session_id: str\n    user_id: str  # Added based on feedback\n    items: list[AgentTaskItem]\n    created_at: datetime\n    last_updated_at: datetime\n    status: Literal[\"Running\", \"Paused\", \"Completed\", \"Failed\"] = \"Running\"\n</code></pre></li> <li> Create new response models that collapse <code>output_raw</code> and <code>output_pydantic</code> to single <code>output</code> field:   <pre><code>class TealAgentsResponse(BaseModel):\n    session_id: str\n    task_id: str\n    request_id: str\n    output: str  # Collapsed from output_raw/output_pydantic\n    # ... all other existing InvokeResponse fields remain\n\nclass TealAgentsPartialResponse(BaseModel):\n    session_id: str\n    task_id: str\n    request_id: str\n    output_partial: str\n    # ... all other existing PartialResponse fields remain\n</code></pre></li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#phase-2-new-api-version-structure-week-2","title":"Phase 2: New API Version Structure (Week 2)","text":""},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#4-module-structure","title":"4. Module Structure","text":"<p>Directories to create:</p> <ul> <li><code>src/sk_agents/tealagents/</code></li> <li><code>src/sk_agents/tealagents/v1alpha1/</code></li> </ul> <p>Files to create:</p> <ul> <li><code>src/sk_agents/tealagents/__init__.py</code> - Top-level handler factory</li> <li><code>src/sk_agents/tealagents/v1alpha1/__init__.py</code> - Version-specific entry point</li> <li><code>src/sk_agents/tealagents/v1alpha1/agent.py</code> - State-aware BaseHandler implementation</li> </ul> <p>Specific isolation requirements:</p> <ul> <li> No imports from <code>skagents</code> modules in <code>tealagents</code> modules</li> <li> No shared mutable state between API versions</li> <li> Separate error handling paths to prevent cross-contamination</li> <li> Independent configuration validation logic</li> <li> Unit tests to verify complete isolation (test that changes to tealagents don't affect skagents behavior)</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#5-handler-implementation","title":"5. Handler Implementation","text":"<p>File: <code>src/sk_agents/tealagents/v1alpha1/agent.py</code></p> <p>Tasks:</p> <ul> <li> Create <code>TealAgentsV1Alpha1Handler</code> class implementing <code>BaseHandler</code></li> <li> Implement <code>invoke</code> method with complete state management flow:<ul> <li>Authorize request using factory-provided authorizer</li> <li>Generate session_id if not provided</li> <li>Generate request_id for this invocation</li> <li>Handle task_id logic (load existing vs create new)</li> <li>Verify user ownership for existing tasks (return 401 if mismatch)</li> <li>Build chat history from stored AgentTaskItem objects</li> <li>Invoke LLM and save response</li> <li>Return TealAgentsResponse with all state identifiers</li> </ul> </li> <li> Implement <code>invoke_stream</code> method with state management:<ul> <li>Same authorization and state loading logic as invoke</li> <li>Stream TealAgentsPartialResponse objects with state identifiers</li> <li>Save final response to task state</li> <li>Include keepalive mechanisms for long-running operations (30-second dummy events)</li> </ul> </li> <li> Add comprehensive error handling with appropriate HTTP status codes</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#phase-3-application-integration-week-3","title":"Phase 3: Application Integration (Week 3)","text":""},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#6-route-integration","title":"6. Route Integration","text":"<p>Files to modify:</p> <ul> <li><code>src/sk_agents/routes.py</code> - Minor updates to support tealagents routing</li> <li><code>src/sk_agents/appv3.py</code> - New application class</li> </ul> <p>Tasks:</p> <ul> <li> Update <code>routes.py</code> to route to tealagents handlers when <code>tealagents</code> is detected as first token in apiVersion</li> <li> Preserve all existing telemetry functionality in route updates</li> <li> Create <code>AppV3</code> class following same pattern as <code>AppV1</code> and <code>AppV2</code>:<ul> <li>Extract configuration information</li> <li>Set up routes using updated <code>routes.py</code> functionality</li> <li>Initialize any tealagents-specific middleware or configuration</li> </ul> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#7-main-application-updates","title":"7. Main Application Updates","text":"<p>Files to modify: - <code>src/sk_agents/app.py</code> - Add AppV3 routing logic</p> <p>Tasks:</p> <ul> <li> Update main application to detect <code>tealagents/v1alpha1</code> apiVersion in configuration:<ul> <li>Split apiVersion on <code>/</code> and check if first token is <code>tealagents</code></li> <li>Route to <code>AppV3</code> when tealagents API version is detected</li> <li>Maintain complete backward compatibility with existing routing logic</li> </ul> </li> <li> Ensure configuration file structure remains identical (reference: <code>demos/ZZ_wikipedia_demo/config.yaml</code>)</li> <li> Add proper error handling for unsupported tealagents versions</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#phase-4-testing-and-validation-week-4","title":"Phase 4: Testing and Validation (Week 4)","text":""},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#8-comprehensive-testing","title":"8. Comprehensive Testing","text":"<p>Test files to create:</p> <ul> <li><code>tests/test_tealagents_handler.py</code></li> <li><code>tests/test_authorization.py</code></li> <li><code>tests/test_persistence.py</code></li> <li><code>tests/test_isolation.py</code></li> </ul> <p>Test scenarios:</p> <ul> <li> Unit tests for all new components with &gt;80% coverage</li> <li> Concurrency tests for thread-safe state access (multiple simultaneous requests to same task)</li> <li> Authorization tests (valid user, invalid user, missing auth header)</li> <li> Persistence failure scenarios (should return 5xx responses)</li> <li> State corruption scenarios (should return 5xx responses)</li> <li> Complete isolation tests (verify tealagents changes don't affect skagents)</li> <li> End-to-end integration tests for complete state flow scenarios</li> <li> SSE streaming tests with state management</li> <li> Performance benchmarks for state operations</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#9-configuration-and-error-handling","title":"9. Configuration and Error Handling","text":"<p>Tasks:</p> <ul> <li> Validate that existing API versions continue to work unchanged:</li> <li><code>skagents/v1</code> (test with <code>demos/03_plugins/config.yaml</code>)</li> <li><code>skagents/v2alpha1</code> (test with <code>demos/10_chat_plugins/config.yaml</code>)</li> <li> Test new API version with <code>tealagents/v1alpha1</code> configuration</li> <li> Verify proper error messages for:<ul> <li>Invalid authorization</li> <li>Persistence failures</li> <li>Task not found</li> <li>User ownership mismatches</li> <li>Configuration errors</li> </ul> </li> <li> Test timeout handling for long-running operations</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#implementation-notes","title":"Implementation Notes","text":""},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#concurrency-safety","title":"Concurrency Safety","text":"<ul> <li>Use proper locking mechanisms in <code>InMemoryPersistenceManager</code></li> <li>Handle race conditions for concurrent access to same task</li> <li>Ensure thread-safe access to shared state throughout the application</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#error-handling-strategy","title":"Error Handling Strategy","text":"<ul> <li>Persistence failures \u2192 5xx responses</li> <li>Authorization failures \u2192 401 responses</li> <li>Task ownership violations \u2192 401 responses</li> <li>Configuration errors \u2192 500 responses with clear messages</li> <li>Invalid task_id \u2192 404 responses</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#sse-streaming-considerations","title":"SSE Streaming Considerations","text":"<ul> <li>Include state identifiers (session_id, task_id, request_id) in each streamed event</li> <li>Update task state during streaming operations</li> <li>Implement keepalive events for long LLM calls (30-second intervals)</li> <li>Handle streaming errors and state recovery gracefully</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Lazy initialization of factories to minimize startup overhead</li> <li>Efficient chat history reconstruction from AgentTaskItem objects</li> <li>Monitor memory usage in InMemoryPersistenceManager</li> <li>Consider connection pooling for future persistent storage implementations</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#future-extensibility","title":"Future Extensibility","text":"<ul> <li>Abstract interfaces support future Redis/DynamoDB implementations</li> <li>Authorization abstraction allows for real Entra ID integration</li> <li>State models include timestamps for future cleanup implementations</li> <li>Response models designed to support future HITL requirements</li> </ul>"},{"location":"planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan/#environment-variables","title":"Environment Variables","text":"<p>New environment variables introduced:</p> <ul> <li><code>TA_AUTHORIZER_MODULE</code> - Module path for authorization implementation</li> <li><code>TA_AUTHORIZER_CLASS</code> - Class name for authorization implementation</li> <li><code>TA_PERSISTENCE_MODULE</code> - Module path for persistence implementation</li> <li><code>TA_PERSISTENCE_CLASS</code> - Class name for persistence implementation</li> </ul> <p>Default values for development:</p> <ul> <li>Authorizer: <code>sk_agents.authorization.dummy_authorizer.DummyAuthorizer</code></li> <li>Persistence: <code>sk_agents.persistence.in_memory_persistence_manager.InMemoryPersistenceManager</code></li> </ul>"},{"location":"planning/2507-state-hitl-auth/02-01-manual-tool-call/","title":"Phase 2 - Refactor for Manual Tool Call","text":"<p>Teal Agents currently leverages Semantic Kernel's in-built functionality to automatically perform agent tool calls. Unfortunately, the library does not include required capability to allow for our code to intercept the tool call message response from the LLM and perform any pre-requisite tasks prior to calling the tool.</p>"},{"location":"planning/2507-state-hitl-auth/02-01-manual-tool-call/#preparation-for-hitl","title":"Preparation for HITL","text":"<p>We need to introduce human-in-the-loop (HITL) functionality wherein, for certain \"high risk\" tool calls, we will pause the current interaction and respond to the calling application with a specially crafted message which will instruct client to prompt the user for explicit consent prior to proceeding with the tool call. To achieve this, we will have to refactor some of the code, \"de-abstracting\" the portion of the Semantic Kernel library where an agent performs tool calls.</p>"},{"location":"planning/2507-state-hitl-auth/02-01-manual-tool-call/#reference-documentation","title":"Reference Documentation","text":"<ul> <li><code>context/teal-agents-overview.md</code> - A reference of the overall structure and   background of the Teal Agents project</li> <li><code>context/state-refactor.md</code> - An overview of work that needs to be done to enable   stateful agent interactions. This work is currently ongoing and as such, this branch   of the code does not reflect any of this capability.</li> <li><code>context/refinde-implementation-plan.md</code> - A detailed plan of how state will be   implemented in the Teal Agents project (the actual work to-be-done based on the   <code>state-refactor.md</code> document).</li> <li><code>context/my-list.md</code> - This was my original plan for the refactoring to include state.   it, along with the <code>state-refactor.md</code> document provided the basis for the work   defined in <code>refined-implementation-plan.md</code>.</li> <li><code>src/sk_agents/skagents/v1/sk_agent.py</code> - This is the specific file in the current   implementation where agents are invoked. Within the file, in the <code>invoke</code> and   <code>invoke_stream</code> methods, the Semantic Kernel library's agent methods are called and   it is within these methods that tool calls are actually performed.</li> <li><code>src/sk_agents/skagents/v1/sk_agent_v2.py</code> - A version of the <code>sk_agent.py</code> file that   I directly refactored, using the Semantic Kernel library as a reference, to move the   tool calling functionality up a level to where Teal Agents would be responsible for   performing the tool calls. This file is not used in the current implementation, it   was just an example of how the refactoring could be done.</li> <li><code>chat_completion_agent.py</code> within the virtual environment - This is the Semantic   Kernel file that contains the tool calling logic.  It was the basis for   <code>sk_agent_v2.py</code></li> </ul>"},{"location":"planning/2507-state-hitl-auth/02-02-manual-tool-call-implementation-plan/","title":"Implementation Plan for Manual Tool Calling (with Code)","text":"<p>This document outlines the plan to refactor the agent invocation process to allow for manual interception of tool calls, as described in <code>context/manual-tool-call.md</code>. This change is a prerequisite for implementing Human-in-the-Loop (HITL) functionality.</p> <p>The implementation will follow the \"de-abstracted\" pattern prototyped in <code>src/sk_agents/skagents/v1/sk_agent_v2.py</code> and will be integrated into the new stateful API version <code>tealagents/v1alpha1</code>.</p>"},{"location":"planning/2507-state-hitl-auth/02-02-manual-tool-call-implementation-plan/#1-high-level-strategy","title":"1. High-Level Strategy","text":"<p>We will replace the high-level <code>agent.invoke()</code> and <code>agent.invoke_stream()</code> calls with a manual orchestration of the LLM interaction within our <code>Agent</code>. This provides a clear interception point to inspect tool calls before they are executed.</p>"},{"location":"planning/2507-state-hitl-auth/02-02-manual-tool-call-implementation-plan/#2-new-hitl-placeholder-module","title":"2. New HITL Placeholder Module","text":"<p>A new placeholder module will be created to establish a clean interception point for future HITL logic.</p> <p>File to Create: <code>src/sk_agents/tealagents/v1alpha1/hitl_manager.py</code></p> <pre><code># src/sk_agents/tealagents/v1alpha1/hitl_manager.py\nfrom semantic_kernel.contents.function_call_content import FunctionCallContent\n\ndef check_for_intervention(tool_call: FunctionCallContent) -&gt; bool:\n    \"\"\"\n    Placeholder for HITL logic. In the future, this will check\n    if the tool call requires user consent based on configured policies.\n\n    Returns False for now, allowing all calls to proceed without interruption.\n    \"\"\"\n    # TODO: Implement actual policy checks for high-risk tools.\n    print(f\"HITL Check: Intercepted call to {tool_call.plugin_name}.{tool_call.function_name}. Allowing to proceed.\")\n    return False\n</code></pre>"},{"location":"planning/2507-state-hitl-auth/02-02-manual-tool-call-implementation-plan/#3-refactoring-the-agent-handler","title":"3. Refactoring the Agent Handler","text":"<p>The core changes will be in the <code>Agent</code>.</p> <p>File to Modify: <code>src/sk_agents/tealagents/v1alpha1/agent.py</code></p>"},{"location":"planning/2507-state-hitl-auth/02-02-manual-tool-call-implementation-plan/#31-add-imports-and-helper-method","title":"3.1. Add Imports and Helper Method","text":"<p>We will add necessary imports and the <code>_invoke_function</code> helper method, adapted directly from <code>sk_agent_v2.py</code>.</p> <pre><code># Add to imports at the top of src/sk_agents/tealagents/v1alpha1/agent.py\nimport asyncio\nfrom functools import reduce\n\nfrom semantic_kernel.connectors.ai.chat_completion_client_base import ChatCompletionClientBase\nfrom semantic_kernel.contents.function_call_content import FunctionCallContent\nfrom semantic_kernel.contents.function_result_content import FunctionResultContent\nfrom semantic_kernel.contents.streaming_chat_message_content import StreamingChatMessageContent\n\n# Import the new HITL placeholder\nfrom sk_agents.hitl import hitl_manager\n\n# ... existing class definition for Agent ...\n\n    # Add this helper method inside the TealAgentsV1Alpha1Handler class\n    async def _invoke_function(self, kernel: \"Kernel\", fc_content: FunctionCallContent) -&gt; FunctionResultContent:\n        \"\"\"Helper to execute a single tool function call.\"\"\"\n        function = kernel.get_function(\n            fc_content.plugin_name,\n            fc_content.function_name,\n        )\n        function_result = await function(kernel, fc_content.to_kernel_arguments())\n        return FunctionResultContent.from_function_call_content_and_result(\n            fc_content, function_result\n        )\n</code></pre>"},{"location":"planning/2507-state-hitl-auth/02-02-manual-tool-call-implementation-plan/#32-updated-invoke-method-non-streaming","title":"3.2. Updated <code>invoke</code> Method (Non-Streaming)","text":"<p>The <code>invoke</code> method will be replaced with the following code to manually handle the tool-calling loop.</p> <pre><code># Replace the existing 'invoke' method in TealAgentsV1Alpha1Handler\nasync def invoke(self, history: ChatHistory) -&gt; AsyncIterable[ChatMessageContent]:\n    kernel = self.agent.kernel\n    arguments = self.agent.arguments\n    chat_completion_service, settings = kernel.select_ai_service(\n        arguments=arguments, type=ChatCompletionClientBase\n    )\n    assert isinstance(chat_completion_service, ChatCompletionClientBase)\n\n    # Initial call to the LLM\n    response_list = await chat_completion_service.get_chat_message_contents(\n        chat_history=history,\n        settings=settings,\n        kernel=kernel,\n        arguments=arguments,\n    )\n\n    function_calls = []\n    # Separate content and tool calls\n    for response in response_list:\n        # A response may have multiple items, e.g., multiple tool calls\n        fc_in_response = [item for item in response.items if isinstance(item, FunctionCallContent)]\n\n        if fc_in_response:\n            history.add_message(response) # Add assistant's message to history\n            function_calls.extend(fc_in_response)\n        else:\n            # If no function calls, it's a direct answer\n            yield response\n\n    # If tool calls were returned, execute them\n    if function_calls:\n        # --- INTERCEPTION POINT ---\n        for fc in function_calls:\n            hitl_manager.check_for_intervention(fc)\n            # In the future, a `True` return would trigger a pause flow.\n\n        # Execute all functions in parallel\n        results = await asyncio.gather(\n            *[self._invoke_function(kernel, fc) for fc in function_calls]\n        )\n\n        # Add results to history\n        for result in results:\n            history.add_message(result.to_chat_message_content())\n\n        # Make a recursive call to get the final response from the LLM\n        async for final_response in self.invoke(history):\n            yield final_response\n</code></pre>"},{"location":"planning/2507-state-hitl-auth/02-02-manual-tool-call-implementation-plan/#33-updated-invoke_stream-method-streaming","title":"3.3. Updated <code>invoke_stream</code> Method (Streaming)","text":"<p>The <code>invoke_stream</code> method will be replaced to handle streaming and tool calls correctly.</p> <pre><code># Replace the existing 'invoke_stream' method in TealAgentsV1Alpha1Handler\nasync def invoke_stream(self, history: ChatHistory) -&gt; AsyncIterable[StreamingChatMessageContent]:\n    kernel = self.agent.kernel\n    arguments = self.agent.arguments\n    chat_completion_service, settings = kernel.select_ai_service(\n        arguments=arguments, type=ChatCompletionClientBase\n    )\n    assert isinstance(chat_completion_service, ChatCompletionClientBase)\n\n    all_responses = []\n    # Stream the initial response from the LLM\n    async for response_list in chat_completion_service.get_streaming_chat_message_contents(\n        chat_history=history,\n        settings=settings,\n        kernel=kernel,\n        arguments=arguments,\n    ):\n        for response in response_list:\n            all_responses.append(response)\n            if response.content:\n                yield response # Yield content chunks to the client immediately\n\n    # Aggregate the full response to check for tool calls\n    if not all_responses:\n        return\n\n    full_completion: StreamingChatMessageContent = reduce(lambda x, y: x + y, all_responses)\n    function_calls = [\n        item\n        for item in full_completion.items\n        if isinstance(item, FunctionCallContent)\n    ]\n\n    # If tool calls are present, execute them\n    if function_calls:\n        history.add_message(message=full_completion.to_chat_message_content())\n\n        # --- INTERCEPTION POINT ---\n        for fc in function_calls:\n            hitl_manager.check_for_intervention(fc)\n\n        # Execute functions in parallel\n        results = await asyncio.gather(\n            *[self._invoke_function(kernel, fc) for fc in function_calls]\n        )\n\n        # Add results to history\n        for result in results:\n            history.add_message(result.to_chat_message_content())\n\n        # Make a recursive call to get the final streamed response\n        async for final_response_chunk in self.invoke_stream(history):\n            yield final_response_chunk\n</code></pre>"},{"location":"planning/2507-state-hitl-auth/02-02-manual-tool-call-implementation-plan/#4-testing-strategy","title":"4. Testing Strategy","text":"<p>The testing strategy remains the same as the previous plan, but the tests in <code>tests/test_tealagents_handler.py</code> will now be written against this specific implementation, verifying:</p> <ol> <li>Simple chat works without regression.</li> <li>Tool calls are correctly identified and executed.</li> <li>The <code>hitl_manager.check_for_intervention</code> function is called for each tool invocation.</li> <li>The final response after tool execution is correct for both streaming and non-streaming modes.</li> </ol>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/","title":"Application State After Phases 1 &amp; 2: Foundation for Human-in-the-Loop Implementation","text":"<p>This document provides a comprehensive overview of the application state after completing Phases 1 and 2, as described in <code>01-02-state-refactor-implementation-plan.md</code> and <code>02-02-manual-tool-call-implementation-plan.md</code>. This overview is intended to support Phase 3 planning, which will introduce Human-in-the-Loop (HITL) functionality for selected tool calls.</p>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#new-infrastructure-components","title":"New Infrastructure Components","text":""},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#authorization-system","title":"Authorization System","text":"<p>The application now includes a pluggable authorization system:</p> <ul> <li><code>src/sk_agents/authorization/</code> module - Complete authorization infrastructure</li> <li><code>RequestAuthorizer</code> - Abstract base class requiring <code>authorize_request(auth_header: str) -&gt; str</code></li> <li><code>DummyAuthorizer</code> - Development implementation returning 'dummyuser' for all requests</li> <li><code>AuthorizerFactory</code> - Thread-safe singleton factory with environment variable configuration<ul> <li><code>TA_AUTHORIZER_MODULE</code> - Module path for authorization implementation</li> <li><code>TA_AUTHORIZER_CLASS</code> - Class name for authorization implementation</li> </ul> </li> <li>Error handling - Comprehensive handling for import failures and misconfigurations</li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#persistence-system","title":"Persistence System","text":"<p>A pluggable state storage system is now available:</p> <ul> <li><code>src/sk_agents/persistence/</code> module - Complete persistence infrastructure</li> <li><code>TaskPersistenceManager</code> - Abstract base class with CRUD operations for <code>AgentTask</code> objects<ul> <li><code>create(task: AgentTask) -&gt; None</code></li> <li><code>load(task_id: str) -&gt; AgentTask | None</code></li> <li><code>update(task: AgentTask) -&gt; None</code></li> <li><code>delete(task_id: str) -&gt; None</code></li> </ul> </li> <li><code>InMemoryPersistenceManager</code> - Thread-safe in-memory implementation with proper locking</li> <li><code>PersistenceFactory</code> - Environment variable configuration<ul> <li><code>TA_PERSISTENCE_MODULE</code> - Module path for persistence implementation</li> <li><code>TA_PERSISTENCE_CLASS</code> - Class name for persistence implementation</li> </ul> </li> <li>Error handling - Persistence failures result in 5xx responses</li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#state-models","title":"State Models","text":"<p>New data models support complete conversation state management:</p> <ul> <li><code>AgentTask</code> - Core state container with:<ul> <li><code>task_id</code>, <code>session_id</code>, <code>user_id</code> for identification</li> <li><code>items: list[AgentTaskItem]</code> for conversation history</li> <li><code>created_at</code>, <code>last_updated_at</code> timestamps</li> <li><code>status: Literal[\"Running\", \"Paused\", \"Completed\", \"Failed\"]</code> for state tracking</li> </ul> </li> <li><code>AgentTaskItem</code> - Individual conversation entries with:<ul> <li><code>role: Literal[\"user\", \"assistant\"]</code> for message attribution</li> <li><code>item: MultiModalItem</code> for content</li> <li><code>request_id: str</code> for tracking individual requests</li> <li><code>updated: datetime</code> for chronological ordering</li> </ul> </li> <li><code>UserMessage</code> - Input model with optional state identifiers:<ul> <li><code>session_id: str | None</code> for session continuity</li> <li><code>task_id: str | None</code> for task resumption</li> <li><code>items: list[MultiModalItem]</code> for multimodal content</li> </ul> </li> <li><code>TealAgentsResponse</code>/<code>TealAgentsPartialResponse</code> - Response models with:<ul> <li><code>session_id</code>, <code>task_id</code>, <code>request_id</code> for complete state tracking</li> <li><code>output</code> field (collapsed from previous <code>output_raw</code>/<code>output_pydantic</code>)</li> <li>All existing response fields preserved</li> </ul> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#new-api-architecture","title":"New API Architecture","text":""},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#module-structure","title":"Module Structure","text":"<p>A completely isolated API version has been created:</p> <ul> <li><code>src/sk_agents/tealagents/</code> - Top-level module, completely isolated from <code>skagents</code></li> <li><code>src/sk_agents/tealagents/v1alpha1/</code> - Version-specific implementation</li> <li><code>src/sk_agents/tealagents/v1alpha1/handler.py</code> - Core handler implementation</li> <li><code>src/sk_agents/tealagents/v1alpha1/agent.py</code> - LLM interaction and tool call</li> <li>Isolation requirements:<ul> <li>No imports from <code>skagents</code> modules in <code>tealagents</code> modules</li> <li>No shared mutable state between API versions</li> <li>Separate error handling paths to prevent cross-contamination</li> <li>Independent configuration validation logic</li> </ul> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#routing-integration","title":"Routing Integration","text":"<p>The application routing has been extended to support the new API:</p> <ul> <li>Updated <code>routes.py</code> - Detects <code>tealagents</code> as first token in <code>apiVersion</code></li> <li>New <code>AppV3</code> class - Follows existing <code>AppV1</code>/<code>AppV2</code> patterns</li> <li>Main <code>app.py</code> - Routes <code>tealagents/v1alpha1</code> configurations to <code>AppV3</code></li> <li>Backward compatibility - All existing API versions continue to work unchanged</li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#tool-call-interception-architecture","title":"Tool Call Interception Architecture","text":""},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#hitl-foundation","title":"HITL Foundation","text":"<p>The groundwork for Human-in-the-Loop functionality has been established:</p> <ul> <li><code>src/sk_agents/hitl/hitl_manager.py</code> - Placeholder module with interception point</li> <li><code>check_for_intervention(tool_call: FunctionCallContent) -&gt; bool</code> - Core interception function<ul> <li>Currently returns <code>False</code> (no intervention) for all tool calls</li> <li>Establishes the exact point where HITL logic will be implemented</li> <li>Receives complete <code>FunctionCallContent</code> objects for inspection</li> </ul> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#manual-tool-orchestration","title":"Manual Tool Orchestration","text":"<p>The <code>Agent</code> (<code>src/sk_agents/tealagents/v1alpha1/agent.py</code>) implements the tool invocation loop:</p> <ul> <li>Direct LLM interaction - Uses <code>ChatCompletionClientBase</code> instead of high-level agent methods</li> <li>Manual tool extraction - Extracts <code>FunctionCallContent</code> objects from LLM responses</li> <li>Clear interception point - Each tool call is individually passed to <code>hitl_manager.check_for_intervention()</code></li> <li>Parallel execution - Approved tool calls are executed via <code>asyncio.gather()</code></li> <li>Recursive handling - Supports multi-turn tool calling scenarios</li> <li>Streaming support - Both <code>invoke()</code> and <code>invoke_stream()</code> methods have identical interception logic</li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#state-management-flow","title":"State Management Flow","text":""},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#request-processing-pipeline","title":"Request Processing Pipeline","text":"<p>The <code>TealAgentsV1Alpha1Handler</code> (<code>src/sk_agents/tealagents/v1alpha1/handler.py</code>) processes requests with a clear state management flow:</p> <ol> <li>Authorization - Via pluggable authorizer (extracts <code>user_id</code>)</li> <li>Session/Task ID handling - Generation or validation of state identifiers</li> <li>User ownership verification - Existing tasks checked for user ownership</li> <li>Chat history reconstruction - Built from persisted <code>AgentTaskItem</code> objects</li> <li>Agent invocation - Invoke agent with appropriate chat history</li> <li>State persistence - After each interaction</li> <li>Response generation - With complete state identifiers</li> </ol>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#concurrency-error-handling","title":"Concurrency &amp; Error Handling","text":"<p>Robust error handling and concurrency support:</p> <ul> <li>Thread-safe state access - Proper locking mechanisms in persistence layer</li> <li>Comprehensive error responses:<ul> <li>401 for authorization failures</li> <li>404 for missing tasks</li> <li>5xx for persistence failures</li> </ul> </li> <li>Streaming support - State management with keepalive mechanisms</li> <li>Race condition handling - Concurrent access to same task properly managed</li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#key-architectural-decisions-for-phase-3","title":"Key Architectural Decisions for Phase 3","text":""},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#tool-call-interception-points","title":"Tool Call Interception Points","text":"<p>The architecture provides clear interception capabilities:</p> <ul> <li>Identical interception logic - Both <code>invoke()</code> and <code>invoke_stream()</code> methods have the same interception flow</li> <li>Pre-execution inspection - Tool calls are extracted and inspected before execution</li> <li>Individual tool processing - Each <code>FunctionCallContent</code> object is individually passed to the interception function</li> <li>Execution control - The interception point can prevent tool execution (currently always allows)</li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#state-persistence-capabilities","title":"State Persistence Capabilities","text":"<p>Complete state management for paused/resumed operations:</p> <ul> <li>Full conversation history - Maintained in <code>AgentTask.items</code> with chronological ordering</li> <li>Unique request tracking - Each interaction has a unique <code>request_id</code></li> <li>Pause support - Task status field supports \"Paused\" state (designed for HITL)</li> <li>Timestamp tracking - All state objects include timestamps for timeout/cleanup logic</li> <li>User association - All tasks are associated with specific users for authorization</li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#response-model-design","title":"Response Model Design","text":"<p>Response models are designed to support HITL workflows:</p> <ul> <li>State identifier inclusion - All responses include <code>session_id</code>, <code>task_id</code>, <code>request_id</code></li> <li>Streaming consistency - State identifiers maintained throughout streaming responses</li> <li>Extensibility - Response models designed to support future HITL-specific fields</li> <li>Client tracking - State identifiers allow clients to track and respond to approval requests</li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#hitl-implementation-ready-points","title":"HITL Implementation Ready Points","text":"<p>The architecture establishes the following foundation for Phase 3 HITL implementation:</p>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#1-tool-call-interception","title":"1. Tool Call Interception","text":"<ul> <li><code>hitl_manager.check_for_intervention()</code> - Ready to implement policy-based tool approval</li> <li>Complete tool context - <code>FunctionCallContent</code> objects provide full tool information</li> <li>Execution control - Return <code>True</code> to block tool execution</li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#2-state-persistence-for-paused-tasks","title":"2. State Persistence for Paused Tasks","text":"<ul> <li>Task pausing - Change <code>AgentTask.status</code> to \"Paused\"</li> <li>Conversation state - Complete chat history preserved for resumption</li> <li>User context - User authorization preserved for approval requests</li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#3-response-mechanisms","title":"3. Response Mechanisms","text":"<ul> <li>State tracking - Response models include all necessary identifiers</li> <li>Client communication - Mechanisms exist to inform clients of approval requirements</li> <li>Resumption support - Task can be resumed with <code>request_id</code> in subsequent requests</li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#4-authorization-integration","title":"4. Authorization Integration","text":"<ul> <li>User identification - Every request tied to specific user</li> <li>Approval tracking - Tool approval requests can be associated with users</li> <li>Security - User ownership verification prevents unauthorized task access</li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#environment-variables","title":"Environment Variables","text":"<p>New environment variables introduced:</p> <ul> <li><code>TA_AUTHORIZER_MODULE</code> - Module path for authorization implementation</li> <li><code>TA_AUTHORIZER_CLASS</code> - Class name for authorization implementation</li> <li><code>TA_PERSISTENCE_MODULE</code> - Module path for persistence implementation</li> <li><code>TA_PERSISTENCE_CLASS</code> - Class name for persistence implementation</li> </ul> <p>Default values for development:</p> <ul> <li>Authorizer: <code>sk_agents.authorization.dummy_authorizer.DummyAuthorizer</code></li> <li>Persistence: <code>sk_agents.persistence.in_memory_persistence_manager.InMemoryPersistenceManager</code></li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#backward-compatibility","title":"Backward Compatibility","text":"<p>The application maintains complete backward compatibility:</p> <ul> <li>Existing APIs unchanged - <code>skagents/v1</code> and <code>skagents/v2alpha1</code> continue to work</li> <li>No shared state - New <code>tealagents</code> API is completely isolated</li> <li>Configuration compatibility - Existing configuration files continue to work</li> <li>Telemetry preservation - All existing telemetry functionality maintained</li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-01-hitl-baseline/#summary","title":"Summary","text":"<p>After Phases 1 and 2, the application provides a complete foundation for Human-in-the-Loop implementation with:</p> <ol> <li>Authorization infrastructure - User identification and request authorization</li> <li>State persistence - Complete conversation state management with pause/resume capability</li> <li>Tool call interception - Clear points for inspecting and controlling tool execution</li> <li>Response mechanisms - State tracking and client communication capabilities</li> <li>Isolation - New functionality completely isolated from existing APIs</li> </ol> <p>The <code>tealagents/v1alpha1</code> API path now provides stateful, interceptable agent interactions while maintaining complete backward compatibility with existing functionality. Phase 3 can build upon this foundation to implement Human-in-the-Loop approval workflows for selected tool calls.</p>"},{"location":"planning/2507-state-hitl-auth/03-02-hitl/","title":"Phase 3 - Humaan-in-the-Loop (HITL)","text":""},{"location":"planning/2507-state-hitl-auth/03-02-hitl/#overview","title":"Overview","text":"<p>In phase 3, we will introduce the capability to pause the execution of an agent task, when certain \"high risk\" tools are identified for use, and require human intervention prior to proceeding. Achieving this relies on changes made in phases 1 and 2.</p>"},{"location":"planning/2507-state-hitl-auth/03-02-hitl/#phase-3-resulting-flow","title":"Phase 3 Resulting Flow","text":"<p>For tool calls identified as \"high risk\", instead of directly executing these calls, the application will need to:</p> <ol> <li>Save the relevant tool call details such that they can be resumed after human    intervention (this should probably be in the task item which might require extension    of its structure).</li> <li>Place the task in to a paused state</li> <li>Respond with a payload indicating the call or calls which triggered the HITL    requirement as well as a URL, referencing the appropriate request ID(s), which can    be invoked to \"Approve\" or \"Reject\" the call(s).</li> </ol> <p>Upon receipt of this new response, the client (not considered here) will be responsible for prompting the user for approval or rejection of the tool call(s).</p> <p>If the tool call(s) is/are approved, the application will need to resume immediately, from the point of the tool call(s) and proceed as normal (this might require an alternate logic path to reach the handler and/or agent invocation).</p> <p>If the tool call(s) is/are rejected, the application should place the task in to a canceled state and respond with a payload indicating as such.</p> <p>Approvals and rejections should be recorded somewhere in a persistence layer.</p>"},{"location":"planning/2507-state-hitl-auth/03-02-hitl/#additional-non-functional-requirements","title":"Additional Non-Functional Requirements","text":"<ul> <li>Keep the definition of the approval/rejection endpoint flexible. We will be   introducing additional functionality in subsequent phases which will allow tasks to be   paused in cases where the user need to perform authentication or grant consent in   order for tool calls to proceed. It would be ideal if this single \"resume\" endpoint   could be used for these cases, as well.</li> <li>The \"resume\" endpoint should leverage the <code>request_id</code> in the URL to identify which   tool call(s) task is being resumed/canceled. There is no need to include <code>session_id</code>   or <code>task_id</code> as the request ID, alone, would uniquely identify the task/invocation   which requires HITL.</li> <li>User authorization will need to be included in the resume endpoint, and it should be   validated that the user calling the endpoint is the same user who initiated the task.</li> <li>The determination of a tool's \"risk level\" can be left out of scope for this planning.   Just assume the <code>check_for_intervention</code> placeholder will determine handle this logic.</li> <li>The payload to-be-sent indicating that tool use approvals are required can be a   completely new model object. The existing response objects should not be extended to   support this new functionality.</li> <li>I believe we'll have to know the exact structure of the tool call responses from the   LLMs in order to determine exactly how we'll need to extend <code>AgentTaskItem</code> to   accommodate the persistence of the tool call details. For this reason, don't be   specific about exactly how to persist this, just indicate that it will need to be   persisted in <code>AgentTaskItem</code>.</li> <li>The \"resume\" endpoint will either approve or reject ALL tool calls for a given   <code>request_id</code>. We will not support partial approvals or rejections.</li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-03-hitl-implementation-plan/","title":"Phase 3 Implementation Plan: Human-in-the-Loop (HITL)","text":"<p>This document outlines the development tasks required to implement the Human-in-the-Loop (HITL) functionality as described in <code>03-02-hitl.md</code>, building upon the foundational architecture established in Phases 1 and 2.</p>"},{"location":"planning/2507-state-hitl-auth/03-03-hitl-implementation-plan/#task-1-extend-state-models-for-hitl","title":"Task 1: Extend State Models for HITL","text":"<p>Objective: Update the core data models to support paused states, pending tool calls, and a new response type for HITL interventions.</p> <ul> <li>File: <code>src/sk_agents/ska_types.py</code></li> <li> <p>Changes:</p> <p>1.Modify <code>AgentTaskItem</code>: Add an optional field to store tool calls that are pending approval.     <pre><code># In AgentTaskItem class\npending_tool_calls: list[dict] | None = None # Store serialized FunctionCallContent\n</code></pre> 2.Modify <code>AgentTask</code>: Add a \"Canceled\" status to the <code>status</code> literal to handle rejections.     <pre><code># In AgentTask class\nstatus: Literal[\"Running\", \"Paused\", \"Completed\", \"Failed\", \"Canceled\"]\n</code></pre> 3.Create <code>HitlResponse</code> Model: Define a new Pydantic model for the response sent to the client when an intervention is required.     <code>python     class HitlResponse(BaseModel):         task_id: str         session_id: str         request_id: str         message: str = \"Human intervention required.\"         approval_url: str         rejection_url: str         tool_calls: list[dict] # Serialized FunctionCallContent</code></p> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-03-hitl-implementation-plan/#task-2-implement-persistence-layer-extension","title":"Task 2: Implement Persistence Layer Extension","text":"<p>Objective: Enable the retrieval of tasks using a <code>request_id</code> to support the resume endpoint.</p> <ul> <li>Files:<ul> <li><code>src/sk_agents/persistence/task_persistence_manager.py</code></li> <li><code>src/sk_agents/persistence/in_memory_persistence_manager.py</code></li> </ul> </li> <li>Changes:<ol> <li>Update <code>TaskPersistenceManager</code> ABC: Add a new abstract method to find a task by <code>request_id</code>.     <pre><code>@abstractmethod\ndef load_by_request_id(self, request_id: str) -&gt; AgentTask | None:\n    ...\n</code></pre></li> <li>Implement in <code>InMemoryPersistenceManager</code>: Implement the new method. This will likely require creating a new index (dictionary) to map <code>request_id</code> to <code>task_id</code>. Ensure this index is properly maintained with thread-safe locks.</li> </ol> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-03-hitl-implementation-plan/#task-3-implement-hitl-trigger-and-pause-logic","title":"Task 3: Implement HITL Trigger and Pause Logic","text":"<p>Objective: Modify the agent and handler to detect when an intervention is needed, pause the task, and persist the state.</p> <ul> <li>Files:<ul> <li><code>src/sk_agents/hitl/hitl_manager.py</code></li> <li><code>src/sk_agents/tealagents/v1alpha1/agent.py</code></li> <li><code>src/sk_agents/tealagents/v1alpha1/handler.py</code></li> </ul> </li> <li>Changes:<ol> <li>Update <code>hitl_manager.py</code>: For now, hardcode <code>check_for_intervention</code> to return <code>True</code> if a tool call's name matches a predefined \"high-risk\" tool (e.g., <code>ShellCommand</code>).</li> <li>Create Custom Exception: Define a custom exception, e.g., <code>HitlInterventionRequired(Exception)</code>, to signal the need for HITL from the agent to the handler.</li> <li>Modify <code>agent.py</code>: In <code>invoke()</code> and <code>invoke_stream()</code>, after extracting tool calls, iterate through them. If <code>check_for_intervention()</code> returns <code>True</code> for any of them, raise <code>HitlInterventionRequired</code> with the list of all tool calls from the LLM's response.</li> <li>Modify <code>handler.py</code>:         - Wrap the <code>agent.invoke()</code> call in a <code>try...except HitlInterventionRequired</code> block.         - In the <code>except</code> block:             - Set <code>AgentTask.status</code> to <code>\"Paused\"</code>.             - Create a new <code>AgentTaskItem</code> for the assistant's turn, storing the pending tool calls from the exception into the new <code>pending_tool_calls</code> field.             - Persist the updated <code>AgentTask</code> using the <code>persistence_manager</code>.             - Construct and return the <code>HitlResponse</code>, generating the appropriate approval and rejection URLs (e.g., <code>/tealagents/v1alpha1/resume/{request_id}</code>).</li> </ol> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-03-hitl-implementation-plan/#task-4-create-the-hitl-resume-endpoint","title":"Task 4: Create the HITL Resume Endpoint","text":"<p>Objective: Create a new API endpoint that the client can call to approve or reject a paused tool call.</p> <ul> <li>Files:<ul> <li><code>src/sk_agents/routes.py</code></li> <li><code>src/sk_agents/app.py</code></li> <li><code>src/sk_agents/tealagents/v1alpha1/handler.py</code> (or a new <code>resume_handler.py</code>)</li> </ul> </li> <li>Changes:<ol> <li>Define Route in <code>routes.py</code>: Add a new <code>POST</code> route, e.g., <code>/tealagents/v1alpha1/resume/{request_id}</code>.</li> <li>Create Resume Handler: Implement a new handler function for this route. This function will accept the <code>request_id</code> from the URL and a simple JSON body like <code>{\"action\": \"approve\"}</code> or <code>{\"action\": \"reject\"}</code>.</li> <li>Integrate in <code>app.py</code>: Wire the new route to the new handler function in the <code>AppV3</code> class.</li> </ol> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-03-hitl-implementation-plan/#task-5-implement-resume-and-rejection-logic","title":"Task 5: Implement Resume and Rejection Logic","text":"<p>Objective: Implement the core logic within the resume handler to either continue execution or cancel the task.</p> <ul> <li>File: <code>src/sk_agents/tealagents/v1alpha1/handler.py</code> (or the new resume handler file)</li> <li>Changes:<ol> <li>Authorization: The request must go through the <code>RequestAuthorizer</code> to get the <code>user_id</code>.</li> <li>Load Task: Use the new <code>persistence_manager.load_by_request_id()</code> method to fetch the <code>AgentTask</code>.</li> <li>Validation:<ul> <li>If the task is not found, return 404.</li> <li>Verify the <code>user_id</code> from the authorizer matches the <code>task.user_id</code>. If not, return 403 Forbidden.</li> <li>Verify the task status is \"Paused\". If not, return 409 Conflict.</li> </ul> </li> <li>Handle Rejection (<code>action == \"reject\"</code>):<ul> <li>Update the <code>AgentTask.status</code> to <code>\"Canceled\"</code>.</li> <li>Add an <code>AgentTaskItem</code> to the history logging the rejection.</li> <li>Persist the task.</li> <li>Return a confirmation response to the client.</li> </ul> </li> <li>Handle Approval (<code>action == \"approve\"</code>):<ul> <li>This is the most complex part, creating a new execution path.</li> <li>Retrieve the <code>pending_tool_calls</code> from the last <code>AgentTaskItem</code>.</li> <li>Execute the tool calls using <code>asyncio.gather()</code>, just as the agent would have.</li> <li>Create <code>ToolContent</code> objects from the results.</li> <li>Add the <code>AgentTaskItem</code> with the <code>pending_tool_calls</code> and a new <code>AgentTaskItem</code> with the <code>ToolContent</code> results to the chat history.</li> <li>Update the <code>AgentTask.status</code> to <code>\"Running\"</code>.</li> <li>Invoke the agent again with the updated chat history to get the final response from the LLM.</li> <li>Persist the final state (<code>AgentTask</code> and new <code>AgentTaskItem</code>s).</li> <li>Return the final <code>TealAgentsResponse</code> to the client.</li> </ul> </li> </ol> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-03-hitl-implementation-plan/#task-6-record-approvalrejection","title":"Task 6: Record Approval/Rejection","text":"<p>Objective: Ensure that the approval or rejection action is explicitly recorded in the task's history.</p> <ul> <li>File: <code>src/sk_agents/tealagents/v1alpha1/handler.py</code> (or the new resume handler file)</li> <li>Changes:<ol> <li>When handling an approval or rejection, create a new <code>AgentTaskItem</code> that explicitly records the action.</li> <li>For approvals, this could be an item with <code>role: \"user\"</code> and content like <code>{\"action\": \"approve\", \"request_id\": \"...\"}</code>.</li> <li>For rejections, a similar item should be added before setting the state to \"Canceled\".</li> <li>This provides a clear audit trail within the conversation history.</li> </ol> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/03-prompt/","title":"03 prompt","text":"<p>Based on the current state of this project and assuming that changes will be made to achieve the baseline state described in <code>04-01-hitl-baseline.md</code>, create a set of tasks which, when completed will introduce the functionality described in <code>04-02-hitl.md</code>. Save this implementation plan in to a new file called <code>04-03-hitl-implementation-plan-claude.md</code> in the <code>planning/2507-state-hitl-auth</code> directory.</p>"},{"location":"planning/2507-state-hitl-auth/04-01-tool-catalog/","title":"Phase 4 - Plugin Catalog","text":"<p>In this phase, we will introduce the concept of a plugin catalog.</p>"},{"location":"planning/2507-state-hitl-auth/04-01-tool-catalog/#overview","title":"Overview","text":"<p>While we have not yet landed on the technology to use, we will need to continue forward with the design and integration of the concept of a plugin catalog to allow us to move forward with HITL and authorization. The plugin catalog will be the centralized repository for tools made available to agents, and will provide a set of metadata for each tool that can be used to determine things like which authorization server and scopes are required for a particular tool invocation and whether a specific tool requires HITL confirmation prior to execution.</p> <p>Since no decision has been reached on an actual implementation technology, we will proceed with establishing an abstraction layer which, for the time being, will require manual configuration of available tools.</p>"},{"location":"planning/2507-state-hitl-auth/04-01-tool-catalog/#abstraction-layer-design","title":"Abstraction Layer Design","text":"<p>The Plugin concept can be represented as the following:</p> <pre><code>class PluginType(BaseModel):\n    type_name: Literal[\"code\", \"mcp\"]\n\nclass Governance(BaseModel):\n    requires_hitl: bool\n    cost: Literal[\"low\", \"medium\", \"high\"]\n    data_sensitivity: Literal[\"public\", \"proprietary\", \"confidential\", \"sensitive\"]\n\nclass PluginAuth(BaseModel):\n    auth_type: Literal[\"oauth2\"]\n\nclass Oauth2PluginAuth(PluginAuth):\n    auth_server: str\n    scopes: List[str]\n\nclass PluginTool(BaseModel):\n    tool_id: str\n    name: str\n    description: str\n    governance: Governance\n\nclass Plugin(BaseModel):\n    plugin_id: str\n    name: str\n    description: str\n    version: str\n    owner: str\n    plugin_type: Type[PluginType]\n    auth: Type[PluginAuth] | None\n    tools: List[PluginTool]\n</code></pre> <p><code>PluginType</code> will be a base class for the different types of plugins available. Currently, the only two should be <code>code</code> (which refers to a python code plugin) and <code>mcp</code> (which refers to a Streamable HTTP MCP Server). Individual plugin types should have subclasses that provide additional metadata for that specific plugin type, when applicable. I'm thinking that, currently, <code>code</code> type plugins won't require additional metadata, but <code>mcp</code> will, though I'm not sure what it will be yet.</p> <p>Plugin auth will be applied at the plugin level and will be applicable for all tools in a given plugin (is this the right approach?). Governance will be applied to individual tools within a plugin.  I believe the other objects and fields are self-explanatory.</p> <p>The Plugin catalog will need to provide a method which allows the retrieval of the information about the plugin for a given plugin or tool ID. I'm not sure what the most appropriate lookup method will be, so for the time being let's accommodate both.</p> <p>The Plugin catalog should be implemented as an abstract class.</p> <p>We should define a single, initial implementation called <code>LocalPluginCatalog</code> which will simply read a JSON file from the local filesystem which contains the defined plugins.</p> <p>The application should rely on two new environment variables: <code>TA_PLUGIN_CATALOG_MODULE</code> - The path and file name of the module which will implement the desired plugin catalog provider class. <code>TA_PLUGIN_CATALOG_CLASS</code> - The name of the class within the module which implements the plugin catalog.</p> <p>Additionally, the initial <code>LocalPluginCatalog</code> implementation should leverage an additional environment variable <code>TA_PLUGIN_CATALOG_FILE</code> which will be the path to the JSON file containing the plugin definitions.</p> <p>Finally, we should additionally define a Plugin catalog factory which will be responsible for instantiating the plugin catalog based on the environment variables.</p> <p>This should use a Singleton pattern. Note, there's an existing <code>Singleton</code> class in the <code>ska-utils</code> package which can be used for this.</p> <p>Re-review @planning/2507-state-hitl-auth/04-03-hitl-implementation-plan.md to see where this catalog should be hooked in and include appropriate tasks to achieve that.</p>"},{"location":"planning/2507-state-hitl-auth/04-02-tool-catalog-implementation-plan/","title":"Phase 4 Implementation Plan: Plugin Catalog","text":"<p>This document outlines the development tasks to introduce a plugin catalog. This catalog will serve as a centralized repository for tool definitions and their associated metadata, such as governance policies (e.g., HITL requirements) and authentication details.</p> <p>This plan establishes an abstraction layer for the catalog, with an initial implementation that reads from a local JSON file.</p>"},{"location":"planning/2507-state-hitl-auth/04-02-tool-catalog-implementation-plan/#task-1-plugin-catalog-data-models","title":"Task 1: Plugin Catalog Data Models","text":"<p>Objective: Define the core Pydantic models that represent plugins, tools, and their metadata.</p> <ul> <li>File to Create: <code>src/sk_agents/plugincatalog/models.py</code></li> <li>Details: Implement the following Pydantic models. We will use discriminated unions to handle different plugin and auth types.</li> </ul> <pre><code>from typing import List, Literal, Union\nfrom pydantic import BaseModel, Field\n\n# PluginType Models\nclass CodePluginType(BaseModel):\n    type_name: Literal[\"code\"] = \"code\"\n\nclass McpPluginType(BaseModel):\n    type_name: Literal[\"mcp\"] = \"mcp\"\n    # Future metadata for MCP plugins will go here\n\nPluginType = Union[CodePluginType, McpPluginType]\n\n# Governance Model\nclass Governance(BaseModel):\n    requires_hitl: bool = False\n    cost: Literal[\"low\", \"medium\", \"high\"]\n    data_sensitivity: Literal[\"public\", \"proprietary\", \"confidential\", \"sensitive\"]\n\n# PluginAuth Models\nclass Oauth2PluginAuth(BaseModel):\n    auth_type: Literal[\"oauth2\"] = \"oauth2\"\n    auth_server: str\n    scopes: List[str]\n\nPluginAuth = Union[Oauth2PluginAuth]\n\n# Core Plugin Models\nclass PluginTool(BaseModel):\n    tool_id: str # Unique identifier, e.g., \"Shell-execute\"\n    name: str\n    description: str\n    governance: Governance\n\nclass Plugin(BaseModel):\n    plugin_id: str # e.g., \"Shell\"\n    name: str\n    description: str\n    version: str\n    owner: str\n    plugin_type: PluginType = Field(..., discriminator=\"type_name\")\n    auth: PluginAuth | None = Field(None, discriminator=\"auth_type\")\n    tools: List[PluginTool]\n\nclass PluginCatalogDefinition(BaseModel):\n    plugins: List[Plugin]\n</code></pre>"},{"location":"planning/2507-state-hitl-auth/04-02-tool-catalog-implementation-plan/#task-2-plugin-catalog-abstraction-and-factory","title":"Task 2: Plugin Catalog Abstraction and Factory","text":"<p>Objective: Create an abstract base class for the catalog and a singleton factory to instantiate the configured provider.</p> <ul> <li>Files to Create:<ul> <li><code>src/sk_agents/plugincatalog/plugin_catalog.py</code></li> <li><code>src/sk_agents/plugincatalog/plugin_catalog_factory.py</code></li> </ul> </li> <li>Details:<ol> <li>Define <code>PluginCatalog</code> ABC: This class will define the contract for all catalog implementations.     <pre><code># src/sk_agents/plugincatalog/plugin_catalog.py\nfrom abc import ABC, abstractmethod\nfrom .models import Plugin, PluginTool\n\nclass PluginCatalog(ABC):\n    @abstractmethod\n    def get_plugin(self, plugin_id: str) -&gt; Plugin | None:\n        ...\n\n    @abstractmethod\n    def get_tool(self, tool_id: str) -&gt; PluginTool | None:\n        ...\n</code></pre></li> <li>Implement <code>PluginCatalogFactory</code>: This factory will be a singleton responsible for creating the catalog instance based on environment variables. It should use the <code>Singleton</code> class from the <code>ska-utils</code> package.<ul> <li>It will read <code>TA_PLUGIN_CATALOG_MODULE</code> and <code>TA_PLUGIN_CATALOG_CLASS</code> to dynamically import and instantiate the catalog provider.</li> </ul> </li> </ol> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/04-02-tool-catalog-implementation-plan/#task-3-localplugincatalog-implementation","title":"Task 3: <code>LocalPluginCatalog</code> Implementation","text":"<p>Objective: Create a file-based implementation of the <code>PluginCatalog</code> for initial development and testing.</p> <ul> <li>File to Create: <code>src/sk_agents/plugincatalog/local_plugin_catalog.py</code></li> <li>Details:<ol> <li>Implement <code>LocalPluginCatalog</code>:<ul> <li>Inherit from <code>PluginCatalog</code>.</li> <li>In the constructor, read the JSON file path from the <code>TA_PLUGIN_CATALOG_FILE</code> environment variable.</li> <li>Load and parse the JSON file into the Pydantic models defined in Task 1.</li> <li>Create internal dictionaries to provide efficient lookups for <code>get_plugin()</code> and <code>get_tool()</code>.</li> </ul> </li> <li>Example <code>catalog.json</code>: <pre><code>{\n  \"plugins\": [\n    {\n      \"plugin_id\": \"Shell\",\n      \"name\": \"Shell\",\n      \"description\": \"Executes shell commands.\",\n      \"version\": \"1.0\",\n      \"owner\": \"system\",\n      \"plugin_type\": { \"type_name\": \"code\" },\n      \"auth\": null,\n      \"tools\": [\n        {\n          \"tool_id\": \"Shell-execute\",\n          \"name\": \"execute\",\n          \"description\": \"Executes a command in the shell.\",\n          \"governance\": {\n            \"requires_hitl\": true,\n            \"cost\": \"high\",\n            \"data_sensitivity\": \"sensitive\"\n          }\n        }\n      ]\n    }\n  ]\n}\n</code></pre></li> </ol> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/04-02-tool-catalog-implementation-plan/#task-4-integrate-catalog-with-hitl-manager","title":"Task 4: Integrate Catalog with HITL Manager","text":"<p>Objective: Update the HITL logic to use the plugin catalog to decide if an intervention is required.</p> <ul> <li>File to Modify: <code>src/sk_agents/hitl/hitl_manager.py</code></li> <li> <p>Details:</p> <ul> <li>The <code>check_for_intervention</code> function will be updated to use the catalog. The hardcoded logic will be removed.</li> <li>The function will construct a <code>tool_id</code> from the <code>FunctionCallContent</code> provided by the kernel. The convention will be <code>{plugin_name}-{function_name}</code>.</li> </ul> <pre><code># src/sk_agents/hitl/hitl_manager.py\nfrom semantic_kernel.contents.function_call_content import FunctionCallContent\nfrom sk_agents.plugincatalog import plugin_catalog_factory\n\ndef check_for_intervention(tool_call: FunctionCallContent) -&gt; bool:\n    \"\"\"\n    Checks the plugin catalog to determine if a tool call requires\n    Human-in-the-Loop intervention.\n    \"\"\"\n    catalog = plugin_catalog_factory.get_instance()\n    if not catalog:\n        # Fallback if catalog is not configured\n        return False\n\n    tool_id = f\"{tool_call.plugin_name}-{tool_call.function_name}\"\n    tool = catalog.get_tool(tool_id)\n\n    if tool:\n        print(f\"HITL Check: Intercepted call to {tool_id}. Requires HITL: {tool.governance.requires_hitl}\")\n        return tool.governance.requires_hitl\n\n    # Default to no intervention if tool is not in the catalog\n    return False\n</code></pre> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/04-02-tool-catalog-implementation-plan/#task-5-testing-strategy","title":"Task 5: Testing Strategy","text":"<p>Objective: Ensure the plugin catalog is correctly implemented and integrated.</p> <ul> <li>Files to Create/Modify:<ul> <li><code>demos/catalog.json</code> (a sample catalog for testing)</li> <li><code>tests/test_plugin_catalog.py</code> (new test file)</li> <li><code>tests/test_tealagents_handler.py</code> (modify existing tests)</li> </ul> </li> <li>Details:<ol> <li>Unit Tests (<code>test_plugin_catalog.py</code>):<ul> <li>Test <code>LocalPluginCatalog</code> can correctly load, parse, and validate a <code>catalog.json</code> file.</li> <li>Test successful lookups via <code>get_plugin()</code> and <code>get_tool()</code>.</li> <li>Test that lookups for non-existent IDs return <code>None</code>.</li> <li>Test the <code>PluginCatalogFactory</code> correctly instantiates the <code>LocalPluginCatalog</code>.</li> </ul> </li> <li>Integration Tests (<code>test_tealagents_handler.py</code>):<ul> <li>Modify the existing HITL tests.</li> <li>Point <code>TA_PLUGIN_CATALOG_FILE</code> to a test-specific catalog file.</li> <li>Verify that the HITL \"pause\" flow is triggered if and only if a tool with <code>requires_hitl: true</code> is called.</li> <li>Verify that tools not in the catalog or marked as <code>false</code> proceed without intervention.</li> </ul> </li> </ol> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/04-02-tool-catalog-implementation-plan/#task-6-environment-variables-and-configuration","title":"Task 6: Environment Variables and Configuration","text":"<p>Objective: Document the new environment variables for configuring the plugin catalog.</p> <ul> <li>Details: The application will now rely on the following environment variables:<ul> <li><code>TA_PLUGIN_CATALOG_MODULE</code>: The Python module path for the catalog implementation.<ul> <li>Default: <code>sk_agents.plugincatalog.local_plugin_catalog</code></li> </ul> </li> <li><code>TA_PLUGIN_CATALOG_CLASS</code>: The class name of the catalog implementation.<ul> <li>Default: <code>LocalPluginCatalog</code></li> </ul> </li> <li><code>TA_PLUGIN_CATALOG_FILE</code>: The absolute path to the JSON file containing plugin definitions (used by <code>LocalPluginCatalog</code>).<ul> <li>Default: <code>/app/catalog.json</code> (or another suitable default path)</li> </ul> </li> </ul> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/04-prompt/","title":"04 prompt","text":"<p>We are planning work a few weeks out for changes that need to be made to this workspace. Context about the work which is not yet completed is available in the following files:</p> <ul> <li>@planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan.md</li> <li>@planning/2507-state-hitl-auth/02-02-manual-tool-call-implementation-plan.md</li> <li>@planning/2507-state-hitl-auth/03-03-hitl-implementation-plan.md</li> </ul> <p>If helpful, there are additional files in the <code>planning/2507-state-hitl-auth</code> directory which can provide more context on the changes detailed in the above files.</p> <p>Create a set of tasks which, when completed, will introduce the functionality described in @planning/2507-state-hitl-auth/04-01-tool-catalog.md and save this set of tasks to a file called <code>04-02-tool-catalog-implementation-plan.md</code> in <code>planning/2507-state-hitl-auth</code> directory.</p>"},{"location":"planning/2507-state-hitl-auth/05-01-auth-infra-overview/","title":"Phase 5 - Authorization Overview","text":"<p>This document provides an overview of how the new authorization system will work for Teal Agents. Initially, it will only focus on OAuth 2.0, the design should be extensible to support other authorization types in the future.</p>"},{"location":"planning/2507-state-hitl-auth/05-01-auth-infra-overview/#overview","title":"Overview","text":"<p>The existing auth setup for teal agents is rudimentary and not scalable. As such, we will refactor and include the ability for the platform to dynamically understand the auth requirements for a particular tool and, when required, prompt the calling client to prompt the user to perform the appropriate authorization flow. We will begin with OAuth 2.0. The internal flow will go something like:</p> <ol> <li>Agent decides to use a tool</li> <li>Agent platform intercepts tool call response from LLM and retrieves the tool     metadata from the tool catalog (see phase 4)</li> <li>If the tool requires authorization (for now, OAuth 2.0), the platform will search     for an existing token for the given authorization server and scopes for this user     within the \"Secure Auth Storage Service\"</li> <li>If the token exists, it will be used to invoke the tool</li> <li>If the token does not exist, a new response type will be crafted and returned that     indicates to the client that the user needs to perform the appropriate authorization     flow. Note that the flow must be initiated from the agent platform (or possibly     directly to the authorization server but the callback must be the agent platform).</li> <li>The client will then prompt the user to perform the authorization flow, which will     involve redirecting the user to the authorization server, where they will log in and     authorize the tool. The client must also present an option to \"Resume\" the flow once     authorization has been completed.</li> <li>Once the user has authorized the tool, the authorization server will redirect the     user back to the agent platform with an authorization code. The agent platform will     then exchange this code for an access token and store it in the \"Secure Auth Storage     Service\" for future use.</li> <li>The agent platform will show a message indicating that authorization is complete and     the user can now close this window/tab and resume the agent flow.</li> <li>The user returns to the original client and clicks \"Resume\" to continue the agent     flow.</li> <li>The agent platform will resume the flow, now able to retrieve the appropriate access     token from the \"Secure Auth Storage Service\" and invoke the tool.</li> </ol>"},{"location":"planning/2507-state-hitl-auth/05-01-auth-infra-overview/#implementation-aspects-in-previous-phases","title":"Implementation Aspects in Previous Phases","text":"<p>Many changes are required to accommodate this new authorization flow. Some of the work has already been scoped, in previous phases:</p>"},{"location":"planning/2507-state-hitl-auth/05-01-auth-infra-overview/#phase-1","title":"Phase 1","text":"<ul> <li>Implementation plan defined in   @planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan.md</li> <li>Integrates the concept of State in to the Agent Platform, which is what will allow   individual agent flows to be paused and resumed.</li> </ul>"},{"location":"planning/2507-state-hitl-auth/05-01-auth-infra-overview/#phase-2","title":"Phase 2","text":"<ul> <li>Implementation plan defined in   @planning/2507-state-hitl-auth/02-02-manual-tool-call-implementation-plan.md</li> <li>Implements the ability for the agent platform to intercept tool calls and provides a   hook for tool evaluation prior to execution of the tool.</li> </ul>"},{"location":"planning/2507-state-hitl-auth/05-01-auth-infra-overview/#phase-3","title":"Phase 3","text":"<ul> <li>Implementation plan defined in   @planning/2507-state-hitl-auth/03-03-hitl-implementation-plan.md</li> <li>Introduces a \"resume\" endpoint that allows the client to resume an agent flow   after a HITL intervention. This is essential for the authorization flow, as it should   be extended to additionally support the resumption of the agent flow after the   authorization flow has been completed.</li> </ul>"},{"location":"planning/2507-state-hitl-auth/05-01-auth-infra-overview/#phase-4","title":"Phase 4","text":"<ul> <li>Implementation plan defined in   @planning/2507-state-hitl-auth/04-02-tool-catalog-implementation-plan.md</li> <li>Implements the tool catalog, which is where the agent platform will retrieve the   tool metadata to determine if authorization is required and, if so, provide the   relevant details to craft the appropriate response to the client.</li> </ul>"},{"location":"planning/2507-state-hitl-auth/05-01-auth-infra-overview/#remaining-work","title":"Remaining Work","text":"<p>Upon completion of phases 1-4, agent task state should be available. We should have the ability to intercept tool calls and evaluate them, and we should have a tool catalog which contains the appropriate metadata for each tool. To introduce tool authorization, we still need to implement the following:</p> <ol> <li>The ability to store and retrieve the required tool authorization information for a    given user and tool.</li> <li>The ability to craft and send an appropriate response to the client when a tool    requires authorization and for which no appropriate authorization information is    available.</li> <li>The ability to either initiate the authorization flow from the agent platform or    simply receive the callback from the authorization server, retrieve/store the needed    authorization information, and inform the user that the agent flow can be resumed.</li> <li>The ability to resume the agent flow once the user has completed the authorization    flow and returned to the client.</li> </ol>"},{"location":"planning/2507-state-hitl-auth/05-02-01-prompt/","title":"05 02 01 prompt","text":"<p>@planning/2507-state-hitl-auth/04-01-tool-catalog.md</p> <p>@planning/2507-state-hitl-auth/01-02-state-refactor-implementation-plan.md</p> <p>@planning/2507-state-hitl-auth/02-01-manual-tool-call.md</p> <p>@planning/2507-state-hitl-auth/02-02-manual-tool-call-implementation-plan.md</p> <p>@planning/2507-state-hitl-auth/04-02-tool-catalog-implementation-plan.md</p> <p>@planning/2507-state-hitl-auth/03-02-hitl.md</p> <p>@planning/2507-state-hitl-auth/00-teal-agents-overview.md</p> <p>@planning/2507-state-hitl-auth/03-01-hitl-baseline.md</p> <p>@planning/2507-state-hitl-auth/03-03-hitl-implementation-plan.md</p> <p>@planning/2507-state-hitl-auth/05-01-auth-infra-overview.md</p> <p>@planning/2507-state-hitl-auth/01-01-state-refactor.md</p> <p>@planning/2507-state-hitl-auth/05-02-01-secure-auth-storage.md</p> <p>We are planning phase 5 of future work to extend this agent platform, which introduces user/tool-specific authorization capability. For an overview of all phase 5 work and relevant background, see 05-01-auth-infra-overview.md (as well as any referenced sources).</p> <p>The scope of this first step in phase 5 is defined in 05-02-01-secure-auth-storage.md.</p> <p>Create a new file at planning/2507-state-hitl-auth/05-02-02-secure-auth-storage-implementation-plan.md which provides a detailed implementation plan for this first step.</p> <p>Notes: * I prefer pydantic BaseModel classes over dataclasses</p>"},{"location":"planning/2507-state-hitl-auth/05-02-01-secure-auth-storage/","title":"Secure Auth Storage Service Requirement","text":"<p>This is the first step in this phase 5 introduction of authorization in to the agent platform. We will introduce an abstraction for the \"Secure Auth Storage Service\" that enable the agent platform to store and retrieve tool authorization information.</p> <p>For an overview of the scope of phase 5, see @planning/2507-state-hitl-auth/05-01-auth-infra-overview.md.</p>"},{"location":"planning/2507-state-hitl-auth/05-02-01-secure-auth-storage/#requirements","title":"Requirements","text":"<ul> <li>Introduce a new abstract class <code>SecureAuthStorageManager</code> that defines the interface   for storing and retrieving tool authorization information for a given user and tool.   We are targeting only OAuth 2.0, presently, but when designing the interface, it   should be flexible enough to accommodate other authorization mechanisms in the future.</li> <li>For OAuth 2.0 implementation type, tokens should be reusable for any tool that   leverages the same authorization server and scopes.</li> <li>Implement a concrete class <code>InMemorySecureAuthStorageManager</code> that implements the   <code>SecureAuthStorageManager</code> interface and stores the authorization information in   memory.</li> <li>Introduce a factor class that will return an appropriate singleton instance of the   configured <code>SecureAuthStorageManager</code> implementation as defined in the environment   variables:<ul> <li><code>TA_SECURE_AUTH_STORAGE_MANAGER_MODULE</code> - The module path to the   <code>SecureAuthStorageManager</code> implementation.</li> <li><code>TA_SECURE_AUTH_STORAGE_MANAGER_CLASS</code> - The class name of the   <code>SecureAuthStorageManager</code> implementation.</li> </ul> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/05-02-02-secure-auth-storage-implementation-plan/","title":"Phase 5 Implementation Plan: Secure Auth Storage Service","text":"<p>This document provides a detailed implementation plan for creating the Secure Auth Storage Service, as required by <code>05-02-01-secure-auth-storage.md</code>. This service will provide a flexible and abstract way to store and retrieve user-specific authorization credentials for tools.</p> <p>The initial implementation will focus on an in-memory storage solution for OAuth 2.0 tokens, with a design that is extensible for future auth mechanisms and persistent storage backends.</p>"},{"location":"planning/2507-state-hitl-auth/05-02-02-secure-auth-storage-implementation-plan/#task-1-data-models-for-authentication-data","title":"Task 1: Data Models for Authentication Data","text":"<p>Objective: Define the Pydantic models for storing different types of authentication credentials. This ensures a structured and validated approach to data handling.</p> <ul> <li>Directory to Create: <code>src/sk_agents/auth_storage/</code></li> <li>File to Create: <code>src/sk_agents/auth_storage/models.py</code></li> <li>Details:<ul> <li>Create a discriminated union of Pydantic models to represent various auth types.</li> <li>The initial implementation will only include a model for OAuth 2.0.</li> </ul> </li> </ul> <pre><code># src/sk_agents/auth_storage/models.py\nfrom datetime import datetime\nfrom typing import List, Literal, Union\nfrom pydantic import BaseModel, Field\n\nclass BaseAuthData(BaseModel):\n    \"\"\"Base model for all authentication data types.\"\"\"\n    auth_type: str\n\nclass OAuth2AuthData(BaseAuthData):\n    \"\"\"Model for storing OAuth 2.0 credentials.\"\"\"\n    auth_type: Literal[\"oauth2\"] = \"oauth2\"\n    access_token: str\n    refresh_token: str | None = None\n    expires_at: datetime\n    # The scopes this token is valid for.\n    scopes: List[str]\n\n# A union of all supported auth data types.\nAuthData = Union[OAuth2AuthData]\n</code></pre>"},{"location":"planning/2507-state-hitl-auth/05-02-02-secure-auth-storage-implementation-plan/#task-2-secure-auth-storage-abstraction","title":"Task 2: Secure Auth Storage Abstraction","text":"<p>Objective: Define an abstract base class (<code>ABC</code>) that establishes the contract for all secure auth storage implementations.</p> <ul> <li>File to Create: <code>src/sk_agents/auth_storage/secure_auth_storage_manager.py</code></li> <li>Details:<ul> <li>The ABC will define the core methods for storing, retrieving, and deleting user-specific auth data based on a key.</li> <li>For OAuth 2.0, the <code>key</code> must be a composite key generated from the authorization server URL and the sorted list of required scopes (e.g., <code>f\"{auth_server}|{sorted(scopes)}\"</code>). This ensures that tokens are only reused when the exact set of permissions is required.</li> </ul> </li> </ul> <pre><code># src/sk_agents/auth_storage/secure_auth_storage_manager.py\nfrom abc import ABC, abstractmethod\nfrom .models import AuthData\n\nclass SecureAuthStorageManager(ABC):\n    \"\"\"Abstract interface for storing and retrieving tool authorization information.\"\"\"\n\n    @abstractmethod\n    def store(self, user_id: str, key: str, data: AuthData) -&gt; None:\n        \"\"\"Stores authorization data for a given user and key.\"\"\"\n        ...\n\n    @abstractmethod\n    def retrieve(self, user_id: str, key: str) -&gt; AuthData | None:\n        \"\"\"Retrieves authorization data for a given user and key.\"\"\"\n        ...\n\n    @abstractmethod\n    def delete(self, user_id: str, key: str) -&gt; None:\n        \"\"\"Deletes authorization data for a given user and key.\"\"\"\n        ...\n</code></pre>"},{"location":"planning/2507-state-hitl-auth/05-02-02-secure-auth-storage-implementation-plan/#task-3-in-memory-storage-implementation","title":"Task 3: In-Memory Storage Implementation","text":"<p>Objective: Create a concrete, thread-safe, in-memory implementation of the <code>SecureAuthStorageManager</code>.</p> <ul> <li>File to Create: <code>src/sk_agents/auth_storage/in_memory_secure_auth_storage_manager.py</code></li> <li>Details:<ul> <li>Implement the <code>InMemorySecureAuthStorageManager</code> class.</li> <li>Use a nested dictionary (<code>dict[str, dict[str, AuthData]]</code>) for storage.</li> <li>Employ <code>threading.Lock</code> to ensure all operations are thread-safe.</li> </ul> </li> </ul> <pre><code># src/sk_agents/auth_storage/in_memory_secure_auth_storage_manager.py\nimport threading\nfrom .models import AuthData\nfrom .secure_auth_storage_manager import SecureAuthStorageManager\n\nclass InMemorySecureAuthStorageManager(SecureAuthStorageManager):\n    \"\"\"A thread-safe, in-memory implementation of the SecureAuthStorageManager.\"\"\"\n    def __init__(self):\n        self._storage: dict[str, dict[str, AuthData]] = {}\n        self._lock = threading.Lock()\n\n    def store(self, user_id: str, key: str, data: AuthData) -&gt; None:\n        with self._lock:\n            if user_id not in self._storage:\n                self._storage[user_id] = {}\n            self._storage[user_id][key] = data\n\n    def retrieve(self, user_id: str, key: str) -&gt; AuthData | None:\n        with self._lock:\n            return self._storage.get(user_id, {}).get(key)\n\n    def delete(self, user_id: str, key: str) -&gt; None:\n        with self._lock:\n            if user_id in self._storage and key in self._storage[user_id]:\n                del self._storage[user_id][key]\n</code></pre>"},{"location":"planning/2507-state-hitl-auth/05-02-02-secure-auth-storage-implementation-plan/#task-4-singleton-factory-implementation","title":"Task 4: Singleton Factory Implementation","text":"<p>Objective: Develop a factory that provides a single, shared instance of the configured <code>SecureAuthStorageManager</code>.</p> <ul> <li>File to Create: <code>src/sk_agents/auth_storage/auth_storage_factory.py</code></li> <li>Details:<ul> <li>The factory will dynamically import and instantiate the manager class based on environment variables.</li> <li>It will follow the singleton pattern used by other factories in the project (e.g., <code>PersistenceFactory</code>).</li> </ul> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/05-02-02-secure-auth-storage-implementation-plan/#task-5-testing-strategy","title":"Task 5: Testing Strategy","text":"<p>Objective: Ensure the reliability, correctness, and thread safety of the new auth storage components.</p> <ul> <li>File to Create: <code>tests/test_secure_auth_storage.py</code></li> <li>Details:<ol> <li>Unit Tests:<ul> <li>Verify that <code>OAuth2AuthData</code> model validation works as expected.</li> <li>Test the <code>InMemorySecureAuthStorageManager</code> for correct <code>store</code>, <code>retrieve</code>, and <code>delete</code> behavior.</li> <li>Write a multi-threaded test to confirm that concurrent read/write operations do not lead to race conditions or data corruption.</li> </ul> </li> <li>Factory Tests:<ul> <li>Test that the <code>AuthStorageFactory</code> correctly instantiates the <code>InMemorySecureAuthStorageManager</code> based on default environment variables.</li> <li>Confirm that the factory always returns the same singleton instance.</li> <li>Test error handling for invalid module or class names in environment variables.</li> </ul> </li> </ol> </li> </ul>"},{"location":"planning/2507-state-hitl-auth/05-02-02-secure-auth-storage-implementation-plan/#task-6-environment-variables-and-configuration","title":"Task 6: Environment Variables and Configuration","text":"<p>Objective: Document the new environment variables required for configuring the Secure Auth Storage Service.</p> <ul> <li>Details: The application will use the following environment variables:<ul> <li><code>TA_SECURE_AUTH_STORAGE_MANAGER_MODULE</code>: The Python module path for the storage manager implementation.<ul> <li>Default: <code>sk_agents.auth_storage.in_memory_secure_auth_storage_manager</code></li> </ul> </li> <li><code>TA_SECURE_AUTH_STORAGE_MANAGER_CLASS</code>: The class name of the storage manager implementation.<ul> <li>Default: <code>InMemorySecureAuthStorageManager</code></li> </ul> </li> </ul> </li> </ul>"}]}